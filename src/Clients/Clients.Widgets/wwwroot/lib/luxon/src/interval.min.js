/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/luxon@3.4.3/src/interval.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import DateTime,{friendlyDateTime}from"./datetime.js";import Duration from"./duration.js";import Settings from"./settings.js";import{InvalidArgumentError,InvalidIntervalError}from"./errors.js";import Invalid from"./impl/invalid.js";import Formatter from"./impl/formatter.js";import*as Formats from"./impl/formats.js";const INVALID="Invalid Interval";function validateStartEnd(t,i){return t&&t.isValid?i&&i.isValid?i<t?Interval.invalid("end before start",`The end of an interval must be after its start, but you had start=${t.toISO()} and end=${i.toISO()}`):null:Interval.invalid("missing or invalid end"):Interval.invalid("missing or invalid start")}export default class Interval{constructor(t){this.s=t.start,this.e=t.end,this.invalid=t.invalid||null,this.isLuxonInterval=!0}static invalid(t,i=null){if(!t)throw new InvalidArgumentError("need to specify a reason the Interval is invalid");const s=t instanceof Invalid?t:new Invalid(t,i);if(Settings.throwOnInvalid)throw new InvalidIntervalError(s);return new Interval({invalid:s})}static fromDateTimes(t,i){const s=friendlyDateTime(t),e=friendlyDateTime(i),r=validateStartEnd(s,e);return null==r?new Interval({start:s,end:e}):r}static after(t,i){const s=Duration.fromDurationLike(i),e=friendlyDateTime(t);return Interval.fromDateTimes(e,e.plus(s))}static before(t,i){const s=Duration.fromDurationLike(i),e=friendlyDateTime(t);return Interval.fromDateTimes(e.minus(s),e)}static fromISO(t,i){const[s,e]=(t||"").split("/",2);if(s&&e){let t,r,n,a;try{t=DateTime.fromISO(s,i),r=t.isValid}catch(e){r=!1}try{n=DateTime.fromISO(e,i),a=n.isValid}catch(e){a=!1}if(r&&a)return Interval.fromDateTimes(t,n);if(r){const s=Duration.fromISO(e,i);if(s.isValid)return Interval.after(t,s)}else if(a){const t=Duration.fromISO(s,i);if(t.isValid)return Interval.before(n,t)}}return Interval.invalid("unparsable",`the input "${t}" can't be parsed as ISO 8601`)}static isInterval(t){return t&&t.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(t="milliseconds"){return this.isValid?this.toDuration(t).get(t):NaN}count(t="milliseconds"){if(!this.isValid)return NaN;const i=this.start.startOf(t),s=this.end.startOf(t);return Math.floor(s.diff(i,t).get(t))+(s.valueOf()!==this.end.valueOf())}hasSame(t){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,t))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(t){return!!this.isValid&&this.s>t}isBefore(t){return!!this.isValid&&this.e<=t}contains(t){return!!this.isValid&&(this.s<=t&&this.e>t)}set({start:t,end:i}={}){return this.isValid?Interval.fromDateTimes(t||this.s,i||this.e):this}splitAt(...t){if(!this.isValid)return[];const i=t.map(friendlyDateTime).filter((t=>this.contains(t))).sort(),s=[];let{s:e}=this,r=0;for(;e<this.e;){const t=i[r]||this.e,n=+t>+this.e?this.e:t;s.push(Interval.fromDateTimes(e,n)),e=n,r+=1}return s}splitBy(t){const i=Duration.fromDurationLike(t);if(!this.isValid||!i.isValid||0===i.as("milliseconds"))return[];let s,{s:e}=this,r=1;const n=[];for(;e<this.e;){const t=this.start.plus(i.mapUnits((t=>t*r)));s=+t>+this.e?this.e:t,n.push(Interval.fromDateTimes(e,s)),e=s,r+=1}return n}divideEqually(t){return this.isValid?this.splitBy(this.length()/t).slice(0,t):[]}overlaps(t){return this.e>t.s&&this.s<t.e}abutsStart(t){return!!this.isValid&&+this.e==+t.s}abutsEnd(t){return!!this.isValid&&+t.e==+this.s}engulfs(t){return!!this.isValid&&(this.s<=t.s&&this.e>=t.e)}equals(t){return!(!this.isValid||!t.isValid)&&(this.s.equals(t.s)&&this.e.equals(t.e))}intersection(t){if(!this.isValid)return this;const i=this.s>t.s?this.s:t.s,s=this.e<t.e?this.e:t.e;return i>=s?null:Interval.fromDateTimes(i,s)}union(t){if(!this.isValid)return this;const i=this.s<t.s?this.s:t.s,s=this.e>t.e?this.e:t.e;return Interval.fromDateTimes(i,s)}static merge(t){const[i,s]=t.sort(((t,i)=>t.s-i.s)).reduce((([t,i],s)=>i?i.overlaps(s)||i.abutsStart(s)?[t,i.union(s)]:[t.concat([i]),s]:[t,s]),[[],null]);return s&&i.push(s),i}static xor(t){let i=null,s=0;const e=[],r=t.map((t=>[{time:t.s,type:"s"},{time:t.e,type:"e"}])),n=Array.prototype.concat(...r).sort(((t,i)=>t.time-i.time));for(const t of n)s+="s"===t.type?1:-1,1===s?i=t.time:(i&&+i!=+t.time&&e.push(Interval.fromDateTimes(i,t.time)),i=null);return Interval.merge(e)}difference(...t){return Interval.xor([this].concat(t)).map((t=>this.intersection(t))).filter((t=>t&&!t.isEmpty()))}toString(){return this.isValid?`[${this.s.toISO()} – ${this.e.toISO()})`:INVALID}toLocaleString(t=Formats.DATE_SHORT,i={}){return this.isValid?Formatter.create(this.s.loc.clone(i),t).formatInterval(this):INVALID}toISO(t){return this.isValid?`${this.s.toISO(t)}/${this.e.toISO(t)}`:INVALID}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:INVALID}toISOTime(t){return this.isValid?`${this.s.toISOTime(t)}/${this.e.toISOTime(t)}`:INVALID}toFormat(t,{separator:i=" – "}={}){return this.isValid?`${this.s.toFormat(t)}${i}${this.e.toFormat(t)}`:INVALID}toDuration(t,i){return this.isValid?this.e.diff(this.s,t,i):Duration.invalid(this.invalidReason)}mapEndpoints(t){return Interval.fromDateTimes(t(this.s),t(this.e))}}
//# sourceMappingURL=/sm/bb6a6290c30bc9f186302cd999f5fcc9486786d31017c6b48cc5a0276ed6afce.map