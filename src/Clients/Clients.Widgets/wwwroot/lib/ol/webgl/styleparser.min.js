/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/webgl/styleparser.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ShaderBuilder}from"./ShaderBuilder.js";import{ValueTypes,arrayToGlsl,expressionToGlsl,getStringNumberEquivalent,stringToGlsl,uniformNameForVariable}from"../style/expressions.js";import{asArray}from"../color.js";import{getUid}from"../util.js";export function packColor(e){const s=asArray(e);return[256*s[0]+s[1],256*s[2]+Math.round(255*s[3])]}const UNPACK_COLOR_FN="vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}";function getGlslSizeFromType(e){return e===ValueTypes.COLOR?2:e===ValueTypes.NUMBER_ARRAY?4:1}function getGlslTypeFromType(e){const s=getGlslSizeFromType(e);return s>1?`vec${s}`:"float"}function parseCommonSymbolProperties(e,s,t,o){let i;if(`${o}radius`in e&&"icon-"!==o?i=expressionToGlsl(t,e[`${o}radius`],ValueTypes.NUMBER):`${o}radius1`in e&&"shape-"===o&&(i=expressionToGlsl(t,e[`${o}radius1`],ValueTypes.NUMBER)),void 0!==i&&(`${o}stroke-width`in e&&(i=`(${i} + ${expressionToGlsl(t,e[`${o}stroke-width`],ValueTypes.NUMBER)} * 0.5)`),s.setSymbolSizeExpression(`vec2(${i} * 2. + 0.5)`)),`${o}scale`in e){const i=expressionToGlsl(t,e[`${o}scale`],ValueTypes.NUMBER|ValueTypes.NUMBER_ARRAY);s.setSymbolSizeExpression(`${s.getSymbolSizeExpression()} * ${i}`)}`${o}displacement`in e&&s.setSymbolOffsetExpression(expressionToGlsl(t,e[`${o}displacement`],ValueTypes.NUMBER_ARRAY)),`${o}rotation`in e&&s.setSymbolRotationExpression(expressionToGlsl(t,e[`${o}rotation`],ValueTypes.NUMBER)),`${o}rotate-with-view`in e&&s.setSymbolRotateWithView(!!e[`${o}rotate-with-view`])}function getColorFromDistanceField(e,s,t,o,i){let n="vec4(0.)";if(null!==s&&(n=s),null!==t&&null!==o){n=`mix(${t}, ${n}, ${`smoothstep(-${o} + 0.63, -${o} - 0.58, ${e})`})`}let a=`${n} * ${`(1.0 - smoothstep(-0.63, 0.58, ${e}))`}`;return null!==i&&(a=`${a} * ${i}`),a}function parseCircleProperties(e,s,t,o,i){i.functions.circleDistanceField="float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}",parseCommonSymbolProperties(e,s,o,"circle-");let n=null;"circle-opacity"in e&&(n=expressionToGlsl(i,e["circle-opacity"],ValueTypes.NUMBER));let a="coordsPx";if("circle-scale"in e){a=`coordsPx / ${expressionToGlsl(i,e["circle-scale"],ValueTypes.NUMBER|ValueTypes.NUMBER_ARRAY)}`}let l=null;"circle-fill-color"in e&&(l=expressionToGlsl(i,e["circle-fill-color"],ValueTypes.COLOR));let r=null;"circle-stroke-color"in e&&(r=expressionToGlsl(i,e["circle-stroke-color"],ValueTypes.COLOR));let c=expressionToGlsl(i,e["circle-radius"],ValueTypes.NUMBER),p=null;"circle-stroke-width"in e&&(p=expressionToGlsl(i,e["circle-stroke-width"],ValueTypes.NUMBER),c=`(${c} + ${p} * 0.5)`);const u=getColorFromDistanceField(`circleDistanceField(${a}, ${c})`,l,r,p,n);s.setSymbolColorExpression(u)}function parseShapeProperties(e,s,t,o,i){i.functions.round="float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}",i.functions.starDistanceField="float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}",i.functions.regularDistanceField="float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}",parseCommonSymbolProperties(e,s,o,"shape-");let n=null;"shape-opacity"in e&&(n=expressionToGlsl(i,e["shape-opacity"],ValueTypes.NUMBER));let a="coordsPx";if("shape-scale"in e){a=`coordsPx / ${expressionToGlsl(i,e["shape-scale"],ValueTypes.NUMBER|ValueTypes.NUMBER_ARRAY)}`}let l=null;"shape-fill-color"in e&&(l=expressionToGlsl(i,e["shape-fill-color"],ValueTypes.COLOR));let r=null;"shape-stroke-color"in e&&(r=expressionToGlsl(i,e["shape-stroke-color"],ValueTypes.COLOR));let c=null;"shape-stroke-width"in e&&(c=expressionToGlsl(i,e["shape-stroke-width"],ValueTypes.NUMBER));const p=expressionToGlsl(i,e["shape-points"],ValueTypes.NUMBER);let u,d="0.";if("shape-angle"in e&&(d=expressionToGlsl(i,e["shape-angle"],ValueTypes.NUMBER)),"shape-radius"in e){let s=expressionToGlsl(i,e["shape-radius"],ValueTypes.NUMBER);null!==c&&(s=`${s} + ${c} * 0.5`),u=`regularDistanceField(${a}, ${p}, ${s}, ${d})`}else{let s=expressionToGlsl(i,e["shape-radius1"],ValueTypes.NUMBER),t=expressionToGlsl(i,e["shape-radius2"],ValueTypes.NUMBER);null!==c&&(s=`${s} + ${c} * 0.5`,t=`${t} + ${c} * 0.5`),u=`starDistanceField(${a}, ${p}, ${t}, ${s}, ${d})`}const f=getColorFromDistanceField(u,l,r,c,n);s.setSymbolColorExpression(f)}function parseIconProperties(e,s,t,o,i){i.functions.samplePremultiplied="vec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {\n  vec4 color = texture2D(sampler, texCoord);\n  return vec4(color.rgb * color.a, color.a);\n}";let n,a,l="vec4(1.0)";"icon-color"in e&&(l=expressionToGlsl(i,e["icon-color"],ValueTypes.COLOR)),"icon-opacity"in e&&(l=`${l} * ${expressionToGlsl(i,e["icon-opacity"],ValueTypes.NUMBER)}`);const r=getUid(e);if("icon-src"in e?(n=new Image,n.crossOrigin=void 0===e["icon-cross-origin"]?"anonymous":e["icon-cross-origin"],n.src=e["icon-src"],t[`u_texture${r}_size`]=()=>n.complete?[n.width,n.height]:[0,0],a=`u_texture${r}_size`,s.addUniform(`vec2 u_texture${r}_size`)):(n=e["icon-img"],n instanceof HTMLImageElement?n.complete&&n.width&&n.height?a=arrayToGlsl([n.width,n.height]):(t[`u_texture${r}_size`]=()=>n.complete?[n.width,n.height]:[0,0],a=`u_texture${r}_size`):a=arrayToGlsl([n.width,n.height])),t[`u_texture${r}`]=n,s.addUniform(`sampler2D u_texture${r}`).setSymbolColorExpression(`${l} * samplePremultiplied(u_texture${r}, v_texCoord)`).setSymbolSizeExpression(a),"icon-width"in e&&"icon-height"in e&&s.setSymbolSizeExpression(`vec2(${expressionToGlsl(o,e["icon-width"],ValueTypes.NUMBER)}, ${expressionToGlsl(o,e["icon-height"],ValueTypes.NUMBER)})`),"icon-offset"in e&&"icon-size"in e){let t=expressionToGlsl(o,e["icon-offset"],ValueTypes.NUMBER_ARRAY);const i=expressionToGlsl(o,e["icon-size"],ValueTypes.NUMBER_ARRAY),n=s.getSymbolSizeExpression();if(s.setSymbolSizeExpression(i),"icon-offset-origin"in e)switch(e["icon-offset-origin"]){case"top-right":t=`vec2(v_quadSizePx.x, 0.) + ${i} * vec2(-1., 0.) + ${t} * vec2(-1., 1.)`;break;case"bottom-left":t=`vec2(0., v_quadSizePx.y) + ${i} * vec2(0., -1.) + ${t} * vec2(1., -1.)`;break;case"bottom-right":t=`v_quadSizePx - ${i} - ${t}`}s.setTextureCoordinateExpression(`(vec4((${t}).xyxy) + vec4(0., 0., ${i})) / (${n}).xyxy`)}if(parseCommonSymbolProperties(e,s,o,"icon-"),"icon-anchor"in e){const t=expressionToGlsl(o,e["icon-anchor"],ValueTypes.NUMBER_ARRAY);let i,n="1.0";"icon-scale"in e&&(n=expressionToGlsl(o,e["icon-scale"],ValueTypes.NUMBER|ValueTypes.NUMBER_ARRAY)),i="pixels"===e["icon-anchor-x-units"]&&"pixels"===e["icon-anchor-y-units"]?`${t} * ${n}`:"pixels"===e["icon-anchor-x-units"]?`${t} * vec2(vec2(${n}).x, v_quadSizePx.y)`:"pixels"===e["icon-anchor-y-units"]?`${t} * vec2(v_quadSizePx.x, vec2(${n}).x)`:`${t} * v_quadSizePx`;let a=`v_quadSizePx * vec2(0.5, -0.5) + ${i} * vec2(-1., 1.)`;if("icon-anchor-origin"in e)switch(e["icon-anchor-origin"]){case"top-right":a=`v_quadSizePx * -0.5 + ${i}`;break;case"bottom-left":a=`v_quadSizePx * 0.5 - ${i}`;break;case"bottom-right":a=`v_quadSizePx * vec2(-0.5, 0.5) + ${i} * vec2(1., -1.)`}s.setSymbolOffsetExpression(`${s.getSymbolOffsetExpression()} + ${a}`)}}function parseStrokeProperties(e,s,t,o,i){if("stroke-color"in e&&s.setStrokeColorExpression(expressionToGlsl(i,e["stroke-color"],ValueTypes.COLOR)),"stroke-width"in e&&s.setStrokeWidthExpression(expressionToGlsl(o,e["stroke-width"],ValueTypes.NUMBER)),"stroke-offset"in e&&s.setStrokeOffsetExpression(expressionToGlsl(o,e["stroke-offset"],ValueTypes.NUMBER)),"stroke-line-cap"in e&&s.setStrokeCapExpression(expressionToGlsl(o,e["stroke-line-cap"],ValueTypes.STRING)),"stroke-line-join"in e&&s.setStrokeJoinExpression(expressionToGlsl(o,e["stroke-line-join"],ValueTypes.STRING)),"stroke-miter-limit"in e&&s.setStrokeMiterLimitExpression(expressionToGlsl(o,e["stroke-miter-limit"],ValueTypes.NUMBER)),"stroke-line-dash"in e){i.functions.getSingleDashDistance=`float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl("square")}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl("round")}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;let t=e["stroke-line-dash"].map((e=>expressionToGlsl(i,e,ValueTypes.NUMBER)));t.length%2==1&&(t=[...t,...t]);let n="0.";"stroke-line-dash-offset"in e&&(n=expressionToGlsl(o,e["stroke-line-dash-offset"],ValueTypes.NUMBER));let a=JSON.stringify(e["stroke-line-dash"]).split("").reduce(((e,s)=>(e<<5)-e+s.charCodeAt(0)),0);a>>>=0;const l=`dashDistanceField_${a}`,r=t.map(((e,s)=>`float dashLength${s} = ${e};`)),c=t.map(((e,s)=>`dashLength${s}`)).join(" + ");let p="0.",u=`getSingleDashDistance(distance, radius, ${p}, dashLength0, totalDashLength, capType)`;for(let e=2;e<t.length;e+=2)p=`${p} + dashLength${e-2} + dashLength${e-1}`,u=`min(${u}, getSingleDashDistance(distance, radius, ${p}, dashLength${e}, totalDashLength, capType))`;i.functions[l]=`float ${l}(float distance, float radius, float capType) {\n  ${r.join("\n  ")}\n  float totalDashLength = ${c};\n  return ${u};\n}`,s.setStrokeDistanceFieldExpression(`${l}(currentLengthPx + ${n}, currentRadiusPx, capType)`)}}function parseFillProperties(e,s,t,o,i){"fill-color"in e&&s.setFillColorExpression(expressionToGlsl(i,e["fill-color"],ValueTypes.COLOR))}export function parseLiteralStyle(e){const s={inFragmentShader:!1,variables:[],attributes:[],functions:{},style:e},t={inFragmentShader:!0,variables:s.variables,attributes:[],functions:{},style:e},o=new ShaderBuilder,i={};if("icon-src"in e||"icon-img"in e?parseIconProperties(e,o,i,s,t):"shape-points"in e?parseShapeProperties(e,o,i,s,t):"circle-radius"in e&&parseCircleProperties(e,o,i,s,t),parseStrokeProperties(e,o,i,s,t),parseFillProperties(e,o,i,s,t),e.filter){const s=expressionToGlsl(t,e.filter,ValueTypes.BOOLEAN);o.setFragmentDiscardExpression(`!${s}`)}t.variables.forEach((function(s){const t=uniformNameForVariable(s.name);let n;o.addUniform(`${getGlslTypeFromType(s.type)} ${t}`),n=s.type===ValueTypes.STRING?()=>getStringNumberEquivalent(e.variables[s.name]):s.type===ValueTypes.COLOR?()=>packColor([...asArray(e.variables[s.name]||"#eee")]):s.type===ValueTypes.BOOLEAN?()=>e.variables[s.name]?1:0:()=>e.variables[s.name],i[t]=n})),t.attributes.forEach((function(e){s.attributes.find((s=>s.name===e.name))||s.attributes.push(e);let t=getGlslTypeFromType(e.type),i=`a_${e.name}`;e.type===ValueTypes.COLOR&&(t="vec4",i=`unpackColor(${i})`,o.addVertexShaderFunction(UNPACK_COLOR_FN)),o.addVarying(`v_${e.name}`,t,i)})),s.attributes.forEach((function(e){o.addAttribute(`${getGlslTypeFromType(e.type)} a_${e.name}`)}));const n=s.attributes.map((function(e){let s;return s=e.callback?e.callback:e.type===ValueTypes.STRING?s=>getStringNumberEquivalent(s.get(e.name)):e.type===ValueTypes.COLOR?s=>packColor([...asArray(s.get(e.name)||"#eee")]):e.type===ValueTypes.BOOLEAN?s=>s.get(e.name)?1:0:s=>s.get(e.name),{name:e.name,size:getGlslSizeFromType(e.type),callback:s}}));for(const e in s.functions)o.addVertexShaderFunction(s.functions[e]);for(const e in t.functions)o.addFragmentShaderFunction(t.functions[e]);return{builder:o,attributes:n.reduce(((e,s)=>({...e,[s.name]:{callback:s.callback,size:s.size}})),{}),uniforms:i}}
//# sourceMappingURL=/sm/4259720d8aee51c9e47406bdfd528f6c0c8747f438d4a245bd9cc049bebf2d52.map