/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/webgl/ShaderBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{colorToGlsl,numberToGlsl,stringToGlsl}from"../style/expressions.js";import{createDefaultStyle}from"../style/flat.js";const COMMON_HEADER="#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform float u_rotation;\nuniform vec4 u_renderExtent;\nuniform mediump int u_hitDetection;\n\nconst float PI = 3.141592653589793238;\nconst float TWO_PI = 2.0 * PI;\n",DEFAULT_STYLE=createDefaultStyle();export class ShaderBuilder{constructor(){this.uniforms_=[],this.attributes_=[],this.varyings_=[],this.hasSymbol_=!1,this.symbolSizeExpression_=`vec2(${numberToGlsl(DEFAULT_STYLE["circle-radius"])} + ${numberToGlsl(.5*DEFAULT_STYLE["circle-stroke-width"])})`,this.symbolRotationExpression_="0.0",this.symbolOffsetExpression_="vec2(0.0)",this.symbolColorExpression_=colorToGlsl(DEFAULT_STYLE["circle-fill-color"]),this.texCoordExpression_="vec4(0.0, 0.0, 1.0, 1.0)",this.discardExpression_="false",this.symbolRotateWithView_=!1,this.hasStroke_=!1,this.strokeWidthExpression_=numberToGlsl(DEFAULT_STYLE["stroke-width"]),this.strokeColorExpression_=colorToGlsl(DEFAULT_STYLE["stroke-color"]),this.strokeOffsetExpression_="0.",this.strokeCapExpression_=stringToGlsl("round"),this.strokeJoinExpression_=stringToGlsl("round"),this.strokeMiterLimitExpression_="10.",this.strokeDistanceFieldExpression_="-1000.",this.hasFill_=!1,this.fillColorExpression_=colorToGlsl(DEFAULT_STYLE["fill-color"]),this.vertexShaderFunctions_=[],this.fragmentShaderFunctions_=[]}addUniform(n){return this.uniforms_.push(n),this}addAttribute(n){return this.attributes_.push(n),this}addVarying(n,t,e){return this.varyings_.push({name:n,type:t,expression:e}),this}setSymbolSizeExpression(n){return this.hasSymbol_=!0,this.symbolSizeExpression_=n,this}getSymbolSizeExpression(){return this.symbolSizeExpression_}setSymbolRotationExpression(n){return this.symbolRotationExpression_=n,this}setSymbolOffsetExpression(n){return this.symbolOffsetExpression_=n,this}getSymbolOffsetExpression(){return this.symbolOffsetExpression_}setSymbolColorExpression(n){return this.hasSymbol_=!0,this.symbolColorExpression_=n,this}getSymbolColorExpression(){return this.symbolColorExpression_}setTextureCoordinateExpression(n){return this.texCoordExpression_=n,this}setFragmentDiscardExpression(n){return this.discardExpression_=n,this}setSymbolRotateWithView(n){return this.symbolRotateWithView_=n,this}setStrokeWidthExpression(n){return this.hasStroke_=!0,this.strokeWidthExpression_=n,this}setStrokeColorExpression(n){return this.hasStroke_=!0,this.strokeColorExpression_=n,this}setStrokeOffsetExpression(n){return this.strokeOffsetExpression_=n,this}setStrokeCapExpression(n){return this.strokeCapExpression_=n,this}setStrokeJoinExpression(n){return this.strokeJoinExpression_=n,this}setStrokeMiterLimitExpression(n){return this.strokeMiterLimitExpression_=n,this}setStrokeDistanceFieldExpression(n){return this.strokeDistanceFieldExpression_=n,this}setFillColorExpression(n){return this.hasFill_=!0,this.fillColorExpression_=n,this}addVertexShaderFunction(n){this.vertexShaderFunctions_.includes(n)||this.vertexShaderFunctions_.push(n)}addFragmentShaderFunction(n){this.fragmentShaderFunctions_.includes(n)||this.fragmentShaderFunctions_.push(n)}getSymbolVertexShader(){return this.hasSymbol_?`${COMMON_HEADER}\n${this.uniforms_.map((function(n){return"uniform "+n+";"})).join("\n")}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec4 a_hitColor;\n${this.attributes_.map((function(n){return"attribute "+n+";"})).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_.map((function(n){return"varying "+n.type+" "+n.name+";"})).join("\n")}\n${this.vertexShaderFunctions_.join("\n")}\nvec2 pxToScreen(vec2 coordPx) {\n  vec2 scaled = coordPx / u_viewportSizePx / 0.5;\n  ${this.symbolRotateWithView_?"scaled = vec2(scaled.x * cos(-u_rotation) - scaled.y * sin(-u_rotation), scaled.x * sin(-u_rotation) + scaled.y * cos(-u_rotation));":""}\n  return scaled;\n}\n\nvec2 screenToPx(vec2 coordScreen) {\n  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  v_quadSizePx = ${this.symbolSizeExpression_};\n  vec2 halfSizePx = v_quadSizePx * 0.5;\n  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};\n  vec2 offsetPx = centerOffsetPx;\n  if (a_index == 0.0) {\n    offsetPx -= halfSizePx;\n  } else if (a_index == 1.0) {\n    offsetPx += halfSizePx * vec2(1., -1.);\n  } else if (a_index == 2.0) {\n    offsetPx += halfSizePx;\n  } else {\n    offsetPx += halfSizePx * vec2(-1., 1.);\n  }\n  float angle = ${this.symbolRotationExpression_};\n  float c = cos(-angle);\n  float s = sin(-angle);\n  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);\n  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  gl_Position = center + vec4(pxToScreen(offsetPx), 0., 0.);\n  vec4 texCoord = ${this.texCoordExpression_};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  v_hitColor = a_hitColor;\n  v_angle = angle;\n  ${this.symbolRotateWithView_?"v_angle += u_rotation;":""}\n  c = cos(-v_angle);\n  s = sin(-v_angle);\n  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); \n  v_centerPx = screenToPx(center.xy) + centerOffsetPx;\n${this.varyings_.map((function(n){return"  "+n.name+" = "+n.expression+";"})).join("\n")}\n}`:null}getSymbolFragmentShader(){return this.hasSymbol_?`${COMMON_HEADER}\n${this.uniforms_.map((function(n){return"uniform "+n+";"})).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_.map((function(n){return"varying "+n.type+" "+n.name+";"})).join("\n")}\n${this.fragmentShaderFunctions_.join("\n")}\n\nvoid main(void) {\n  if (${this.discardExpression_}) { discard; }\n  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center\n  float c = cos(v_angle);\n  float s = sin(v_angle);\n  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);\n  gl_FragColor = ${this.symbolColorExpression_};\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.05) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`:null}getStrokeVertexShader(){return this.hasStroke_?`${COMMON_HEADER}\n${this.uniforms_.map((function(n){return"uniform "+n+";"})).join("\n")}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec2 a_segmentStart;\nattribute vec2 a_segmentEnd;\nattribute float a_parameters;\nattribute float a_distance;\nattribute vec2 a_joinAngles;\nattribute vec4 a_hitColor;\n${this.attributes_.map((function(n){return"attribute "+n+";"})).join("\n")}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n${this.varyings_.map((function(n){return"varying "+n.type+" "+n.name+";"})).join("\n")}\n${this.vertexShaderFunctions_.join("\n")}\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvec4 pxToScreen(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return vec4(screenPos, 0.0, 1.0);\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nvec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {\n  float halfAngle = joinAngle / 2.0;\n  float c = cos(halfAngle);\n  float s = sin(halfAngle);\n  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);\n  float length = 1.0 / s;\n  return angleBisectorNormal * length;\n}\n\nvec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {\n  // if on a cap or the join angle is too high, offset the line along the segment normal\n  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {\n    return point - normal * offsetPx;\n  }\n  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)\n  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;\n}\n\nvoid main(void) {\n  v_angleStart = a_joinAngles.x;\n  v_angleEnd = a_joinAngles.y;\n  float vertexNumber = a_parameters;\n\n  float lineWidth = ${this.strokeWidthExpression_};\n  float lineOffsetPx = ${this.strokeOffsetExpression_};\n\n  // compute segment start/end in px with offset\n  vec2 segmentStartPx = worldToPx(a_segmentStart);\n  vec2 segmentEndPx = worldToPx(a_segmentEnd);\n  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),\n  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);\n  \n  // compute current vertex position\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n  vec2 joinDirection;\n  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;\n  // if angle is too high, do not make a proper join\n  if (cos(angle) > 0.985 || isCap(angle)) {\n    joinDirection = normalPx * normalDir - tangentPx * tangentDir;\n  } else {\n    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);\n  }\n  positionPx = positionPx + joinDirection * lineWidth * 0.5;\n  gl_Position = pxToScreen(positionPx);\n\n  v_segmentStart = segmentStartPx;\n  v_segmentEnd = segmentEndPx;\n  v_width = lineWidth;\n  v_hitColor = a_hitColor;\n  v_distanceOffsetPx = a_distance / u_resolution;\n${this.varyings_.map((function(n){return"  "+n.name+" = "+n.expression+";"})).join("\n")}\n}`:null}getStrokeFragmentShader(){return this.hasStroke_?`${COMMON_HEADER}\n${this.uniforms_.map((function(n){return"uniform "+n+";"})).join("\n")}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n${this.varyings_.map((function(n){return"varying "+n.type+" "+n.name+";"})).join("\n")}\n${this.fragmentShaderFunctions_.join("\n")}\n\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  vec2 tangent = normalize(end - start);\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 startToPoint = point - start;\n  return abs(dot(startToPoint, normal)) - width * 0.5;\n}\n\nfloat buttCapDistanceField(vec2 point, vec2 start, vec2 end) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  return dot(startToPoint, -tangent);\n}\n\nfloat squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return buttCapDistanceField(point, start, end) - width * 0.5;\n}\n\nfloat roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment\n  return length(point - start) - width * 0.5 - onSegment;\n}\n\nfloat roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  float c = cos(joinAngle * 0.5);\n  float s = sin(joinAngle * 0.5);\n  float direction = -sign(sin(joinAngle));\n  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);\n  float radius = width * 0.5 * s;\n  return dot(startToPoint, bisector * direction) - radius;\n}\n\nfloat miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  if (cos(joinAngle) > 0.985) { // avoid risking a division by zero\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  float miterLength = 1. / sin(joinAngle * 0.5);\n  float miterLimit = ${this.strokeMiterLimitExpression_};\n  if (miterLength > miterLimit) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  return -1000.;\n}\n\nfloat capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {\n   if (capType == ${stringToGlsl("butt")}) {\n    return buttCapDistanceField(point, start, end);\n  } else if (capType == ${stringToGlsl("square")}) {\n    return squareCapDistanceField(point, start, end, width);\n  }\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {\n  if (joinType == ${stringToGlsl("bevel")}) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  } else if (joinType == ${stringToGlsl("miter")}) {\n    return miterJoinDistanceField(point, start, end, width, joinAngle);\n  }\n  return roundJoinDistanceField(point, start, end, width);\n}\n\nfloat computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {\n  if (isCap(joinAngle)) {\n    return capDistanceField(point, start, end, width, capType);\n  }\n  return joinDistanceField(point, start, end, width, joinAngle, joinType);\n}\n\nvoid main(void) {\n  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(currentPoint);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n\n  float segmentLength = length(v_segmentEnd - v_segmentStart);\n  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;\n  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);\n  vec2 startToPoint = currentPoint - v_segmentStart;\n  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; \n  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));\n  vec4 color = ${this.strokeColorExpression_} * u_globalAlpha;\n  float capType = ${this.strokeCapExpression_};\n  float joinType = ${this.strokeJoinExpression_};\n  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);\n  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);\n  float distance = max(\n    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),\n    max(segmentStartDistance, segmentEndDistance)\n  );\n  distance = max(distance, ${this.strokeDistanceFieldExpression_});\n  gl_FragColor = color * smoothstep(0., -1., distance);\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`:null}getFillVertexShader(){return this.hasFill_?`${COMMON_HEADER}\n${this.uniforms_.map((function(n){return"uniform "+n+";"})).join("\n")}\nattribute vec2 a_position;\nattribute vec4 a_hitColor;\n${this.attributes_.map((function(n){return"attribute "+n+";"})).join("\n")}\nvarying vec4 v_hitColor;\n${this.varyings_.map((function(n){return"varying "+n.type+" "+n.name+";"})).join("\n")}\n${this.vertexShaderFunctions_.join("\n")}\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n${this.varyings_.map((function(n){return"  "+n.name+" = "+n.expression+";"})).join("\n")}\n}`:null}getFillFragmentShader(){return this.hasFill_?`${COMMON_HEADER}\n${this.uniforms_.map((function(n){return"uniform "+n+";"})).join("\n")}\nvarying vec4 v_hitColor;\n${this.varyings_.map((function(n){return"varying "+n.type+" "+n.name+";"})).join("\n")}\n${this.fragmentShaderFunctions_.join("\n")}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nvoid main(void) {\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(gl_FragCoord.xy / u_pixelRatio);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.fillColorExpression_} * u_globalAlpha;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`:null}}
//# sourceMappingURL=/sm/b698439bed2cf06f1b0b26ff646a40f5144f392162f5620931e9f3a22d5f8b29.map