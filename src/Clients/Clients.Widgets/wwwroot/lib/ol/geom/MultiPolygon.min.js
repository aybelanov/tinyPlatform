/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/geom/MultiPolygon.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import MultiPoint from"./MultiPoint.js";import Polygon from"./Polygon.js";import SimpleGeometry from"./SimpleGeometry.js";import{assignClosestMultiArrayPoint,multiArrayMaxSquaredDelta}from"./flat/closest.js";import{closestSquaredDistanceXY}from"../extent.js";import{deflateMultiCoordinatesArray}from"./flat/deflate.js";import{extend}from"../array.js";import{getInteriorPointsOfMultiArray}from"./flat/interiorpoint.js";import{inflateMultiCoordinatesArray}from"./flat/inflate.js";import{intersectsLinearRingMultiArray}from"./flat/intersectsextent.js";import{linearRingssAreOriented,orientLinearRingsArray}from"./flat/orient.js";import{linearRingss as linearRingssArea}from"./flat/area.js";import{linearRingss as linearRingssCenter}from"./flat/center.js";import{linearRingssContainsXY}from"./flat/contains.js";import{quantizeMultiArray}from"./flat/simplify.js";class MultiPolygon extends SimpleGeometry{constructor(t,e,i){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!i&&!Array.isArray(t[0])){let s=this.getLayout();const n=t,r=[],o=[];for(let t=0,e=n.length;t<e;++t){const e=n[t];0===t&&(s=e.getLayout());const i=r.length,a=e.getEnds();for(let t=0,e=a.length;t<e;++t)a[t]+=i;extend(r,e.getFlatCoordinates()),o.push(a)}e=s,t=r,i=o}void 0!==e&&i?(this.setFlatCoordinates(e,t),this.endss_=i):this.setCoordinates(t,e)}appendPolygon(t){let e;if(this.flatCoordinates){const i=this.flatCoordinates.length;extend(this.flatCoordinates,t.getFlatCoordinates()),e=t.getEnds().slice();for(let t=0,s=e.length;t<s;++t)e[t]+=i}else this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();this.endss_.push(e),this.changed()}clone(){const t=this.endss_.length,e=new Array(t);for(let i=0;i<t;++i)e[i]=this.endss_[i].slice();const i=new MultiPolygon(this.flatCoordinates.slice(),this.layout,e);return i.applyProperties(this),i}closestPointXY(t,e,i,s){return s<closestSquaredDistanceXY(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,i,s))}containsXY(t,e){return linearRingssContainsXY(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)}getArea(){return linearRingssArea(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(t){let e;return void 0!==t?(e=this.getOrientedFlatCoordinates().slice(),orientLinearRingsArray(e,0,this.endss_,this.stride,t)):e=this.flatCoordinates,inflateMultiCoordinatesArray(e,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const t=linearRingssCenter(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new MultiPoint(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;linearRingssAreOriented(t,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=orientLinearRingsArray(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[],i=[];return e.length=quantizeMultiArray(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,i),new MultiPolygon(e,"XY",i)}getPolygon(t){if(t<0||this.endss_.length<=t)return null;let e;if(0===t)e=0;else{const i=this.endss_[t-1];e=i[i.length-1]}const i=this.endss_[t].slice(),s=i[i.length-1];if(0!==e)for(let t=0,s=i.length;t<s;++t)i[t]-=e;return new Polygon(this.flatCoordinates.slice(e,s),this.layout,i)}getPolygons(){const t=this.layout,e=this.flatCoordinates,i=this.endss_,s=[];let n=0;for(let r=0,o=i.length;r<o;++r){const o=i[r].slice(),a=o[o.length-1];if(0!==n)for(let t=0,e=o.length;t<e;++t)o[t]-=n;const l=new Polygon(e.slice(n,a),t,o);s.push(l),n=a}return s}getType(){return"MultiPolygon"}intersectsExtent(t){return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);const i=deflateMultiCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.endss_);if(0===i.length)this.flatCoordinates.length=0;else{const t=i[i.length-1];this.flatCoordinates.length=0===t.length?0:t[t.length-1]}this.changed()}}export default MultiPolygon;
//# sourceMappingURL=/sm/08645a746378ba623287559a167d506788ebe0f7315a2b4f9dc2be3b06671b45.map