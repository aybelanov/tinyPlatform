/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/source/GeoTIFF.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import DataTile from"./DataTile.js";import TileGrid from"../tilegrid/TileGrid.js";import{Pool,globals as geotiffGlobals,fromBlob as tiffFromBlob,fromUrl as tiffFromUrl,fromUrls as tiffFromUrls}from"geotiff";import{Projection,get as getCachedProjection,toUserCoordinate,toUserExtent}from"../proj.js";import{clamp}from"../math.js";import{getCenter,getIntersection}from"../extent.js";import{error as logError}from"../console.js";import{fromCode as unitsFromCode}from"../proj/Units.js";function isMask(e){return 4==(4&(e.fileDirectory.NewSubfileType||0))}function readRGB(e,t){if(!e)return!1;if(!0===e)return!0;if(3!==t.getSamplesPerPixel())return!1;const o=t.fileDirectory.PhotometricInterpretation,r=geotiffGlobals.photometricInterpretations;return o===r.CMYK||o===r.YCbCr||o===r.CIELab||o===r.ICCLab}const STATISTICS_MAXIMUM="STATISTICS_MAXIMUM",STATISTICS_MINIMUM="STATISTICS_MINIMUM",defaultTileSize=256;let workerPool;function getWorkerPool(){return workerPool||(workerPool=new Pool),workerPool}function getBoundingBox(e){try{return e.getBoundingBox()}catch(t){return[0,0,e.getWidth(),e.getHeight()]}}function getOrigin(e){try{return e.getOrigin().slice(0,2)}catch(t){return[0,e.getHeight()]}}function getResolutions(e,t){try{return e.getResolution(t)}catch(o){return[t.getWidth()/e.getWidth(),t.getHeight()/e.getHeight()]}}function getProjection(e){const t=e.geoKeys;if(!t)return null;if(t.ProjectedCSTypeGeoKey&&32767!==t.ProjectedCSTypeGeoKey){const e="EPSG:"+t.ProjectedCSTypeGeoKey;let o=getCachedProjection(e);if(!o){const r=unitsFromCode(t.ProjLinearUnitsGeoKey);r&&(o=new Projection({code:e,units:r}))}return o}if(t.GeographicTypeGeoKey&&32767!==t.GeographicTypeGeoKey){const e="EPSG:"+t.GeographicTypeGeoKey;let o=getCachedProjection(e);if(!o){const r=unitsFromCode(t.GeogAngularUnitsGeoKey);r&&(o=new Projection({code:e,units:r}))}return o}return null}function getImagesForTIFF(e){return e.getImageCount().then((function(t){const o=new Array(t);for(let r=0;r<t;++r)o[r]=e.getImage(r);return Promise.all(o)}))}function getImagesForSource(e,t){let o;return o=e.blob?tiffFromBlob(e.blob):e.overviews?tiffFromUrls(e.url,e.overviews,t):tiffFromUrl(e.url,t),o.then(getImagesForTIFF)}function assertEqual(e,t,o,r,n){if(Array.isArray(e)){const i=e.length;if(!Array.isArray(t)||i!=t.length){const e=new Error(r);throw n(e),e}for(let s=0;s<i;++s)assertEqual(e[s],t[s],o,r,n)}else if(Math.abs(e-t)>o*e)throw new Error(r)}function getMinForDataType(e){return e instanceof Int8Array?-128:e instanceof Int16Array?-32768:e instanceof Int32Array?-2147483648:e instanceof Float32Array?12e-39:0}function getMaxForDataType(e){return e instanceof Int8Array?127:e instanceof Uint8Array||e instanceof Uint8ClampedArray?255:e instanceof Int16Array?32767:e instanceof Uint16Array?65535:e instanceof Int32Array?2147483647:e instanceof Uint32Array?4294967295:e instanceof Float32Array?34e37:255}class GeoTIFFSource extends DataTile{constructor(e){super({state:"loading",tileGrid:null,projection:e.projection||null,opaque:e.opaque,transition:e.transition,interpolate:!1!==e.interpolate,wrapX:e.wrapX}),this.sourceInfo_=e.sources;const t=this.sourceInfo_.length;this.sourceOptions_=e.sourceOptions,this.sourceImagery_=new Array(t),this.sourceMasks_=new Array(t),this.resolutionFactors_=new Array(t),this.samplesPerPixel_,this.nodataValues_,this.metadata_,this.normalize_=!1!==e.normalize,this.addAlpha_=!1,this.error_=null,this.convertToRGB_=e.convertToRGB||!1,this.setKey(this.sourceInfo_.map((e=>e.url)).join(","));const o=this,r=new Array(t);for(let e=0;e<t;++e)r[e]=getImagesForSource(this.sourceInfo_[e],this.sourceOptions_);Promise.all(r).then((function(e){o.configure_(e)})).catch((function(e){logError(e),o.error_=e,o.setState("error")}))}getError(){return this.error_}determineProjection(e){const t=e[0];for(let e=t.length-1;e>=0;--e){const o=getProjection(t[e]);if(o){this.projection=o;break}}}configure_(e){let t,o,r,n,i;const s=new Array(e.length),a=new Array(e.length),l=new Array(e.length);let c=0;const h=e.length;for(let u=0;u<h;++u){const h=[],g=[];e[u].forEach((e=>{isMask(e)?g.push(e):h.push(e)}));const f=h.length;if(g.length>0&&g.length!==f)throw new Error(`Expected one mask per image found ${g.length} masks and ${f} images`);let d,m;const p=new Array(f),y=new Array(f),I=new Array(f);a[u]=new Array(f),l[u]=new Array(f);for(let e=0;e<f;++e){const t=h[e],o=t.getGDALNoData();l[u][e]=t.getGDALMetadata(0),a[u][e]=o;const r=this.sourceInfo_[u].bands;s[u]=r?r.length:t.getSamplesPerPixel();const n=f-(e+1);d||(d=getBoundingBox(t)),m||(m=getOrigin(t));const i=getResolutions(t,h[0]);I[n]=i[0];const c=[t.getTileWidth(),t.getTileHeight()];c[0]!==c[1]&&c[1]<256&&(c[0]=256,c[1]=256),p[n]=c;const g=i[0]/Math.abs(i[1]);y[n]=[c[0],c[1]/g]}if(t?getIntersection(t,d,t):t=d,o){assertEqual(o,m,0,`Origin mismatch for source ${u}, got [${m}] but expected [${o}]`,this.viewRejector)}else o=m;if(i){i.length-c>I.length&&(c=i.length-I.length);const e=i[i.length-1]/I[I.length-1];this.resolutionFactors_[u]=e;const t=I.map((t=>t*e)),o=`Resolution mismatch for source ${u}, got [${t}] but expected [${i}]`;assertEqual(i.slice(c,i.length),t,.02,o,this.viewRejector)}else i=I,this.resolutionFactors_[u]=1;r?assertEqual(r.slice(c,r.length),y,.01,`Tile size mismatch for source ${u}`,this.viewRejector):r=y,n?assertEqual(n.slice(c,n.length),p,0,`Tile size mismatch for source ${u}`,this.viewRejector):n=p,this.sourceImagery_[u]=h.reverse(),this.sourceMasks_[u]=g.reverse()}for(let e=0,t=this.sourceImagery_.length;e<t;++e){const t=this.sourceImagery_[e];for(;t.length<i.length;)t.unshift(void 0)}this.getProjection()||this.determineProjection(e),this.samplesPerPixel_=s,this.nodataValues_=a,this.metadata_=l;e:for(let e=0;e<h;++e){if(void 0!==this.sourceInfo_[e].nodata){this.addAlpha_=!0;break}if(this.sourceMasks_[e].length){this.addAlpha_=!0;break}const t=a[e],o=this.sourceInfo_[e].bands;if(o){for(let e=0;e<o.length;++e)if(null!==t[o[e]-1]){this.addAlpha_=!0;break e}}else for(let e=0;e<t.length;++e)if(null!==t[e]){this.addAlpha_=!0;break e}}let u=this.addAlpha_?1:0;for(let e=0;e<h;++e)u+=s[e];this.bandCount=u;const g=new TileGrid({extent:t,minZoom:c,origin:o,resolutions:i,tileSizes:r});this.tileGrid=g,this.setTileSizes(n),this.setLoader(this.loadTile_.bind(this)),this.setState("ready");2===i.length?i=[i[0],i[1],i[1]/2]:1===i.length&&(i=[2*i[0],i[0],i[0]/2]),this.viewResolver({showFullExtent:!0,projection:this.projection,resolutions:i,center:toUserCoordinate(getCenter(t),this.projection),extent:toUserExtent(t,this.projection),zoom:1})}loadTile_(e,t,o){const r=this.getTileSize(e),n=this.sourceImagery_.length,i=new Array(2*n),s=this.nodataValues_,a=this.sourceInfo_,l=getWorkerPool();for(let c=0;c<n;++c){const h=a[c],u=this.resolutionFactors_[c],g=[Math.round(t*(r[0]*u)),Math.round(o*(r[1]*u)),Math.round((t+1)*(r[0]*u)),Math.round((o+1)*(r[1]*u))],f=this.sourceImagery_[c][e];let d,m;h.bands&&(d=h.bands.map((function(e){return e-1}))),m="nodata"in h&&null!==h.nodata?h.nodata:d?d.map((function(e){return s[c][e]})):s[c];const p={window:g,width:r[0],height:r[1],samples:d,fillValue:m,pool:l,interleave:!1};readRGB(this.convertToRGB_,f)?i[c]=f.readRGB(p):i[c]=f.readRasters(p);const y=n+c,I=this.sourceMasks_[c][e];I?i[y]=I.readRasters({window:g,width:r[0],height:r[1],samples:[0],pool:l,interleave:!1}):i[y]=Promise.resolve(null)}return Promise.all(i).then(this.composeTile_.bind(this,r)).catch((function(e){throw logError(e),e}))}composeTile_(e,t){const o=this.metadata_,r=this.sourceInfo_,n=this.sourceImagery_.length,i=this.bandCount,s=this.samplesPerPixel_,a=this.nodataValues_,l=this.normalize_,c=this.addAlpha_,h=e[0]*e[1],u=h*i;let g;g=l?new Uint8Array(u):new Float32Array(u);let f=0;for(let e=0;e<h;++e){let i=c;for(let h=0;h<n;++h){const u=r[h];let d,m,p=u.min,y=u.max;if(l){const e=o[h][0];void 0===p&&(p=e&&STATISTICS_MINIMUM in e?parseFloat(e[STATISTICS_MINIMUM]):getMinForDataType(t[h][0])),void 0===y&&(y=e&&STATISTICS_MAXIMUM in e?parseFloat(e[STATISTICS_MAXIMUM]):getMaxForDataType(t[h][0])),d=255/(y-p),m=-p*d}for(let o=0;o<s[h];++o){const r=t[h][o][e];let n;if(n=l?clamp(d*r+m,0,255):r,c){let e=u.nodata;if(void 0===e){let t;t=u.bands?u.bands[o]-1:o,e=a[h][t]}const t=isNaN(e);(!t&&r!==e||t&&!isNaN(r))&&(i=!1,g[f]=n)}else g[f]=n;f++}if(!i){const o=t[n+h];o&&!o[0][e]&&(i=!0)}}c&&(i||(g[f]=255),f++)}return g}}GeoTIFFSource.prototype.getView;export default GeoTIFFSource;
//# sourceMappingURL=/sm/4f2184d68cd075b6656f857f478e7207042673932de25eee665ffb4019a9c331.map