/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/source/Cluster.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import EventType from"../events/EventType.js";import Feature from"../Feature.js";import Point from"../geom/Point.js";import VectorSource from"./Vector.js";import{add as addCoordinate,scale as scaleCoordinate}from"../coordinate.js";import{assert}from"../asserts.js";import{buffer,createEmpty,createOrUpdateFromCoordinate,getCenter}from"../extent.js";import{getUid}from"../util.js";class Cluster extends VectorSource{constructor(t){super({attributions:t.attributions,wrapX:t.wrapX}),this.resolution=void 0,this.distance=void 0!==t.distance?t.distance:20,this.minDistance=t.minDistance||0,this.interpolationRatio=0,this.features=[],this.geometryFunction=t.geometryFunction||function(t){const e=t.getGeometry();return assert(!e||"Point"===e.getType(),"The default `geometryFunction` can only handle `Point` or null geometries"),e},this.createCustomCluster_=t.createCluster,this.source=null,this.boundRefresh_=this.refresh.bind(this),this.updateDistance(this.distance,this.minDistance),this.setSource(t.source||null)}clear(t){this.features.length=0,super.clear(t)}getDistance(){return this.distance}getSource(){return this.source}loadFeatures(t,e,s){this.source.loadFeatures(t,e,s),e!==this.resolution&&(this.resolution=e,this.refresh())}setDistance(t){this.updateDistance(t,this.minDistance)}setMinDistance(t){this.updateDistance(this.distance,t)}getMinDistance(){return this.minDistance}setSource(t){this.source&&this.source.removeEventListener(EventType.CHANGE,this.boundRefresh_),this.source=t,t&&t.addEventListener(EventType.CHANGE,this.boundRefresh_),this.refresh()}refresh(){this.clear(),this.cluster(),this.addFeatures(this.features)}updateDistance(t,e){const s=0===t?0:Math.min(e,t)/t,i=t!==this.distance||this.interpolationRatio!==s;this.distance=t,this.minDistance=e,this.interpolationRatio=s,i&&this.refresh()}cluster(){if(void 0===this.resolution||!this.source)return;const t=createEmpty(),e=this.distance*this.resolution,s=this.source.getFeatures(),i={};for(let r=0,o=s.length;r<o;r++){const o=s[r];if(!(getUid(o)in i)){const s=this.geometryFunction(o);if(s){const r=s.getCoordinates();createOrUpdateFromCoordinate(r,t),buffer(t,e,t);const o=this.source.getFeaturesInExtent(t).filter((function(t){const e=getUid(t);return!(e in i)&&(i[e]=!0,!0)}));this.features.push(this.createCluster(o,t))}}}}createCluster(t,e){const s=[0,0];for(let e=t.length-1;e>=0;--e){const i=this.geometryFunction(t[e]);i?addCoordinate(s,i.getCoordinates()):t.splice(e,1)}scaleCoordinate(s,1/t.length);const i=getCenter(e),r=this.interpolationRatio,o=new Point([s[0]*(1-r)+i[0]*r,s[1]*(1-r)+i[1]*r]);return this.createCustomCluster_?this.createCustomCluster_(o,t):new Feature({geometry:o,features:t})}}export default Cluster;
//# sourceMappingURL=/sm/90bfd65a42b5b7086b103998c81422c4776de868221b5843e2e2502823697868.map