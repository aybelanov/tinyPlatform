/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/source/Raster.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Disposable from"../Disposable.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import ImageCanvas from"../ImageCanvas.js";import ImageLayer from"../layer/Image.js";import ImageSource from"./Image.js";import Source from"./Source.js";import TileLayer from"../layer/Tile.js";import TileQueue from"../TileQueue.js";import TileSource from"./Tile.js";import{createCanvasContext2D}from"../dom.js";import{create as createTransform}from"../transform.js";import{equals,getCenter,getHeight,getWidth}from"../extent.js";import{getUid}from"../util.js";let context,hasImageData=!0;try{new ImageData(10,10)}catch(e){hasImageData=!1}export function newImageData(e,t,s){if(hasImageData)return new ImageData(e,t,s);context||(context=document.createElement("canvas").getContext("2d"));const r=context.createImageData(t,s);return r.data.set(e),r}function createMinion(e){let t=!0;try{new ImageData(10,10)}catch(e){t=!1}function s(e,s,r){return t?new ImageData(e,s,r):{data:e,width:s,height:r}}return function(t){const r=t.buffers,n=t.meta,a=t.imageOps,i=t.width,o=t.height,u=r.length,h=r[0].byteLength;if(a){const t=new Array(u);for(let e=0;e<u;++e)t[e]=s(new Uint8ClampedArray(r[e]),i,o);return e(t,n).data.buffer}const l=new Uint8ClampedArray(h),c=new Array(u),d=new Array(u);for(let e=0;e<u;++e)c[e]=new Uint8ClampedArray(r[e]),d[e]=[0,0,0,0];for(let t=0;t<h;t+=4){for(let e=0;e<u;++e){const s=c[e];d[e][0]=s[t],d[e][1]=s[t+1],d[e][2]=s[t+2],d[e][3]=s[t+3]}const s=e(d,n);l[t]=s[0],l[t+1]=s[1],l[t+2]=s[2],l[t+3]=s[3]}return l.buffer}}function createWorker(e,t){const s=Object.keys(e.lib||{}).map((function(t){return"const "+t+" = "+e.lib[t].toString()+";"})).concat(["const __minion__ = ("+createMinion.toString()+")(",e.operation.toString(),");",'self.addEventListener("message", function(event) {',"  const buffer = __minion__(event.data);","  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);","});"]),r=new Worker("undefined"==typeof Blob?"data:text/javascript;base64,"+Buffer.from(s.join("\n"),"binary").toString("base64"):URL.createObjectURL(new Blob(s,{type:"text/javascript"})));return r.addEventListener("message",t),r}function createFauxWorker(e,t){const s=createMinion(e.operation);let r=!1;return{postMessage:function(e){setTimeout((function(){r||t({data:{buffer:s(e),meta:e.meta}})}),0)},terminate:function(){r=!0}}}export class Processor extends Disposable{constructor(e){let t;super(),this._imageOps=!!e.imageOps,t=0===e.threads?0:this._imageOps?1:e.threads||1;const s=new Array(t);if(t)for(let r=0;r<t;++r)s[r]=createWorker(e,this._onWorkerMessage.bind(this,r));else s[0]=createFauxWorker(e,this._onWorkerMessage.bind(this,0));this._workers=s,this._queue=[],this._maxQueueLength=e.queue||1/0,this._running=0,this._dataLookup={},this._job=null}process(e,t,s){this._enqueue({inputs:e,meta:t,callback:s}),this._dispatch()}_enqueue(e){for(this._queue.push(e);this._queue.length>this._maxQueueLength;)this._queue.shift().callback(null,null)}_dispatch(){if(this._running||0===this._queue.length)return;const e=this._queue.shift();this._job=e;const t=e.inputs[0].width,s=e.inputs[0].height,r=e.inputs.map((function(e){return e.data.buffer})),n=this._workers.length;if(this._running=n,1===n)return void this._workers[0].postMessage({buffers:r,meta:e.meta,imageOps:this._imageOps,width:t,height:s},r);const a=e.inputs[0].data.length,i=4*Math.ceil(a/4/n);for(let a=0;a<n;++a){const n=a*i,o=[];for(let e=0,t=r.length;e<t;++e)o.push(r[e].slice(n,n+i));this._workers[a].postMessage({buffers:o,meta:e.meta,imageOps:this._imageOps,width:t,height:s},o)}}_onWorkerMessage(e,t){this.disposed||(this._dataLookup[e]=t.data,--this._running,0===this._running&&this._resolveJob())}_resolveJob(){const e=this._job,t=this._workers.length;let s,r;if(1===t)s=new Uint8ClampedArray(this._dataLookup[0].buffer),r=this._dataLookup[0].meta;else{const n=e.inputs[0].data.length;s=new Uint8ClampedArray(n),r=new Array(t);const a=4*Math.ceil(n/4/t);for(let e=0;e<t;++e){const t=this._dataLookup[e].buffer,n=e*a;s.set(new Uint8ClampedArray(t),n),r[e]=this._dataLookup[e].meta}}this._job=null,this._dataLookup={},e.callback(null,newImageData(s,e.inputs[0].width,e.inputs[0].height),r),this._dispatch()}disposeInternal(){for(let e=0;e<this._workers.length;++e)this._workers[e].terminate();this._workers.length=0}}const RasterEventType={BEFOREOPERATIONS:"beforeoperations",AFTEROPERATIONS:"afteroperations"};export class RasterSourceEvent extends Event{constructor(e,t,s){super(e),this.extent=t.extent,this.resolution=t.viewState.resolution/t.pixelRatio,this.data=s}}class RasterSource extends ImageSource{constructor(e){super({projection:null}),this.on,this.once,this.un,this.processor_=null,this.operationType_=void 0!==e.operationType?e.operationType:"pixel",this.threads_=void 0!==e.threads?e.threads:1,this.layers_=createLayers(e.sources);const t=this.changed.bind(this);for(let e=0,s=this.layers_.length;e<s;++e)this.layers_[e].addEventListener(EventType.CHANGE,t);this.useResolutions_=null!==e.resolutions,this.tileQueue_=new TileQueue((function(){return 1}),this.processSources_.bind(this)),this.requestedFrameState_,this.renderedImageCanvas_=null,this.renderedRevision_,this.frameState_={animate:!1,coordinateToPixelTransform:createTransform(),declutterTree:null,extent:null,index:0,layerIndex:0,layerStatesArray:getLayerStatesArray(this.layers_),pixelRatio:1,pixelToCoordinateTransform:createTransform(),postRenderFunctions:[],size:[0,0],tileQueue:this.tileQueue_,time:Date.now(),usedTiles:{},viewState:{rotation:0},viewHints:[],wantedTiles:{},mapId:getUid(this),renderTargets:{}},this.setAttributions((function(t){const s=[];for(let r=0,n=e.sources.length;r<n;++r){const n=e.sources[r],a=n instanceof Source?n:n.getSource();if(!a)continue;const i=a.getAttributions();if("function"==typeof i){const e=i(t);s.push.apply(s,e)}}return 0!==s.length?s:null})),void 0!==e.operation&&this.setOperation(e.operation,e.lib)}setOperation(e,t){this.processor_&&this.processor_.dispose(),this.processor_=new Processor({operation:e,imageOps:"image"===this.operationType_,queue:1,lib:t,threads:this.threads_}),this.changed()}updateFrameState_(e,t,s){const r=Object.assign({},this.frameState_);r.viewState=Object.assign({},r.viewState);const n=getCenter(e);r.size[0]=Math.ceil(getWidth(e)/t),r.size[1]=Math.ceil(getHeight(e)/t),r.extent=[n[0]-r.size[0]*t/2,n[1]-r.size[1]*t/2,n[0]+r.size[0]*t/2,n[1]+r.size[1]*t/2],r.time=Date.now();const a=r.viewState;return a.center=n,a.projection=s,a.resolution=t,r}allSourcesReady_(){let e,t=!0;for(let s=0,r=this.layers_.length;s<r;++s)if(e=this.layers_[s].getSource(),!e||"ready"!==e.getState()){t=!1;break}return t}getImage(e,t,s,r){if(!this.allSourcesReady_())return null;this.tileQueue_.loadMoreTiles(16,16),t=this.findNearestResolution(t);const n=this.updateFrameState_(e,t,r);if(this.requestedFrameState_=n,this.renderedImageCanvas_){const e=this.renderedImageCanvas_.getResolution(),s=this.renderedImageCanvas_.getExtent();t===e&&equals(n.extent,s)||(this.renderedImageCanvas_=null)}return this.renderedImageCanvas_&&this.getRevision()===this.renderedRevision_||this.processSources_(),n.animate&&requestAnimationFrame(this.changed.bind(this)),this.renderedImageCanvas_}processSources_(){const e=this.requestedFrameState_,t=this.layers_.length,s=new Array(t);for(let r=0;r<t;++r){e.layerIndex=r,e.renderTargets={};const t=getImageData(this.layers_[r],e);if(!t)return;s[r]=t}const r={};this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS,e,r)),this.processor_.process(s,r,this.onWorkerComplete_.bind(this,e))}onWorkerComplete_(e,t,s,r){if(t||!s)return;const n=e.extent,a=e.viewState.resolution;if(a!==this.requestedFrameState_.viewState.resolution||!equals(n,this.requestedFrameState_.extent))return;let i;if(this.renderedImageCanvas_)i=this.renderedImageCanvas_.getImage().getContext("2d");else{const e=Math.round(getWidth(n)/a),t=Math.round(getHeight(n)/a);i=createCanvasContext2D(e,t),this.renderedImageCanvas_=new ImageCanvas(n,a,1,i.canvas)}i.putImageData(s,0,0),e.animate?requestAnimationFrame(this.changed.bind(this)):this.changed(),this.renderedRevision_=this.getRevision(),this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS,e,r))}getResolutions(e){if(!this.useResolutions_)return null;let t=super.getResolutions();if(!t)for(let s=0,r=this.layers_.length;s<r;++s){if(t=this.layers_[s].getSource().getResolutions(e),t)break}return t}disposeInternal(){this.processor_&&this.processor_.dispose(),super.disposeInternal()}}RasterSource.prototype.dispose;let sharedContext=null;function getImageData(e,t){const s=e.getRenderer();if(!s)throw new Error("Unsupported layer type: "+e);if(!s.prepareFrame(t))return null;const r=t.size[0],n=t.size[1];if(0===r||0===n)return null;const a=s.renderFrame(t,null);let i;if(a instanceof HTMLCanvasElement)i=a;else{if(a&&(i=a.firstElementChild),!(i instanceof HTMLCanvasElement))throw new Error("Unsupported rendered element: "+i);if(i.width===r&&i.height===n){return i.getContext("2d").getImageData(0,0,r,n)}}if(sharedContext){const e=sharedContext.canvas;e.width!==r||e.height!==n?sharedContext=createCanvasContext2D(r,n,void 0,{willReadFrequently:!0}):sharedContext.clearRect(0,0,r,n)}else sharedContext=createCanvasContext2D(r,n,void 0,{willReadFrequently:!0});return sharedContext.drawImage(i,0,0,r,n),sharedContext.getImageData(0,0,r,n)}function getLayerStatesArray(e){return e.map((function(e){return e.getLayerState()}))}function createLayers(e){const t=e.length,s=new Array(t);for(let r=0;r<t;++r)s[r]=createLayer(e[r]);return s}function createLayer(e){let t;return e instanceof Source?e instanceof TileSource?t=new TileLayer({source:e}):e instanceof ImageSource&&(t=new ImageLayer({source:e})):t=e,t}export default RasterSource;
//# sourceMappingURL=/sm/d8345b9bbb6a7e58f592190df0c2655ca2a1fd7436fbc8bf07488110abb5e58f.map