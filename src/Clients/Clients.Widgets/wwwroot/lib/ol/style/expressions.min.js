/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/style/expressions.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import PaletteTexture from"../webgl/PaletteTexture.js";import{Uniforms}from"../renderer/webgl/TileLayer.js";import{asArray,fromString,isStringColor}from"../color.js";export const ValueTypes={NUMBER:1,STRING:2,COLOR:4,BOOLEAN:8,NUMBER_ARRAY:16,ANY:31,NONE:0};function getTypeFromHint(e){switch(e){case"string":return ValueTypes.STRING;case"color":return ValueTypes.COLOR;case"number":return ValueTypes.NUMBER;case"boolean":return ValueTypes.BOOLEAN;case"number[]":return ValueTypes.NUMBER_ARRAY;default:throw new Error(`Unrecognized type hint: ${e}`)}}export const Operators={};export function getValueType(e){if("number"==typeof e)return ValueTypes.NUMBER;if("boolean"==typeof e)return ValueTypes.BOOLEAN;if("string"==typeof e)return isStringColor(e)?ValueTypes.COLOR|ValueTypes.STRING:ValueTypes.STRING;if(!Array.isArray(e))throw new Error(`Unhandled value type: ${JSON.stringify(e)}`);const t=e;if(t.every((function(e){return"number"==typeof e})))return 3===t.length||4===t.length?ValueTypes.COLOR|ValueTypes.NUMBER_ARRAY:ValueTypes.NUMBER_ARRAY;if("string"!=typeof t[0])throw new Error(`Expected an expression operator but received: ${JSON.stringify(t)}`);const r=Operators[t[0]];if(void 0===r)throw new Error(`Unrecognized expression operator: ${JSON.stringify(t)}`);return r.getReturnType(t.slice(1))}export function isTypeUnique(e){return Math.log2(e)%1==0}function printTypes(e){const t=[];return(e&ValueTypes.NUMBER)>0&&t.push("number"),(e&ValueTypes.COLOR)>0&&t.push("color"),(e&ValueTypes.BOOLEAN)>0&&t.push("boolean"),(e&ValueTypes.NUMBER_ARRAY)>0&&t.push("number[]"),(e&ValueTypes.STRING)>0&&t.push("string"),t.length>0?t.join(", "):"(no type)"}function computeOperatorFunctionName(e,t){return`operator_${e}_${Object.keys(t.functions).length}`}export function numberToGlsl(e){const t=e.toString();return t.includes(".")?t:t+".0"}export function arrayToGlsl(e){if(e.length<2||e.length>4)throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");return`vec${e.length}(${e.map(numberToGlsl).join(", ")})`}export function colorToGlsl(e){const t=asArray(e),r=t.length>3?t[3]:1;return arrayToGlsl([t[0]/255*r,t[1]/255*r,t[2]/255*r,r])}const stringToFloatMap={};let stringToFloatCounter=0;export function getStringNumberEquivalent(e){return e in stringToFloatMap||(stringToFloatMap[e]=stringToFloatCounter++),stringToFloatMap[e]}export function stringToGlsl(e){return numberToGlsl(getStringNumberEquivalent(e))}export function expressionToGlsl(e,t,r){const s=void 0!==r?r:ValueTypes.NUMBER;if(Array.isArray(t)&&"string"==typeof t[0]){const r=Operators[t[0]];if(void 0===r)throw new Error(`Unrecognized expression operator: ${JSON.stringify(t)}`);return r.toGlsl(e,t.slice(1),s)}const n=getValueType(t)&s;if(assertNotEmptyType(t,n,""),(n&ValueTypes.NUMBER)>0)return numberToGlsl(t);if((n&ValueTypes.BOOLEAN)>0)return t.toString();if((n&ValueTypes.STRING)>0)return stringToGlsl(t.toString());if((n&ValueTypes.COLOR)>0)return colorToGlsl(t);if((n&ValueTypes.NUMBER_ARRAY)>0)return arrayToGlsl(t);throw new Error(`Unexpected expression ${t} (expected type ${printTypes(s)})`)}function assertNumber(e){if(0==(getValueType(e)&ValueTypes.NUMBER))throw new Error(`A numeric value was expected, got ${JSON.stringify(e)} instead`)}function assertNumbers(e){for(let t=0;t<e.length;t++)assertNumber(e[t])}function assertString(e){if(0==(getValueType(e)&ValueTypes.STRING))throw new Error(`A string value was expected, got ${JSON.stringify(e)} instead`)}function assertBoolean(e){if(0==(getValueType(e)&ValueTypes.BOOLEAN))throw new Error(`A boolean value was expected, got ${JSON.stringify(e)} instead`)}function assertArgsCount(e,t){if(e.length!==t)throw new Error(`Exactly ${t} arguments were expected, got ${e.length} instead`)}function assertArgsMinCount(e,t){if(e.length<t)throw new Error(`At least ${t} arguments were expected, got ${e.length} instead`)}function assertArgsMaxCount(e,t){if(e.length>t)throw new Error(`At most ${t} arguments were expected, got ${e.length} instead`)}function assertArgsEven(e){if(e.length%2!=0)throw new Error(`An even amount of arguments was expected, got ${JSON.stringify(e)} instead`)}function assertArgsOdd(e){if(e.length%2==0)throw new Error(`An odd amount of arguments was expected, got ${JSON.stringify(e)} instead`)}function assertNotEmptyType(e,t,r){if(t===ValueTypes.NONE)throw new Error(`No matching type was found for the following expression ${r}: ${JSON.stringify(e)}`)}function assertSingleType(e,t,r){if(assertNotEmptyType(e,t,r),!isTypeUnique(t))throw new Error(`Expected to have a unique type for the following expression ${r}: ${JSON.stringify(e)}\nGot the following types instead: ${printTypes(t)}`)}function assertOfType(e,t,r,s){if((t&r)===ValueTypes.NONE)throw new Error(`Expected the ${s} type of the following expression: ${JSON.stringify(e)} to be of the following types: ${printTypes(r)}\nGot these types instead: ${printTypes(t)}`)}Operators.get={getReturnType:function(e){if(2===e.length){return getTypeFromHint(e[1])}return ValueTypes.ANY},toGlsl:function(e,t,r){assertArgsMinCount(t,1),assertArgsMaxCount(t,2),assertString(t[0]);const s=r&Operators.get.getReturnType(t);assertSingleType(["get",...t],s,"");const n=t[0].toString(),o=e.attributes.find((e=>e.name===n));if(o){if(s!==o.type)throw new Error(`The following attribute was used in different places with incompatible types: ${n}\nTypes were: ${printTypes(o.type)} and ${printTypes(s)}`)}else e.attributes.push({name:n,type:s});return(e.inFragmentShader?"v_":"a_")+n}};export function uniformNameForVariable(e){return"u_var_"+e}Operators.var={getReturnType:function(){return ValueTypes.ANY},toGlsl:function(e,t,r){assertArgsCount(t,1),assertString(t[0]);const s=t[0].toString();if(!e.style.variables||void 0===e.style.variables[s])throw new Error(`The following variable is missing from the style: ${s}`);const n=r&getValueType(e.style.variables[s]);assertSingleType(["var",...t],n,"");const o=e.variables.find((e=>e.name===s));if(o){if(n!==o.type)throw new Error(`The following variable was used in different places with incompatible types: ${s}\nTypes were: ${printTypes(o.type)} and ${printTypes(n)}`)}else e.variables.push({name:s,type:n});return uniformNameForVariable(s)}};export const PALETTE_TEXTURE_ARRAY="u_paletteTextures";Operators.palette={getReturnType:function(){return ValueTypes.COLOR},toGlsl:function(e,t){assertArgsCount(t,2),assertNumber(t[0]);const r=expressionToGlsl(e,t[0]),s=t[1];if(!Array.isArray(s))throw new Error("The second argument of palette must be an array");const n=s.length,o=new Uint8Array(4*n);for(let e=0;e<n;e++){const t=s[e];let r;if("string"==typeof t)r=fromString(t);else{if(!Array.isArray(t))throw new Error("The second argument of palette must be an array of strings or colors");const e=t.length;if(4===e)r=t;else{if(3!==e)throw new Error(`Expected palette color to have 3 or 4 values, got ${e}`);r=[t[0],t[1],t[2],1]}}const n=4*e;o[n]=r[0],o[n+1]=r[1],o[n+2]=r[2],o[n+3]=255*r[3]}e.paletteTextures||(e.paletteTextures=[]);const l=`u_paletteTextures[${e.paletteTextures.length}]`,u=new PaletteTexture(l,o);return e.paletteTextures.push(u),`texture2D(${l}, vec2((${r} + 0.5) / ${n}.0, 0.5))`}};const GET_BAND_VALUE_FUNC="getBandValue";function getEqualOperator(e){return{getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(t,r){assertArgsCount(r,2);let s=ValueTypes.ANY;for(let e=0;e<r.length;e++)s&=getValueType(r[e]);if(s===ValueTypes.NONE)throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(r)} instead`);return s&=~ValueTypes.COLOR,`(${expressionToGlsl(t,r[0],s)} ${e} ${expressionToGlsl(t,r[1],s)})`}}}function getDecisionOperator(e){return{getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(t,r){assertArgsMinCount(r,2);for(let e=0;e<r.length;e++)assertBoolean(r[e]);let s=r.map((e=>expressionToGlsl(t,e,ValueTypes.BOOLEAN))).join(` ${e} `);return s=`(${s})`,s}}}Operators.band={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){assertArgsMinCount(t,1),assertArgsMaxCount(t,3);const r=t[0];if(!("getBandValue"in e.functions)){let t="";const r=e.bandCount||1;for(let e=0;e<r;e++){const s=Math.floor(e/4);let n=e%4;e===r-1&&1===n&&(n=3);t+=`\n          if (band == ${e+1}.0) {\n            return texture2D(${`${Uniforms.TILE_TEXTURE_ARRAY}[${s}]`}, v_textureCoord + vec2(dx, dy))[${n}];\n          }\n        `}e.functions.getBandValue=`\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${t}\n        }\n      `}return`getBandValue(${expressionToGlsl(e,r)}, ${expressionToGlsl(e,t[1]||0)}, ${expressionToGlsl(e,t[2]||0)})`}},Operators.time={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,0),"u_time"}},Operators.zoom={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,0),"u_zoom"}},Operators.resolution={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,0),"u_resolution"}},Operators["geometry-type"]={getReturnType:function(){return ValueTypes.STRING},toGlsl:function(e,t){assertArgsCount(t,0);const r="geometryType",s=e=>{const t=e.getType();switch(t){case"Point":case"LineString":case"Polygon":return t;case"MultiPoint":case"MultiLineString":case"MultiPolygon":return t.substring(5);case"Circle":return"Polygon";case"GeometryCollection":return s(e.getGeometries()[0])}};e.attributes.find((e=>e.name===r))||e.attributes.push({name:r,type:ValueTypes.STRING,callback:e=>s(e.getGeometry())});return(e.inFragmentShader?"v_":"a_")+r}},Operators["*"]={getReturnType:function(e){let t=ValueTypes.NUMBER|ValueTypes.COLOR;for(let r=0;r<e.length;r++)t&=getValueType(e[r]);return t},toGlsl:function(e,t,r){assertArgsMinCount(t,2);let s=r;for(let e=0;e<t.length;e++)s&=getValueType(t[e]);return assertOfType(t,s,ValueTypes.NUMBER|ValueTypes.COLOR,"output"),`(${t.map((t=>expressionToGlsl(e,t,s))).join(" * ")})`}},Operators["/"]={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} / ${expressionToGlsl(e,t[1])})`}},Operators["+"]={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsMinCount(t,2),assertNumbers(t),`(${t.map((t=>expressionToGlsl(e,t))).join(" + ")})`}},Operators["-"]={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} - ${expressionToGlsl(e,t[1])})`}},Operators.clamp={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){assertArgsCount(t,3),assertNumbers(t);const r=expressionToGlsl(e,t[1]),s=expressionToGlsl(e,t[2]);return`clamp(${expressionToGlsl(e,t[0])}, ${r}, ${s})`}},Operators["%"]={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`mod(${expressionToGlsl(e,t[0])}, ${expressionToGlsl(e,t[1])})`}},Operators["^"]={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`pow(${expressionToGlsl(e,t[0])}, ${expressionToGlsl(e,t[1])})`}},Operators.abs={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`abs(${expressionToGlsl(e,t[0])})`}},Operators.floor={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`floor(${expressionToGlsl(e,t[0])})`}},Operators.round={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`floor(${expressionToGlsl(e,t[0])} + 0.5)`}},Operators.ceil={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`ceil(${expressionToGlsl(e,t[0])})`}},Operators.sin={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`sin(${expressionToGlsl(e,t[0])})`}},Operators.cos={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`cos(${expressionToGlsl(e,t[0])})`}},Operators.atan={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsMinCount(t,1),assertArgsMaxCount(t,2),assertNumbers(t),2===t.length?`atan(${expressionToGlsl(e,t[0])}, ${expressionToGlsl(e,t[1])})`:`atan(${expressionToGlsl(e,t[0])})`}},Operators.sqrt={getReturnType:function(){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`sqrt(${expressionToGlsl(e,t[0])})`}},Operators[">"]={getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} > ${expressionToGlsl(e,t[1])})`}},Operators[">="]={getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} >= ${expressionToGlsl(e,t[1])})`}},Operators["<"]={getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} < ${expressionToGlsl(e,t[1])})`}},Operators["<="]={getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} <= ${expressionToGlsl(e,t[1])})`}},Operators["=="]=getEqualOperator("=="),Operators["!="]=getEqualOperator("!="),Operators["!"]={getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,1),assertBoolean(t[0]),`(!${expressionToGlsl(e,t[0],ValueTypes.BOOLEAN)})`}},Operators.all=getDecisionOperator("&&"),Operators.any=getDecisionOperator("||"),Operators.between={getReturnType:function(){return ValueTypes.BOOLEAN},toGlsl:function(e,t){assertArgsCount(t,3),assertNumbers(t);const r=expressionToGlsl(e,t[1]),s=expressionToGlsl(e,t[2]),n=expressionToGlsl(e,t[0]);return`(${n} >= ${r} && ${n} <= ${s})`}},Operators.array={getReturnType:function(){return ValueTypes.NUMBER_ARRAY},toGlsl:function(e,t){assertArgsMinCount(t,2),assertArgsMaxCount(t,4),assertNumbers(t);const r=t.map((function(t){return expressionToGlsl(e,t)}));return`vec${t.length}(${r.join(", ")})`}},Operators.color={getReturnType:function(){return ValueTypes.COLOR},toGlsl:function(e,t){assertArgsMinCount(t,3),assertArgsMaxCount(t,4),assertNumbers(t);const r=t.slice(0,3).map((t=>`${expressionToGlsl(e,t)} / 255.0`));if(3===t.length)return`vec4(${r.join(", ")}, 1.0)`;return`(${expressionToGlsl(e,t[3])} * vec4(${r.join(", ")}, 1.0))`}},Operators.interpolate={getReturnType:function(e){let t=ValueTypes.COLOR|ValueTypes.NUMBER;for(let r=3;r<e.length;r+=2)t&=getValueType(e[r]);return t},toGlsl:function(e,t,r){assertArgsEven(t),assertArgsMinCount(t,6);const s=t[0];let n;switch(s[0]){case"linear":n=1;break;case"exponential":n=s[1];break;default:n=null}if(!n)throw new Error(`Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(s)}`);const o=ValueTypes.NUMBER,l=Operators.interpolate.getReturnType(t)&r;assertSingleType(["interpolate",...t],l,"output");const u=expressionToGlsl(e,t[1],o),a=numberToGlsl(n);let i="";for(let r=2;r<t.length-2;r+=2){const s=expressionToGlsl(e,t[r],o),p=i||expressionToGlsl(e,t[r+1],l),T=expressionToGlsl(e,t[r+2],o);let y;y=1===n?`(${u} - ${s}) / (${T} - ${s})`:`(pow(${a}, (${u} - ${s})) - 1.0) / (pow(${a}, (${T} - ${s})) - 1.0)`,i=`mix(${p}, ${expressionToGlsl(e,t[r+3],l)}, clamp(${y}, 0.0, 1.0))`}return i}},Operators.match={getReturnType:function(e){let t=ValueTypes.ANY;for(let r=2;r<e.length;r+=2)t&=getValueType(e[r]);return t&=getValueType(e[e.length-1]),t},toGlsl:function(e,t,r){assertArgsEven(t),assertArgsMinCount(t,4);let s=getValueType(t[0]);for(let e=1;e<t.length-1;e+=2)s&=getValueType(t[e]);assertOfType(["match",...t],s,ValueTypes.STRING|ValueTypes.NUMBER|ValueTypes.BOOLEAN,"input"),s=(ValueTypes.STRING|ValueTypes.NUMBER|ValueTypes.BOOLEAN)&s;const n=Operators.match.getReturnType(t)&r;assertSingleType(["match",...t],n,"output");const o=expressionToGlsl(e,t[0],s),l=expressionToGlsl(e,t[t.length-1],n);let u=null;for(let r=t.length-3;r>=1;r-=2){u=`(${o} == ${expressionToGlsl(e,t[r],s)} ? ${expressionToGlsl(e,t[r+1],n)} : ${u||l})`}return u}},Operators.case={getReturnType:function(e){let t=ValueTypes.ANY;for(let r=1;r<e.length;r+=2)t&=getValueType(e[r]);return t&=getValueType(e[e.length-1]),t},toGlsl:function(e,t,r){assertArgsOdd(t),assertArgsMinCount(t,3);const s=Operators.case.getReturnType(t)&r;assertSingleType(["case",...t],s,"output");for(let e=0;e<t.length-1;e+=2)assertBoolean(t[e]);const n=expressionToGlsl(e,t[t.length-1],s);let o=null;for(let r=t.length-3;r>=0;r-=2){o=`(${expressionToGlsl(e,t[r],ValueTypes.BOOLEAN)} ? ${expressionToGlsl(e,t[r+1],s)} : ${o||n})`}return o}},Operators.in={getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(e,t){assertArgsCount(t,2);const r=t[0];let s=t[1];if(!Array.isArray(s))throw new Error('The "in" operator expects an array literal as its second argument.');if("string"==typeof s[0]){if("literal"!==s[0])throw new Error('For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.');if(!Array.isArray(s[1]))throw new Error('The "in" operator was provided a literal value which was not an array as second argument.');s=s[1]}let n=getValueType(r);for(let e=0;e<s.length-1;e+=1)n&=getValueType(s[e]);assertOfType(["match",...t],n,ValueTypes.STRING|ValueTypes.NUMBER|ValueTypes.BOOLEAN,"input"),n=(ValueTypes.STRING|ValueTypes.NUMBER|ValueTypes.BOOLEAN)&n;const o=computeOperatorFunctionName("in",e),l=[];for(let t=0;t<s.length;t+=1)l.push(`  if (inputValue == ${expressionToGlsl(e,s[t],n)}) { return true; }`);return e.functions[o]=`bool ${o}(float inputValue) {\n${l.join("\n")}\n  return false;\n}`,`${o}(${expressionToGlsl(e,r,n)})`}};
//# sourceMappingURL=/sm/2bec00b2b09653009a3feb2ce34082e3b48121c761e0435420e7a7f6d770d614.map