/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/style/RegularShape.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import ImageState from"../ImageState.js";import ImageStyle from"./Image.js";import{asArray}from"../color.js";import{asColorLike}from"../colorlike.js";import{createCanvasContext2D}from"../dom.js";import{defaultFillStyle,defaultLineCap,defaultLineJoin,defaultLineWidth,defaultMiterLimit,defaultStrokeStyle}from"../render/canvas.js";class RegularShape extends ImageStyle{constructor(t){super({opacity:1,rotateWithView:void 0!==t.rotateWithView&&t.rotateWithView,rotation:void 0!==t.rotation?t.rotation:0,scale:void 0!==t.scale?t.scale:1,displacement:void 0!==t.displacement?t.displacement:[0,0],declutterMode:t.declutterMode}),this.canvas_=void 0,this.hitDetectionCanvas_=null,this.fill_=void 0!==t.fill?t.fill:null,this.origin_=[0,0],this.points_=t.points,this.radius_=void 0!==t.radius?t.radius:t.radius1,this.radius2_=t.radius2,this.angle_=void 0!==t.angle?t.angle:0,this.stroke_=void 0!==t.stroke?t.stroke:null,this.size_=null,this.renderOptions_=null,this.render()}clone(){const t=this.getScale(),e=new RegularShape({fill:this.getFill()?this.getFill().clone():void 0,points:this.getPoints(),radius:this.getRadius(),radius2:this.getRadius2(),angle:this.getAngle(),stroke:this.getStroke()?this.getStroke().clone():void 0,rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),scale:Array.isArray(t)?t.slice():t,displacement:this.getDisplacement().slice(),declutterMode:this.getDeclutterMode()});return e.setOpacity(this.getOpacity()),e}getAnchor(){const t=this.size_;if(!t)return null;const e=this.getDisplacement(),i=this.getScaleArray();return[t[0]/2-e[0]/i[0],t[1]/2+e[1]/i[1]]}getAngle(){return this.angle_}getFill(){return this.fill_}setFill(t){this.fill_=t,this.render()}getHitDetectionImage(){return this.hitDetectionCanvas_||this.createHitDetectionCanvas_(this.renderOptions_),this.hitDetectionCanvas_}getImage(t){let e=this.canvas_[t];if(!e){const i=this.renderOptions_,s=createCanvasContext2D(i.size*t,i.size*t);this.draw_(i,s,t),e=s.canvas,this.canvas_[t]=e}return e}getPixelRatio(t){return t}getImageSize(){return this.size_}getImageState(){return ImageState.LOADED}getOrigin(){return this.origin_}getPoints(){return this.points_}getRadius(){return this.radius_}getRadius2(){return this.radius2_}getSize(){return this.size_}getStroke(){return this.stroke_}setStroke(t){this.stroke_=t,this.render()}listenImageChange(t){}load(){}unlistenImageChange(t){}calculateLineJoinSize_(t,e,i){if(0===e||this.points_===1/0||"bevel"!==t&&"miter"!==t)return e;let s=this.radius_,a=void 0===this.radius2_?s:this.radius2_;if(s<a){const t=s;s=a,a=t}const r=void 0===this.radius2_?this.points_:2*this.points_,n=2*Math.PI/r,l=a*Math.sin(n),o=s-Math.sqrt(a*a-l*l),h=Math.sqrt(l*l+o*o),d=h/l;if("miter"===t&&d<=i)return d*e;const u=e/2/d,c=e/2*(o/h),_=Math.sqrt((s+u)*(s+u)+c*c)-s;if(void 0===this.radius2_||"bevel"===t)return 2*_;const g=s*Math.sin(n),f=a-Math.sqrt(s*s-g*g),m=Math.sqrt(g*g+f*f)/g;if(m<=i){const t=m*e/2-a-s;return 2*Math.max(_,t)}return 2*_}createRenderOptions(){let t,e=defaultLineCap,i=defaultLineJoin,s=0,a=null,r=0,n=0;this.stroke_&&(t=this.stroke_.getColor(),null===t&&(t=defaultStrokeStyle),t=asColorLike(t),n=this.stroke_.getWidth(),void 0===n&&(n=defaultLineWidth),a=this.stroke_.getLineDash(),r=this.stroke_.getLineDashOffset(),i=this.stroke_.getLineJoin(),void 0===i&&(i=defaultLineJoin),e=this.stroke_.getLineCap(),void 0===e&&(e=defaultLineCap),s=this.stroke_.getMiterLimit(),void 0===s&&(s=defaultMiterLimit));const l=this.calculateLineJoinSize_(i,n,s),o=Math.max(this.radius_,this.radius2_||0);return{strokeStyle:t,strokeWidth:n,size:Math.ceil(2*o+l),lineCap:e,lineDash:a,lineDashOffset:r,lineJoin:i,miterLimit:s}}render(){this.renderOptions_=this.createRenderOptions();const t=this.renderOptions_.size;this.canvas_={},this.size_=[t,t]}draw_(t,e,i){if(e.scale(i,i),e.translate(t.size/2,t.size/2),this.createPath_(e),this.fill_){let t=this.fill_.getColor();null===t&&(t=defaultFillStyle),e.fillStyle=asColorLike(t),e.fill()}this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineCap=t.lineCap,e.lineJoin=t.lineJoin,e.miterLimit=t.miterLimit,e.stroke())}createHitDetectionCanvas_(t){if(this.fill_){let e=this.fill_.getColor(),i=0;if("string"==typeof e&&(e=asArray(e)),null===e?i=1:Array.isArray(e)&&(i=4===e.length?e[3]:1),0===i){const e=createCanvasContext2D(t.size,t.size);this.hitDetectionCanvas_=e.canvas,this.drawHitDetectionCanvas_(t,e)}}this.hitDetectionCanvas_||(this.hitDetectionCanvas_=this.getImage(1))}createPath_(t){let e=this.points_;const i=this.radius_;if(e===1/0)t.arc(0,0,i,0,2*Math.PI);else{const s=void 0===this.radius2_?i:this.radius2_;void 0!==this.radius2_&&(e*=2);const a=this.angle_-Math.PI/2,r=2*Math.PI/e;for(let n=0;n<e;n++){const e=a+n*r,l=n%2==0?i:s;t.lineTo(l*Math.cos(e),l*Math.sin(e))}t.closePath()}}drawHitDetectionCanvas_(t,e){e.translate(t.size/2,t.size/2),this.createPath_(e),e.fillStyle=defaultFillStyle,e.fill(),this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineJoin=t.lineJoin,e.miterLimit=t.miterLimit,e.stroke())}}export default RegularShape;
//# sourceMappingURL=/sm/856ae98f4310bac51c2bdc46cd1263f2d97a6f64962b1a6dee6341694c5a66cc.map