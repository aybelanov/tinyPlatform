/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/View.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BaseObject from"./Object.js";import ViewHint from"./ViewHint.js";import ViewProperty from"./ViewProperty.js";import{DEFAULT_TILE_SIZE}from"./tilegrid/common.js";import{METERS_PER_UNIT,createProjection,disableCoordinateWarning,fromUserCoordinate,fromUserExtent,getUserProjection,toUserCoordinate,toUserExtent}from"./proj.js";import{VOID}from"./functions.js";import{add as addCoordinate,equals as coordinatesEqual,equals,rotate as rotateCoordinate}from"./coordinate.js";import{assert}from"./asserts.js";import{none as centerNone,createExtent}from"./centerconstraint.js";import{clamp,modulo}from"./math.js";import{createMinMaxResolution,createSnapToPower,createSnapToResolutions}from"./resolutionconstraint.js";import{createSnapToN,createSnapToZero,disable,none as rotationNone}from"./rotationconstraint.js";import{easeOut,inAndOut}from"./easing.js";import{getCenter,getForViewAndSize,getHeight,getWidth,isEmpty}from"./extent.js";import{linearFindNearest}from"./array.js";import{fromExtent as polygonFromExtent}from"./geom/Polygon.js";const DEFAULT_MIN_ZOOM=0;class View extends BaseObject{constructor(t){super(),this.on,this.once,this.un,t=Object.assign({},t),this.hints_=[0,0],this.animations_=[],this.updateAnimationKey_,this.projection_=createProjection(t.projection,"EPSG:3857"),this.viewportSize_=[100,100],this.targetCenter_=null,this.targetResolution_,this.targetRotation_,this.nextCenter_=null,this.nextResolution_,this.nextRotation_,this.cancelAnchor_=void 0,t.projection&&disableCoordinateWarning(),t.center&&(t.center=fromUserCoordinate(t.center,this.projection_)),t.extent&&(t.extent=fromUserExtent(t.extent,this.projection_)),this.applyOptions_(t)}applyOptions_(t){const e=Object.assign({},t);for(const t in ViewProperty)delete e[t];this.setProperties(e,!0);const o=createResolutionConstraint(t);this.maxResolution_=o.maxResolution,this.minResolution_=o.minResolution,this.zoomFactor_=o.zoomFactor,this.resolutions_=t.resolutions,this.padding_=t.padding,this.minZoom_=o.minZoom;const n=createCenterConstraint(t),i=o.constraint,s=createRotationConstraint(t);this.constraints_={center:n,resolution:i,rotation:s},this.setRotation(void 0!==t.rotation?t.rotation:0),this.setCenterInternal(void 0!==t.center?t.center:null),void 0!==t.resolution?this.setResolution(t.resolution):void 0!==t.zoom&&this.setZoom(t.zoom)}get padding(){return this.padding_}set padding(t){let e=this.padding_;this.padding_=t;const o=this.getCenterInternal();if(o){const n=t||[0,0,0,0];e=e||[0,0,0,0];const i=this.getResolution(),s=i/2*(n[3]-e[3]+e[1]-n[1]),r=i/2*(n[0]-e[0]+e[2]-n[2]);this.setCenterInternal([o[0]+s,o[1]-r])}}getUpdatedOptions_(t){const e=this.getProperties();return void 0!==e.resolution?e.resolution=this.getResolution():e.zoom=this.getZoom(),e.center=this.getCenterInternal(),e.rotation=this.getRotation(),Object.assign({},e,t)}animate(t){this.isDef()&&!this.getAnimating()&&this.resolveConstraints(0);const e=new Array(arguments.length);for(let t=0;t<e.length;++t){let o=arguments[t];o.center&&(o=Object.assign({},o),o.center=fromUserCoordinate(o.center,this.getProjection())),o.anchor&&(o=Object.assign({},o),o.anchor=fromUserCoordinate(o.anchor,this.getProjection())),e[t]=o}this.animateInternal.apply(this,e)}animateInternal(t){let e,o=arguments.length;o>1&&"function"==typeof arguments[o-1]&&(e=arguments[o-1],--o);let n=0;for(;n<o&&!this.isDef();++n){const t=arguments[n];t.center&&this.setCenterInternal(t.center),void 0!==t.zoom?this.setZoom(t.zoom):t.resolution&&this.setResolution(t.resolution),void 0!==t.rotation&&this.setRotation(t.rotation)}if(n===o)return void(e&&animationCallback(e,!0));let i=Date.now(),s=this.targetCenter_.slice(),r=this.targetResolution_,a=this.targetRotation_;const h=[];for(;n<o;++n){const t=arguments[n],o={start:i,complete:!1,anchor:t.anchor,duration:void 0!==t.duration?t.duration:1e3,easing:t.easing||inAndOut,callback:e};if(t.center&&(o.sourceCenter=s,o.targetCenter=t.center.slice(),s=o.targetCenter),void 0!==t.zoom?(o.sourceResolution=r,o.targetResolution=this.getResolutionForZoom(t.zoom),r=o.targetResolution):t.resolution&&(o.sourceResolution=r,o.targetResolution=t.resolution,r=o.targetResolution),void 0!==t.rotation){o.sourceRotation=a;const e=modulo(t.rotation-a+Math.PI,2*Math.PI)-Math.PI;o.targetRotation=a+e,a=o.targetRotation}isNoopAnimation(o)?o.complete=!0:i+=o.duration,h.push(o)}this.animations_.push(h),this.setHint(ViewHint.ANIMATING,1),this.updateAnimations_()}getAnimating(){return this.hints_[ViewHint.ANIMATING]>0}getInteracting(){return this.hints_[ViewHint.INTERACTING]>0}cancelAnimations(){let t;this.setHint(ViewHint.ANIMATING,-this.hints_[ViewHint.ANIMATING]);for(let e=0,o=this.animations_.length;e<o;++e){const o=this.animations_[e];if(o[0].callback&&animationCallback(o[0].callback,!1),!t)for(let e=0,n=o.length;e<n;++e){const n=o[e];if(!n.complete){t=n.anchor;break}}}this.animations_.length=0,this.cancelAnchor_=t,this.nextCenter_=null,this.nextResolution_=NaN,this.nextRotation_=NaN}updateAnimations_(){if(void 0!==this.updateAnimationKey_&&(cancelAnimationFrame(this.updateAnimationKey_),this.updateAnimationKey_=void 0),!this.getAnimating())return;const t=Date.now();let e=!1;for(let o=this.animations_.length-1;o>=0;--o){const n=this.animations_[o];let i=!0;for(let o=0,s=n.length;o<s;++o){const s=n[o];if(s.complete)continue;const r=t-s.start;let a=s.duration>0?r/s.duration:1;a>=1?(s.complete=!0,a=1):i=!1;const h=s.easing(a);if(s.sourceCenter){const t=s.sourceCenter[0],e=s.sourceCenter[1],o=s.targetCenter[0],n=s.targetCenter[1];this.nextCenter_=s.targetCenter;const i=t+h*(o-t),r=e+h*(n-e);this.targetCenter_=[i,r]}if(s.sourceResolution&&s.targetResolution){const t=1===h?s.targetResolution:s.sourceResolution+h*(s.targetResolution-s.sourceResolution);if(s.anchor){const e=this.getViewportSize_(this.getRotation()),o=this.constraints_.resolution(t,0,e,!0);this.targetCenter_=this.calculateCenterZoom(o,s.anchor)}this.nextResolution_=s.targetResolution,this.targetResolution_=t,this.applyTargetState_(!0)}if(void 0!==s.sourceRotation&&void 0!==s.targetRotation){const t=1===h?modulo(s.targetRotation+Math.PI,2*Math.PI)-Math.PI:s.sourceRotation+h*(s.targetRotation-s.sourceRotation);if(s.anchor){const e=this.constraints_.rotation(t,!0);this.targetCenter_=this.calculateCenterRotate(e,s.anchor)}this.nextRotation_=s.targetRotation,this.targetRotation_=t}if(this.applyTargetState_(!0),e=!0,!s.complete)break}if(i){this.animations_[o]=null,this.setHint(ViewHint.ANIMATING,-1),this.nextCenter_=null,this.nextResolution_=NaN,this.nextRotation_=NaN;const t=n[0].callback;t&&animationCallback(t,!0)}}this.animations_=this.animations_.filter(Boolean),e&&void 0===this.updateAnimationKey_&&(this.updateAnimationKey_=requestAnimationFrame(this.updateAnimations_.bind(this)))}calculateCenterRotate(t,e){let o;const n=this.getCenterInternal();return void 0!==n&&(o=[n[0]-e[0],n[1]-e[1]],rotateCoordinate(o,t-this.getRotation()),addCoordinate(o,e)),o}calculateCenterZoom(t,e){let o;const n=this.getCenterInternal(),i=this.getResolution();if(void 0!==n&&void 0!==i){o=[e[0]-t*(e[0]-n[0])/i,e[1]-t*(e[1]-n[1])/i]}return o}getViewportSize_(t){const e=this.viewportSize_;if(t){const o=e[0],n=e[1];return[Math.abs(o*Math.cos(t))+Math.abs(n*Math.sin(t)),Math.abs(o*Math.sin(t))+Math.abs(n*Math.cos(t))]}return e}setViewportSize(t){this.viewportSize_=Array.isArray(t)?t.slice():[100,100],this.getAnimating()||this.resolveConstraints(0)}getCenter(){const t=this.getCenterInternal();return t?toUserCoordinate(t,this.getProjection()):t}getCenterInternal(){return this.get(ViewProperty.CENTER)}getConstraints(){return this.constraints_}getConstrainResolution(){return this.get("constrainResolution")}getHints(t){return void 0!==t?(t[0]=this.hints_[0],t[1]=this.hints_[1],t):this.hints_.slice()}calculateExtent(t){const e=this.calculateExtentInternal(t);return toUserExtent(e,this.getProjection())}calculateExtentInternal(t){t=t||this.getViewportSizeMinusPadding_();const e=this.getCenterInternal();assert(e,"The view center is not defined");const o=this.getResolution();assert(void 0!==o,"The view resolution is not defined");const n=this.getRotation();return assert(void 0!==n,"The view rotation is not defined"),getForViewAndSize(e,o,n,t)}getMaxResolution(){return this.maxResolution_}getMinResolution(){return this.minResolution_}getMaxZoom(){return this.getZoomForResolution(this.minResolution_)}setMaxZoom(t){this.applyOptions_(this.getUpdatedOptions_({maxZoom:t}))}getMinZoom(){return this.getZoomForResolution(this.maxResolution_)}setMinZoom(t){this.applyOptions_(this.getUpdatedOptions_({minZoom:t}))}setConstrainResolution(t){this.applyOptions_(this.getUpdatedOptions_({constrainResolution:t}))}getProjection(){return this.projection_}getResolution(){return this.get(ViewProperty.RESOLUTION)}getResolutions(){return this.resolutions_}getResolutionForExtent(t,e){return this.getResolutionForExtentInternal(fromUserExtent(t,this.getProjection()),e)}getResolutionForExtentInternal(t,e){e=e||this.getViewportSizeMinusPadding_();const o=getWidth(t)/e[0],n=getHeight(t)/e[1];return Math.max(o,n)}getResolutionForValueFunction(t){t=t||2;const e=this.getConstrainedResolution(this.maxResolution_),o=this.minResolution_,n=Math.log(e/o)/Math.log(t);return function(o){return e/Math.pow(t,o*n)}}getRotation(){return this.get(ViewProperty.ROTATION)}getValueForResolutionFunction(t){const e=Math.log(t||2),o=this.getConstrainedResolution(this.maxResolution_),n=this.minResolution_,i=Math.log(o/n)/e;return function(t){return Math.log(o/t)/e/i}}getViewportSizeMinusPadding_(t){let e=this.getViewportSize_(t);const o=this.padding_;return o&&(e=[e[0]-o[1]-o[3],e[1]-o[0]-o[2]]),e}getState(){const t=this.getProjection(),e=this.getResolution(),o=this.getRotation();let n=this.getCenterInternal();const i=this.padding_;if(i){const t=this.getViewportSizeMinusPadding_();n=calculateCenterOn(n,this.getViewportSize_(),[t[0]/2+i[3],t[1]/2+i[0]],e,o)}return{center:n.slice(0),projection:void 0!==t?t:null,resolution:e,nextCenter:this.nextCenter_,nextResolution:this.nextResolution_,nextRotation:this.nextRotation_,rotation:o,zoom:this.getZoom()}}getViewStateAndExtent(){return{viewState:this.getState(),extent:this.calculateExtent()}}getZoom(){let t;const e=this.getResolution();return void 0!==e&&(t=this.getZoomForResolution(e)),t}getZoomForResolution(t){let e,o,n=this.minZoom_||0;if(this.resolutions_){const i=linearFindNearest(this.resolutions_,t,1);n=i,e=this.resolutions_[i],o=i==this.resolutions_.length-1?2:e/this.resolutions_[i+1]}else e=this.maxResolution_,o=this.zoomFactor_;return n+Math.log(e/t)/Math.log(o)}getResolutionForZoom(t){if(this.resolutions_){if(this.resolutions_.length<=1)return 0;const e=clamp(Math.floor(t),0,this.resolutions_.length-2),o=this.resolutions_[e]/this.resolutions_[e+1];return this.resolutions_[e]/Math.pow(o,clamp(t-e,0,1))}return this.maxResolution_/Math.pow(this.zoomFactor_,t-this.minZoom_)}fit(t,e){let o;if(assert(Array.isArray(t)||"function"==typeof t.getSimplifiedGeometry,"Invalid extent or geometry provided as `geometry`"),Array.isArray(t)){assert(!isEmpty(t),"Cannot fit empty extent provided as `geometry`");const e=fromUserExtent(t,this.getProjection());o=polygonFromExtent(e)}else if("Circle"===t.getType()){const e=fromUserExtent(t.getExtent(),this.getProjection());o=polygonFromExtent(e),o.rotate(this.getRotation(),getCenter(e))}else{const e=getUserProjection();o=e?t.clone().transform(e,this.getProjection()):t}this.fitInternal(o,e)}rotatedExtentForGeometry(t){const e=this.getRotation(),o=Math.cos(e),n=Math.sin(-e),i=t.getFlatCoordinates(),s=t.getStride();let r=1/0,a=1/0,h=-1/0,l=-1/0;for(let t=0,e=i.length;t<e;t+=s){const e=i[t]*o-i[t+1]*n,s=i[t]*n+i[t+1]*o;r=Math.min(r,e),a=Math.min(a,s),h=Math.max(h,e),l=Math.max(l,s)}return[r,a,h,l]}fitInternal(t,e){let o=(e=e||{}).size;o||(o=this.getViewportSizeMinusPadding_());const n=void 0!==e.padding?e.padding:[0,0,0,0],i=void 0!==e.nearest&&e.nearest;let s;s=void 0!==e.minResolution?e.minResolution:void 0!==e.maxZoom?this.getResolutionForZoom(e.maxZoom):0;const r=this.rotatedExtentForGeometry(t);let a=this.getResolutionForExtentInternal(r,[o[0]-n[1]-n[3],o[1]-n[0]-n[2]]);a=isNaN(a)?s:Math.max(a,s),a=this.getConstrainedResolution(a,i?0:1);const h=this.getRotation(),l=Math.sin(h),c=Math.cos(h),u=getCenter(r);u[0]+=(n[1]-n[3])/2*a,u[1]+=(n[0]-n[2])/2*a;const g=u[0]*c-u[1]*l,m=u[1]*c+u[0]*l,d=this.getConstrainedCenter([g,m],a),_=e.callback?e.callback:VOID;void 0!==e.duration?this.animateInternal({resolution:a,center:d,duration:e.duration,easing:e.easing},_):(this.targetResolution_=a,this.targetCenter_=d,this.applyTargetState_(!1,!0),animationCallback(_,!0))}centerOn(t,e,o){this.centerOnInternal(fromUserCoordinate(t,this.getProjection()),e,o)}centerOnInternal(t,e,o){this.setCenterInternal(calculateCenterOn(t,e,o,this.getResolution(),this.getRotation()))}calculateCenterShift(t,e,o,n){let i;const s=this.padding_;if(s&&t){const r=this.getViewportSizeMinusPadding_(-o),a=calculateCenterOn(t,n,[r[0]/2+s[3],r[1]/2+s[0]],e,o);i=[t[0]-a[0],t[1]-a[1]]}return i}isDef(){return!!this.getCenterInternal()&&void 0!==this.getResolution()}adjustCenter(t){const e=toUserCoordinate(this.targetCenter_,this.getProjection());this.setCenter([e[0]+t[0],e[1]+t[1]])}adjustCenterInternal(t){const e=this.targetCenter_;this.setCenterInternal([e[0]+t[0],e[1]+t[1]])}adjustResolution(t,e){e=e&&fromUserCoordinate(e,this.getProjection()),this.adjustResolutionInternal(t,e)}adjustResolutionInternal(t,e){const o=this.getAnimating()||this.getInteracting(),n=this.getViewportSize_(this.getRotation()),i=this.constraints_.resolution(this.targetResolution_*t,0,n,o);e&&(this.targetCenter_=this.calculateCenterZoom(i,e)),this.targetResolution_*=t,this.applyTargetState_()}adjustZoom(t,e){this.adjustResolution(Math.pow(this.zoomFactor_,-t),e)}adjustRotation(t,e){e&&(e=fromUserCoordinate(e,this.getProjection())),this.adjustRotationInternal(t,e)}adjustRotationInternal(t,e){const o=this.getAnimating()||this.getInteracting(),n=this.constraints_.rotation(this.targetRotation_+t,o);e&&(this.targetCenter_=this.calculateCenterRotate(n,e)),this.targetRotation_+=t,this.applyTargetState_()}setCenter(t){this.setCenterInternal(t?fromUserCoordinate(t,this.getProjection()):t)}setCenterInternal(t){this.targetCenter_=t,this.applyTargetState_()}setHint(t,e){return this.hints_[t]+=e,this.changed(),this.hints_[t]}setResolution(t){this.targetResolution_=t,this.applyTargetState_()}setRotation(t){this.targetRotation_=t,this.applyTargetState_()}setZoom(t){this.setResolution(this.getResolutionForZoom(t))}applyTargetState_(t,e){const o=this.getAnimating()||this.getInteracting()||e,n=this.constraints_.rotation(this.targetRotation_,o),i=this.getViewportSize_(n),s=this.constraints_.resolution(this.targetResolution_,0,i,o),r=this.constraints_.center(this.targetCenter_,s,i,o,this.calculateCenterShift(this.targetCenter_,s,n,i));this.get(ViewProperty.ROTATION)!==n&&this.set(ViewProperty.ROTATION,n),this.get(ViewProperty.RESOLUTION)!==s&&(this.set(ViewProperty.RESOLUTION,s),this.set("zoom",this.getZoom(),!0)),r&&this.get(ViewProperty.CENTER)&&equals(this.get(ViewProperty.CENTER),r)||this.set(ViewProperty.CENTER,r),this.getAnimating()&&!t&&this.cancelAnimations(),this.cancelAnchor_=void 0}resolveConstraints(t,e,o){t=void 0!==t?t:200;const n=e||0,i=this.constraints_.rotation(this.targetRotation_),s=this.getViewportSize_(i),r=this.constraints_.resolution(this.targetResolution_,n,s),a=this.constraints_.center(this.targetCenter_,r,s,!1,this.calculateCenterShift(this.targetCenter_,r,i,s));if(0===t&&!this.cancelAnchor_)return this.targetResolution_=r,this.targetRotation_=i,this.targetCenter_=a,void this.applyTargetState_();o=o||(0===t?this.cancelAnchor_:void 0),this.cancelAnchor_=void 0,this.getResolution()===r&&this.getRotation()===i&&this.getCenterInternal()&&equals(this.getCenterInternal(),a)||(this.getAnimating()&&this.cancelAnimations(),this.animateInternal({rotation:i,center:a,resolution:r,duration:t,easing:easeOut,anchor:o}))}beginInteraction(){this.resolveConstraints(0),this.setHint(ViewHint.INTERACTING,1)}endInteraction(t,e,o){o=o&&fromUserCoordinate(o,this.getProjection()),this.endInteractionInternal(t,e,o)}endInteractionInternal(t,e,o){this.getInteracting()&&(this.setHint(ViewHint.INTERACTING,-1),this.resolveConstraints(t,e,o))}getConstrainedCenter(t,e){const o=this.getViewportSize_(this.getRotation());return this.constraints_.center(t,e||this.getResolution(),o)}getConstrainedZoom(t,e){const o=this.getResolutionForZoom(t);return this.getZoomForResolution(this.getConstrainedResolution(o,e))}getConstrainedResolution(t,e){e=e||0;const o=this.getViewportSize_(this.getRotation());return this.constraints_.resolution(t,e,o)}}function animationCallback(t,e){setTimeout((function(){t(e)}),0)}export function createCenterConstraint(t){if(void 0!==t.extent){const e=void 0===t.smoothExtentConstraint||t.smoothExtentConstraint;return createExtent(t.extent,t.constrainOnlyCenter,e)}const e=createProjection(t.projection,"EPSG:3857");if(!0!==t.multiWorld&&e.isGlobal()){const t=e.getExtent().slice();return t[0]=-1/0,t[2]=1/0,createExtent(t,!1,!1)}return centerNone}export function createResolutionConstraint(t){let e,o,n;let i=void 0!==t.minZoom?t.minZoom:0,s=void 0!==t.maxZoom?t.maxZoom:28;const r=void 0!==t.zoomFactor?t.zoomFactor:2,a=void 0!==t.multiWorld&&t.multiWorld,h=void 0===t.smoothResolutionConstraint||t.smoothResolutionConstraint,l=void 0!==t.showFullExtent&&t.showFullExtent,c=createProjection(t.projection,"EPSG:3857"),u=c.getExtent();let g=t.constrainOnlyCenter,m=t.extent;if(a||m||!c.isGlobal()||(g=!1,m=u),void 0!==t.resolutions){const r=t.resolutions;o=r[i],n=void 0!==r[s]?r[s]:r[r.length-1],e=t.constrainResolution?createSnapToResolutions(r,h,!g&&m,l):createMinMaxResolution(o,n,h,!g&&m,l)}else{const a=(u?Math.max(getWidth(u),getHeight(u)):360*METERS_PER_UNIT.degrees/c.getMetersPerUnit())/DEFAULT_TILE_SIZE/Math.pow(2,0),d=a/Math.pow(2,28);o=t.maxResolution,void 0!==o?i=0:o=a/Math.pow(r,i),n=t.minResolution,void 0===n&&(n=void 0!==t.maxZoom?void 0!==t.maxResolution?o/Math.pow(r,s):a/Math.pow(r,s):d),s=i+Math.floor(Math.log(o/n)/Math.log(r)),n=o/Math.pow(r,s-i),e=t.constrainResolution?createSnapToPower(r,o,n,h,!g&&m,l):createMinMaxResolution(o,n,h,!g&&m,l)}return{constraint:e,maxResolution:o,minResolution:n,minZoom:i,zoomFactor:r}}export function createRotationConstraint(t){if(void 0===t.enableRotation||t.enableRotation){const e=t.constrainRotation;return void 0===e||!0===e?createSnapToZero():!1===e?rotationNone:"number"==typeof e?createSnapToN(e):rotationNone}return disable}export function isNoopAnimation(t){return!(t.sourceCenter&&t.targetCenter&&!coordinatesEqual(t.sourceCenter,t.targetCenter))&&(t.sourceResolution===t.targetResolution&&t.sourceRotation===t.targetRotation)}function calculateCenterOn(t,e,o,n,i){const s=Math.cos(-i);let r=Math.sin(-i),a=t[0]*s-t[1]*r,h=t[1]*s+t[0]*r;a+=(e[0]/2-o[0])*n,h+=(o[1]-e[1]/2)*n,r=-r;return[a*s-h*r,h*s+a*r]}export default View;
//# sourceMappingURL=/sm/13b465f7d3f38ae48d2c5ca61ad8854095b02e1ea89eaa6f121cc9d2d1d09f63.map