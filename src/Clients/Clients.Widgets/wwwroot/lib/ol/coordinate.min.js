/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/coordinate.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{getWidth}from"./extent.js";import{modulo,toFixed}from"./math.js";import{padNumber}from"./string.js";export function add(t,e){return t[0]+=+e[0],t[1]+=+e[1],t}export function closestOnCircle(t,e){const r=e.getRadius(),n=e.getCenter(),o=n[0],i=n[1];let u=t[0]-o;const c=t[1]-i;0===u&&0===c&&(u=1);const a=Math.sqrt(u*u+c*c);return[o+r*u/a,i+r*c/a]}export function closestOnSegment(t,e){const r=t[0],n=t[1],o=e[0],i=e[1],u=o[0],c=o[1],a=i[0],s=i[1],f=a-u,p=s-c,d=0===f&&0===p?0:(f*(r-u)+p*(n-c))/(f*f+p*p||0);let x,g;return d<=0?(x=u,g=c):d>=1?(x=a,g=s):(x=u+d*f,g=c+d*p),[x,g]}export function createStringXY(t){return function(e){return toStringXY(e,t)}}export function degreesToStringHDMS(t,e,r){const n=modulo(e+180,360)-180,o=Math.abs(3600*n),i=r||0;let u=Math.floor(o/3600),c=Math.floor((o-3600*u)/60),a=toFixed(o-3600*u-60*c,i);a>=60&&(a=0,c+=1),c>=60&&(c=0,u+=1);let s=u+"°";return 0===c&&0===a||(s+=" "+padNumber(c,2)+"′"),0!==a&&(s+=" "+padNumber(a,2,i)+"″"),0!==n&&(s+=" "+t.charAt(n<0?1:0)),s}export function format(t,e,r){return t?e.replace("{x}",t[0].toFixed(r)).replace("{y}",t[1].toFixed(r)):""}export function equals(t,e){let r=!0;for(let n=t.length-1;n>=0;--n)if(t[n]!=e[n]){r=!1;break}return r}export function rotate(t,e){const r=Math.cos(e),n=Math.sin(e),o=t[0]*r-t[1]*n,i=t[1]*r+t[0]*n;return t[0]=o,t[1]=i,t}export function scale(t,e){return t[0]*=e,t[1]*=e,t}export function squaredDistance(t,e){const r=t[0]-e[0],n=t[1]-e[1];return r*r+n*n}export function distance(t,e){return Math.sqrt(squaredDistance(t,e))}export function squaredDistanceToSegment(t,e){return squaredDistance(t,closestOnSegment(t,e))}export function toStringHDMS(t,e){return t?degreesToStringHDMS("NS",t[1],e)+" "+degreesToStringHDMS("EW",t[0],e):""}export function toStringXY(t,e){return format(t,"{x}, {y}",e)}export function wrapX(t,e){if(e.canWrapX()){const r=getWidth(e.getExtent()),n=getWorldsAway(t,e,r);n&&(t[0]-=n*r)}return t}export function getWorldsAway(t,e,r){const n=e.getExtent();let o=0;return e.canWrapX()&&(t[0]<n[0]||t[0]>n[2])&&(r=r||getWidth(n),o=Math.floor((t[0]-n[0])/r)),o}
//# sourceMappingURL=/sm/a3170086a933e44fa388f95ffb3b8abadc9e10282a393fff34bc540a33bf0367.map