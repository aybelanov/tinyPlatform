/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/extent.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Relationship from"./extent/Relationship.js";export function boundingExtent(t){const e=createEmpty();for(let n=0,r=t.length;n<r;++n)extendCoordinate(e,t[n]);return e}function _boundingExtentXYs(t,e,n){return createOrUpdate(Math.min.apply(null,t),Math.min.apply(null,e),Math.max.apply(null,t),Math.max.apply(null,e),n)}export function buffer(t,e,n){return n?(n[0]=t[0]-e,n[1]=t[1]-e,n[2]=t[2]+e,n[3]=t[3]+e,n):[t[0]-e,t[1]-e,t[2]+e,t[3]+e]}export function clone(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t.slice()}export function closestSquaredDistanceXY(t,e,n){let r,o;return r=e<t[0]?t[0]-e:t[2]<e?e-t[2]:0,o=n<t[1]?t[1]-n:t[3]<n?n-t[3]:0,r*r+o*o}export function containsCoordinate(t,e){return containsXY(t,e[0],e[1])}export function containsExtent(t,e){return t[0]<=e[0]&&e[2]<=t[2]&&t[1]<=e[1]&&e[3]<=t[3]}export function containsXY(t,e,n){return t[0]<=e&&e<=t[2]&&t[1]<=n&&n<=t[3]}export function coordinateRelationship(t,e){const n=t[0],r=t[1],o=t[2],i=t[3],a=e[0],p=e[1];let u=Relationship.UNKNOWN;return a<n?u|=Relationship.LEFT:a>o&&(u|=Relationship.RIGHT),p<r?u|=Relationship.BELOW:p>i&&(u|=Relationship.ABOVE),u===Relationship.UNKNOWN&&(u=Relationship.INTERSECTING),u}export function createEmpty(){return[1/0,1/0,-1/0,-1/0]}export function createOrUpdate(t,e,n,r,o){return o?(o[0]=t,o[1]=e,o[2]=n,o[3]=r,o):[t,e,n,r]}export function createOrUpdateEmpty(t){return createOrUpdate(1/0,1/0,-1/0,-1/0,t)}export function createOrUpdateFromCoordinate(t,e){const n=t[0],r=t[1];return createOrUpdate(n,r,n,r,e)}export function createOrUpdateFromCoordinates(t,e){return extendCoordinates(createOrUpdateEmpty(e),t)}export function createOrUpdateFromFlatCoordinates(t,e,n,r,o){return extendFlatCoordinates(createOrUpdateEmpty(o),t,e,n,r)}export function createOrUpdateFromRings(t,e){return extendRings(createOrUpdateEmpty(e),t)}export function equals(t,e){return t[0]==e[0]&&t[2]==e[2]&&t[1]==e[1]&&t[3]==e[3]}export function approximatelyEquals(t,e,n){return Math.abs(t[0]-e[0])<n&&Math.abs(t[2]-e[2])<n&&Math.abs(t[1]-e[1])<n&&Math.abs(t[3]-e[3])<n}export function extend(t,e){return e[0]<t[0]&&(t[0]=e[0]),e[2]>t[2]&&(t[2]=e[2]),e[1]<t[1]&&(t[1]=e[1]),e[3]>t[3]&&(t[3]=e[3]),t}export function extendCoordinate(t,e){e[0]<t[0]&&(t[0]=e[0]),e[0]>t[2]&&(t[2]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>t[3]&&(t[3]=e[1])}export function extendCoordinates(t,e){for(let n=0,r=e.length;n<r;++n)extendCoordinate(t,e[n]);return t}export function extendFlatCoordinates(t,e,n,r,o){for(;n<r;n+=o)extendXY(t,e[n],e[n+1]);return t}export function extendRings(t,e){for(let n=0,r=e.length;n<r;++n)extendCoordinates(t,e[n]);return t}export function extendXY(t,e,n){t[0]=Math.min(t[0],e),t[1]=Math.min(t[1],n),t[2]=Math.max(t[2],e),t[3]=Math.max(t[3],n)}export function forEachCorner(t,e){let n;return n=e(getBottomLeft(t)),n||(n=e(getBottomRight(t)),n||(n=e(getTopRight(t)),n||(n=e(getTopLeft(t)),n||!1)))}export function getArea(t){let e=0;return isEmpty(t)||(e=getWidth(t)*getHeight(t)),e}export function getBottomLeft(t){return[t[0],t[1]]}export function getBottomRight(t){return[t[2],t[1]]}export function getCenter(t){return[(t[0]+t[2])/2,(t[1]+t[3])/2]}export function getCorner(t,e){let n;if("bottom-left"===e)n=getBottomLeft(t);else if("bottom-right"===e)n=getBottomRight(t);else if("top-left"===e)n=getTopLeft(t);else{if("top-right"!==e)throw new Error("Invalid corner");n=getTopRight(t)}return n}export function getEnlargedArea(t,e){const n=Math.min(t[0],e[0]),r=Math.min(t[1],e[1]);return(Math.max(t[2],e[2])-n)*(Math.max(t[3],e[3])-r)}export function getForViewAndSize(t,e,n,r,o){const[i,a,p,u,c,s,f,x]=getRotatedViewport(t,e,n,r);return createOrUpdate(Math.min(i,p,c,f),Math.min(a,u,s,x),Math.max(i,p,c,f),Math.max(a,u,s,x),o)}export function getRotatedViewport(t,e,n,r){const o=e*r[0]/2,i=e*r[1]/2,a=Math.cos(n),p=Math.sin(n),u=o*a,c=o*p,s=i*a,f=i*p,x=t[0],l=t[1];return[x-u+f,l-c-s,x-u-f,l-c+s,x+u-f,l+c+s,x+u+f,l+c-s,x-u+f,l-c-s]}export function getHeight(t){return t[3]-t[1]}export function getIntersectionArea(t,e){return getArea(getIntersection(t,e))}export function getIntersection(t,e,n){const r=n||createEmpty();return intersects(t,e)?(t[0]>e[0]?r[0]=t[0]:r[0]=e[0],t[1]>e[1]?r[1]=t[1]:r[1]=e[1],t[2]<e[2]?r[2]=t[2]:r[2]=e[2],t[3]<e[3]?r[3]=t[3]:r[3]=e[3]):createOrUpdateEmpty(r),r}export function getMargin(t){return getWidth(t)+getHeight(t)}export function getSize(t){return[t[2]-t[0],t[3]-t[1]]}export function getTopLeft(t){return[t[0],t[3]]}export function getTopRight(t){return[t[2],t[3]]}export function getWidth(t){return t[2]-t[0]}export function intersects(t,e){return t[0]<=e[2]&&t[2]>=e[0]&&t[1]<=e[3]&&t[3]>=e[1]}export function isEmpty(t){return t[2]<t[0]||t[3]<t[1]}export function returnOrUpdate(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t}export function scaleFromCenter(t,e){const n=(t[2]-t[0])/2*(e-1),r=(t[3]-t[1])/2*(e-1);t[0]-=n,t[2]+=n,t[1]-=r,t[3]+=r}export function intersectsSegment(t,e,n){let r=!1;const o=coordinateRelationship(t,e),i=coordinateRelationship(t,n);if(o===Relationship.INTERSECTING||i===Relationship.INTERSECTING)r=!0;else{const a=t[0],p=t[1],u=t[2],c=t[3],s=e[0],f=e[1],x=n[0],l=n[1],h=(l-f)/(x-s);let g,d;i&Relationship.ABOVE&&!(o&Relationship.ABOVE)&&(g=x-(l-c)/h,r=g>=a&&g<=u),r||!(i&Relationship.RIGHT)||o&Relationship.RIGHT||(d=l-(x-u)*h,r=d>=p&&d<=c),r||!(i&Relationship.BELOW)||o&Relationship.BELOW||(g=x-(l-p)/h,r=g>=a&&g<=u),r||!(i&Relationship.LEFT)||o&Relationship.LEFT||(d=l-(x-a)*h,r=d>=p&&d<=c)}return r}export function applyTransform(t,e,n,r){if(isEmpty(t))return createOrUpdateEmpty(n);let o=[];if(r>1){const e=t[2]-t[0],n=t[3]-t[1];for(let i=0;i<r;++i)o.push(t[0]+e*i/r,t[1],t[2],t[1]+n*i/r,t[2]-e*i/r,t[3],t[0],t[3]-n*i/r)}else o=[t[0],t[1],t[2],t[1],t[2],t[3],t[0],t[3]];e(o,o,2);const i=[],a=[];for(let t=0,e=o.length;t<e;t+=2)i.push(o[t]),a.push(o[t+1]);return _boundingExtentXYs(i,a,n)}export function wrapX(t,e){const n=e.getExtent(),r=getCenter(t);if(e.canWrapX()&&(r[0]<n[0]||r[0]>=n[2])){const e=getWidth(n),o=Math.floor((r[0]-n[0])/e)*e;t[0]-=o,t[2]-=o}return t}export function wrapAndSliceX(t,e){if(e.canWrapX()){const n=e.getExtent();if(!isFinite(t[0])||!isFinite(t[2]))return[[n[0],t[1],n[2],t[3]]];wrapX(t,e);const r=getWidth(n);if(getWidth(t)>r)return[[n[0],t[1],n[2],t[3]]];if(t[0]<n[0])return[[t[0]+r,t[1],n[2],t[3]],[n[0],t[1],t[2],t[3]]];if(t[2]>n[2])return[[t[0],t[1],n[2],t[3]],[n[0],t[1],t[2]-r,t[3]]]}return[t]}
//# sourceMappingURL=/sm/07ec737b1439342675de6c51f7b8d6d9eb030f506cdbb372e7fdd16b1bab79f1.map