/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/reproj/DataTile.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ERROR_THRESHOLD}from"./common.js";import DataTile,{asArrayLike,asImageLike,toArray}from"../DataTile.js";import EventType from"../events/EventType.js";import TileState from"../TileState.js";import Triangulation from"./Triangulation.js";import{calculateSourceExtentResolution,canvasPool,render as renderReprojected}from"../reproj.js";import{clamp}from"../math.js";import{createCanvasContext2D,releaseCanvas}from"../dom.js";import{getArea,getIntersection}from"../extent.js";import{listen,unlistenByKey}from"../events.js";class ReprojDataTile extends DataTile{constructor(t){super({tileCoord:t.tileCoord,loader:()=>Promise.resolve(new Uint8Array(4)),interpolate:t.interpolate,transition:t.transition}),this.pixelRatio_=t.pixelRatio,this.gutter_=t.gutter,this.reprojData_=null,this.reprojError_=null,this.reprojSize_=void 0,this.sourceTileGrid_=t.sourceTileGrid,this.targetTileGrid_=t.targetTileGrid,this.wrappedTileCoord_=t.wrappedTileCoord||t.tileCoord,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0;const e=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_),i=this.targetTileGrid_.getExtent();let r=this.sourceTileGrid_.getExtent();const s=i?getIntersection(e,i):e;if(0===getArea(s))return void(this.state=TileState.EMPTY);const o=t.sourceProj,a=o.getExtent();a&&(r=r?getIntersection(r,a):a);const n=this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]),l=t.targetProj,h=calculateSourceExtentResolution(o,l,s,n);if(!isFinite(h)||h<=0)return void(this.state=TileState.EMPTY);const c=void 0!==t.errorThreshold?t.errorThreshold:ERROR_THRESHOLD;if(this.triangulation_=new Triangulation(o,l,s,r,h*c,n),0===this.triangulation_.getTriangles().length)return void(this.state=TileState.EMPTY);this.sourceZ_=this.sourceTileGrid_.getZForResolution(h);let u=this.triangulation_.calculateSourceExtent();if(r&&(o.canWrapX()?(u[1]=clamp(u[1],r[1],r[3]),u[3]=clamp(u[3],r[1],r[3])):u=getIntersection(u,r)),getArea(u)){const e=this.sourceTileGrid_.getTileRangeForExtentAndZ(u,this.sourceZ_),i=t.getTileFunction;for(let t=e.minX;t<=e.maxX;t++)for(let r=e.minY;r<=e.maxY;r++){const e=i(this.sourceZ_,t,r,this.pixelRatio_);e&&this.sourceTiles_.push(e)}0===this.sourceTiles_.length&&(this.state=TileState.EMPTY)}else this.state=TileState.EMPTY}getSize(){return this.reprojSize_}getData(){return this.reprojData_}getError(){return this.reprojError_}reproject_(){const t=[];if(this.sourceTiles_.forEach((e=>{if(!e||e.getState()!==TileState.LOADED)return;const i=e.getSize(),r=this.gutter_;let s;const o=asArrayLike(e.getData());s=o||toArray(asImageLike(e.getData()));const a=[i[0]+2*r,i[1]+2*r],n=s instanceof Float32Array,l=a[0]*a[1],h=n?Float32Array:Uint8Array,c=new h(s.buffer),u=h.BYTES_PER_ELEMENT,T=u*c.length/l,g=c.byteLength/a[1],d=Math.floor(g/u/a[0]),p=l*d;let _=c;if(c.length!==p){_=new h(p);let t=0,e=0;const i=a[0]*d;for(let r=0;r<a[1];++r){for(let r=0;r<i;++r)_[t++]=c[e+r];e+=g/u}}t.push({extent:this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),data:new Uint8Array(_.buffer),dataType:h,bytesPerPixel:T,pixelSize:a})})),this.sourceTiles_.length=0,0===t.length)this.state=TileState.ERROR;else{const e=this.wrappedTileCoord_[0],i=this.targetTileGrid_.getTileSize(e),r="number"==typeof i?i:i[0],s="number"==typeof i?i:i[1],o=this.targetTileGrid_.getResolution(e),a=this.sourceTileGrid_.getResolution(this.sourceZ_),n=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);let l,h;const c=t[0].bytesPerPixel;for(let e=Math.ceil(c/3)-1;e>=0;--e){const i=[];for(let r=0,s=t.length;r<s;++r){const s=t[r],o=s.data,a=s.pixelSize,n=a[0],l=a[1],h=createCanvasContext2D(n,l,canvasPool),u=h.createImageData(n,l),T=u.data;let g=3*e;for(let t=0,e=T.length;t<e;t+=4)T[t]=o[g],T[t+1]=o[g+1],T[t+2]=o[g+2],T[t+3]=255,g+=c;h.putImageData(u,0,0),i.push({extent:s.extent,image:h.canvas})}const u=renderReprojected(r,s,this.pixelRatio_,a,this.sourceTileGrid_.getExtent(),o,n,this.triangulation_,i,this.gutter_,!1,!1);for(let t=0,e=i.length;t<e;++t){const e=i[t].image.getContext("2d");releaseCanvas(e),canvasPool.push(e.canvas)}const T=u.getContext("2d"),g=T.getImageData(0,0,u.width,u.height);releaseCanvas(T),canvasPool.push(u),l||(h=new Uint8Array(c*g.width*g.height),l=new t[0].dataType(h.buffer));const d=g.data;let p=3*e;for(let t=0,e=d.length;t<e;t+=4)255===d[t+3]?(h[p]=d[t],h[p+1]=d[t+1],h[p+2]=d[t+2]):(h[p]=0,h[p+1]=0,h[p+2]=0),p+=c}this.reprojData_=l,this.reprojSize_=[Math.round(r*this.pixelRatio_),Math.round(s*this.pixelRatio_)],this.state=TileState.LOADED}this.changed()}load(){if(this.state!==TileState.IDLE&&this.state!==TileState.ERROR)return;this.state=TileState.LOADING,this.changed();let t=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach((e=>{const i=e.getState();if(i!==TileState.IDLE&&i!==TileState.LOADING)return;t++;const r=listen(e,EventType.CHANGE,(function(){const i=e.getState();i!=TileState.LOADED&&i!=TileState.ERROR&&i!=TileState.EMPTY||(unlistenByKey(r),t--,0===t&&(this.unlistenSources_(),this.reproject_()))}),this);this.sourcesListenerKeys_.push(r)})),0===t?setTimeout(this.reproject_.bind(this),0):this.sourceTiles_.forEach((function(t){t.getState()==TileState.IDLE&&t.load()}))}unlistenSources_(){this.sourcesListenerKeys_.forEach(unlistenByKey),this.sourcesListenerKeys_=null}}export default ReprojDataTile;
//# sourceMappingURL=/sm/203fd4f5d15e1bd1008d2c3d3fd9e626a7f87d21e8793aba809431a75dcc6554.map