/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/reproj/Tile.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ERROR_THRESHOLD}from"./common.js";import EventType from"../events/EventType.js";import Tile from"../Tile.js";import TileState from"../TileState.js";import Triangulation from"./Triangulation.js";import{calculateSourceExtentResolution,canvasPool,render as renderReprojected}from"../reproj.js";import{clamp}from"../math.js";import{getArea,getIntersection}from"../extent.js";import{listen,unlistenByKey}from"../events.js";import{releaseCanvas}from"../dom.js";class ReprojTile extends Tile{constructor(e,t,i,s,r,o,n,a,l,h,c,u){super(r,TileState.IDLE,{interpolate:!!u}),this.renderEdges_=void 0!==c&&c,this.pixelRatio_=n,this.gutter_=a,this.canvas_=null,this.sourceTileGrid_=t,this.targetTileGrid_=s,this.wrappedTileCoord_=o||r,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0;const T=s.getTileCoordExtent(this.wrappedTileCoord_),_=this.targetTileGrid_.getExtent();let g=this.sourceTileGrid_.getExtent();const d=_?getIntersection(T,_):T;if(0===getArea(d))return void(this.state=TileState.EMPTY);const p=e.getExtent();p&&(g=g?getIntersection(g,p):p);const E=s.getResolution(this.wrappedTileCoord_[0]),m=calculateSourceExtentResolution(e,i,d,E);if(!isFinite(m)||m<=0)return void(this.state=TileState.EMPTY);const S=void 0!==h?h:ERROR_THRESHOLD;if(this.triangulation_=new Triangulation(e,i,d,g,m*S,E),0===this.triangulation_.getTriangles().length)return void(this.state=TileState.EMPTY);this.sourceZ_=t.getZForResolution(m);let f=this.triangulation_.calculateSourceExtent();if(g&&(e.canWrapX()?(f[1]=clamp(f[1],g[1],g[3]),f[3]=clamp(f[3],g[1],g[3])):f=getIntersection(f,g)),getArea(f)){const e=t.getTileRangeForExtentAndZ(f,this.sourceZ_);for(let t=e.minX;t<=e.maxX;t++)for(let i=e.minY;i<=e.maxY;i++){const e=l(this.sourceZ_,t,i,n);e&&this.sourceTiles_.push(e)}0===this.sourceTiles_.length&&(this.state=TileState.EMPTY)}else this.state=TileState.EMPTY}getImage(){return this.canvas_}reproject_(){const e=[];if(this.sourceTiles_.forEach((t=>{t&&t.getState()==TileState.LOADED&&e.push({extent:this.sourceTileGrid_.getTileCoordExtent(t.tileCoord),image:t.getImage()})})),this.sourceTiles_.length=0,0===e.length)this.state=TileState.ERROR;else{const t=this.wrappedTileCoord_[0],i=this.targetTileGrid_.getTileSize(t),s="number"==typeof i?i:i[0],r="number"==typeof i?i:i[1],o=this.targetTileGrid_.getResolution(t),n=this.sourceTileGrid_.getResolution(this.sourceZ_),a=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);this.canvas_=renderReprojected(s,r,this.pixelRatio_,n,this.sourceTileGrid_.getExtent(),o,a,this.triangulation_,e,this.gutter_,this.renderEdges_,this.interpolate),this.state=TileState.LOADED}this.changed()}load(){if(this.state==TileState.IDLE){this.state=TileState.LOADING,this.changed();let e=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach((t=>{const i=t.getState();if(i==TileState.IDLE||i==TileState.LOADING){e++;const i=listen(t,EventType.CHANGE,(function(s){const r=t.getState();r!=TileState.LOADED&&r!=TileState.ERROR&&r!=TileState.EMPTY||(unlistenByKey(i),e--,0===e&&(this.unlistenSources_(),this.reproject_()))}),this);this.sourcesListenerKeys_.push(i)}})),0===e?setTimeout(this.reproject_.bind(this),0):this.sourceTiles_.forEach((function(e,t,i){e.getState()==TileState.IDLE&&e.load()}))}}unlistenSources_(){this.sourcesListenerKeys_.forEach(unlistenByKey),this.sourcesListenerKeys_=null}release(){this.canvas_&&(releaseCanvas(this.canvas_.getContext("2d")),canvasPool.push(this.canvas_),this.canvas_=null),super.release()}}export default ReprojTile;
//# sourceMappingURL=/sm/5b1db1b44c0a923e642dde56cd5e949ebf47065ff1db1dea58d6b7f212b5dfab.map