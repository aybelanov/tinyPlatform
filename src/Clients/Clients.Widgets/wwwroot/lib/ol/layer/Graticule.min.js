/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/layer/Graticule.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Collection from"../Collection.js";import EventType from"../render/EventType.js";import Feature from"../Feature.js";import Fill from"../style/Fill.js";import LineString from"../geom/LineString.js";import Point from"../geom/Point.js";import Stroke from"../style/Stroke.js";import Style from"../style/Style.js";import Text from"../style/Text.js";import VectorLayer from"./Vector.js";import VectorSource from"../source/Vector.js";import{applyTransform,approximatelyEquals,containsCoordinate,containsExtent,equals,getCenter,getIntersection,getWidth,intersects,isEmpty,wrapX as wrapExtentX}from"../extent.js";import{clamp}from"../math.js";import{degreesToStringHDMS}from"../coordinate.js";import{equivalent as equivalentProjection,get as getProjection,getTransform}from"../proj.js";import{getVectorContext}from"../render.js";import{meridian,parallel}from"../geom/flat/geodesic.js";const DEFAULT_STROKE_STYLE=new Stroke({color:"rgba(0,0,0,0.2)"}),INTERVALS=[90,45,30,20,10,5,2,1,.5,20/60,10/60,5/60,2/60,1/60,30/3600,20/3600,10/3600,5/3600,2/3600,1/3600];class Graticule extends VectorLayer{constructor(t){t=t||{};const e=Object.assign({updateWhileAnimating:!0,updateWhileInteracting:!0,renderBuffer:0},t);delete e.maxLines,delete e.strokeStyle,delete e.targetSize,delete e.showLabels,delete e.lonLabelFormatter,delete e.latLabelFormatter,delete e.lonLabelPosition,delete e.latLabelPosition,delete e.lonLabelStyle,delete e.latLabelStyle,delete e.intervals,super(e),this.projection_=null,this.maxLat_=1/0,this.maxLon_=1/0,this.minLat_=-1/0,this.minLon_=-1/0,this.maxX_=1/0,this.maxY_=1/0,this.minX_=-1/0,this.minY_=-1/0,this.targetSize_=void 0!==t.targetSize?t.targetSize:100,this.maxLines_=void 0!==t.maxLines?t.maxLines:100,this.meridians_=[],this.parallels_=[],this.strokeStyle_=void 0!==t.strokeStyle?t.strokeStyle:DEFAULT_STROKE_STYLE,this.fromLonLatTransform_=void 0,this.toLonLatTransform_=void 0,this.projectionCenterLonLat_=null,this.bottomLeft_=null,this.bottomRight_=null,this.topLeft_=null,this.topRight_=null,this.meridiansLabels_=null,this.parallelsLabels_=null,t.showLabels&&(this.lonLabelFormatter_=null==t.lonLabelFormatter?degreesToStringHDMS.bind(this,"EW"):t.lonLabelFormatter,this.latLabelFormatter_=null==t.latLabelFormatter?degreesToStringHDMS.bind(this,"NS"):t.latLabelFormatter,this.lonLabelPosition_=null==t.lonLabelPosition?0:t.lonLabelPosition,this.latLabelPosition_=null==t.latLabelPosition?1:t.latLabelPosition,this.lonLabelStyleBase_=new Style({text:void 0!==t.lonLabelStyle?t.lonLabelStyle.clone():new Text({font:"12px Calibri,sans-serif",textBaseline:"bottom",fill:new Fill({color:"rgba(0,0,0,1)"}),stroke:new Stroke({color:"rgba(255,255,255,1)",width:3})})}),this.lonLabelStyle_=t=>{const e=t.get("graticule_label");return this.lonLabelStyleBase_.getText().setText(e),this.lonLabelStyleBase_},this.latLabelStyleBase_=new Style({text:void 0!==t.latLabelStyle?t.latLabelStyle.clone():new Text({font:"12px Calibri,sans-serif",textAlign:"right",fill:new Fill({color:"rgba(0,0,0,1)"}),stroke:new Stroke({color:"rgba(255,255,255,1)",width:3})})}),this.latLabelStyle_=t=>{const e=t.get("graticule_label");return this.latLabelStyleBase_.getText().setText(e),this.latLabelStyleBase_},this.meridiansLabels_=[],this.parallelsLabels_=[],this.addEventListener(EventType.POSTRENDER,this.drawLabels_.bind(this))),this.intervals_=void 0!==t.intervals?t.intervals:INTERVALS,this.setSource(new VectorSource({loader:this.loaderFunction.bind(this),strategy:this.strategyFunction.bind(this),features:new Collection,overlaps:!1,useSpatialIndex:!1,wrapX:t.wrapX})),this.featurePool_=[],this.lineStyle_=new Style({stroke:this.strokeStyle_}),this.loadedExtent_=null,this.renderedExtent_=null,this.renderedResolution_=null,this.setRenderOrder(null)}strategyFunction(t,e){let i=t.slice();return this.projection_&&this.getSource().getWrapX()&&wrapExtentX(i,this.projection_),this.loadedExtent_&&(approximatelyEquals(this.loadedExtent_,i,e)?i=this.loadedExtent_.slice():this.getSource().removeLoadedExtent(this.loadedExtent_)),[i]}loaderFunction(t,e,i){this.loadedExtent_=t;const s=this.getSource(),a=this.getExtent()||[-1/0,-1/0,1/0,1/0],n=getIntersection(a,t);if(this.renderedExtent_&&equals(this.renderedExtent_,n)&&this.renderedResolution_===e)return;if(this.renderedExtent_=n,this.renderedResolution_=e,isEmpty(n))return;const l=getCenter(n),o=e*e/4;(!this.projection_||!equivalentProjection(this.projection_,i))&&this.updateProjectionInfo_(i),this.createGraticule_(n,l,e,o);let r,h=this.meridians_.length+this.parallels_.length;for(this.meridiansLabels_&&(h+=this.meridians_.length),this.parallelsLabels_&&(h+=this.parallels_.length);h>this.featurePool_.length;)r=new Feature,this.featurePool_.push(r);const _=s.getFeaturesCollection();_.clear();let m,L,d=0;for(m=0,L=this.meridians_.length;m<L;++m)r=this.featurePool_[d++],r.setGeometry(this.meridians_[m]),r.setStyle(this.lineStyle_),_.push(r);for(m=0,L=this.parallels_.length;m<L;++m)r=this.featurePool_[d++],r.setGeometry(this.parallels_[m]),r.setStyle(this.lineStyle_),_.push(r)}addMeridian_(t,e,i,s,a,n){const l=this.getMeridian_(t,e,i,s,n);if(intersects(l.getExtent(),a)){if(this.meridiansLabels_){const e=this.lonLabelFormatter_(t);n in this.meridiansLabels_?this.meridiansLabels_[n].text=e:this.meridiansLabels_[n]={geom:new Point([]),text:e}}this.meridians_[n++]=l}return n}addParallel_(t,e,i,s,a,n){const l=this.getParallel_(t,e,i,s,n);if(intersects(l.getExtent(),a)){if(this.parallelsLabels_){const e=this.latLabelFormatter_(t);n in this.parallelsLabels_?this.parallelsLabels_[n].text=e:this.parallelsLabels_[n]={geom:new Point([]),text:e}}this.parallels_[n++]=l}return n}drawLabels_(t){const e=t.frameState.viewState.rotation,i=t.frameState.viewState.resolution,s=t.frameState.size,a=t.frameState.extent,n=getCenter(a);let l=a;if(e){const t=s[0]*i,e=s[1]*i;l=[n[0]-t/2,n[1]-e/2,n[0]+t/2,n[1]+e/2]}let o=0,r=0,h=this.latLabelPosition_<.5;const _=this.projection_.getExtent(),m=getWidth(_);if(this.getSource().getWrapX()&&this.projection_.canWrapX()&&!containsExtent(_,a)){o=Math.floor((a[0]-_[0])/m),r=Math.ceil((a[2]-_[2])/m);h=h!==Math.abs(e)>Math.PI/2}const L=getVectorContext(t);for(let t=o;t<=r;++t){let i,s,_,d,c=this.meridians_.length+this.parallels_.length;if(this.meridiansLabels_)for(s=0,_=this.meridiansLabels_.length;s<_;++s){const o=this.meridians_[s];if(e||0!==t){const i=o.clone();i.translate(t*m,0),i.rotate(-e,n),d=this.getMeridianPoint_(i,l,s),d.rotate(e,n)}else d=this.getMeridianPoint_(o,a,s);i=this.featurePool_[c++],i.setGeometry(d),i.set("graticule_label",this.meridiansLabels_[s].text),L.drawFeature(i,this.lonLabelStyle_(i))}if(this.parallelsLabels_&&(t===o&&h||t===r&&!h))for(s=0,_=this.parallels_.length;s<_;++s){const o=this.parallels_[s];if(e||0!==t){const i=o.clone();i.translate(t*m,0),i.rotate(-e,n),d=this.getParallelPoint_(i,l,s),d.rotate(e,n)}else d=this.getParallelPoint_(o,a,s);i=this.featurePool_[c++],i.setGeometry(d),i.set("graticule_label",this.parallelsLabels_[s].text),L.drawFeature(i,this.latLabelStyle_(i))}}}createGraticule_(t,e,i,s){const a=this.getInterval_(i);if(-1==a)return this.meridians_.length=0,this.parallels_.length=0,this.meridiansLabels_&&(this.meridiansLabels_.length=0),void(this.parallelsLabels_&&(this.parallelsLabels_.length=0));let n=!1;const l=this.projection_.getExtent(),o=getWidth(l);this.getSource().getWrapX()&&this.projection_.canWrapX()&&!containsExtent(l,t)&&(getWidth(t)>=o?(t[0]=l[0],t[2]=l[2]):n=!0);const r=[clamp(e[0],this.minX_,this.maxX_),clamp(e[1],this.minY_,this.maxY_)],h=this.toLonLatTransform_(r);isNaN(h[1])&&(h[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_);let _=clamp(h[0],this.minLon_,this.maxLon_),m=clamp(h[1],this.minLat_,this.maxLat_);const L=this.maxLines_;let d,c,p,g,f=t;n||(f=[clamp(t[0],this.minX_,this.maxX_),clamp(t[1],this.minY_,this.maxY_),clamp(t[2],this.minX_,this.maxX_),clamp(t[3],this.minY_,this.maxY_)]);const x=applyTransform(f,this.toLonLatTransform_,void 0,8);let b=x[3],u=x[2],S=x[1],y=x[0];if(n||(containsCoordinate(f,this.bottomLeft_)&&(y=this.minLon_,S=this.minLat_),containsCoordinate(f,this.bottomRight_)&&(u=this.maxLon_,S=this.minLat_),containsCoordinate(f,this.topLeft_)&&(y=this.minLon_,b=this.maxLat_),containsCoordinate(f,this.topRight_)&&(u=this.maxLon_,b=this.maxLat_),b=clamp(b,m,this.maxLat_),u=clamp(u,_,this.maxLon_),S=clamp(S,this.minLat_,m),y=clamp(y,this.minLon_,_)),_=Math.floor(_/a)*a,g=clamp(_,this.minLon_,this.maxLon_),c=this.addMeridian_(g,S,b,s,t,0),d=0,n)for(;(g-=a)>=y&&d++<L;)c=this.addMeridian_(g,S,b,s,t,c);else for(;g!=this.minLon_&&d++<L;)g=Math.max(g-a,this.minLon_),c=this.addMeridian_(g,S,b,s,t,c);if(g=clamp(_,this.minLon_,this.maxLon_),d=0,n)for(;(g+=a)<=u&&d++<L;)c=this.addMeridian_(g,S,b,s,t,c);else for(;g!=this.maxLon_&&d++<L;)g=Math.min(g+a,this.maxLon_),c=this.addMeridian_(g,S,b,s,t,c);for(this.meridians_.length=c,this.meridiansLabels_&&(this.meridiansLabels_.length=c),m=Math.floor(m/a)*a,p=clamp(m,this.minLat_,this.maxLat_),c=this.addParallel_(p,y,u,s,t,0),d=0;p!=this.minLat_&&d++<L;)p=Math.max(p-a,this.minLat_),c=this.addParallel_(p,y,u,s,t,c);for(p=clamp(m,this.minLat_,this.maxLat_),d=0;p!=this.maxLat_&&d++<L;)p=Math.min(p+a,this.maxLat_),c=this.addParallel_(p,y,u,s,t,c);this.parallels_.length=c,this.parallelsLabels_&&(this.parallelsLabels_.length=c)}getInterval_(t){const e=this.projectionCenterLonLat_[0],i=this.projectionCenterLonLat_[1];let s=-1;const a=Math.pow(this.targetSize_*t,2),n=[],l=[];for(let t=0,o=this.intervals_.length;t<o;++t){const o=clamp(this.intervals_[t]/2,0,90),r=clamp(i,-90+o,90-o);n[0]=e-o,n[1]=r-o,l[0]=e+o,l[1]=r+o,this.fromLonLatTransform_(n,n),this.fromLonLatTransform_(l,l);if(Math.pow(l[0]-n[0],2)+Math.pow(l[1]-n[1],2)<=a)break;s=this.intervals_[t]}return s}getMeridian_(t,e,i,s,a){const n=meridian(t,e,i,this.projection_,s);let l=this.meridians_[a];return l?(l.setFlatCoordinates("XY",n),l.changed()):(l=new LineString(n,"XY"),this.meridians_[a]=l),l}getMeridianPoint_(t,e,i){const s=t.getFlatCoordinates();let a=1,n=s.length-1;s[a]>s[n]&&(a=n,n=1);const l=Math.max(e[1],s[a]),o=Math.min(e[3],s[n]),r=clamp(e[1]+Math.abs(e[1]-e[3])*this.lonLabelPosition_,l,o),h=[s[a-1]+(s[n-1]-s[a-1])*(r-s[a])/(s[n]-s[a]),r],_=this.meridiansLabels_[i].geom;return _.setCoordinates(h),_}getMeridians(){return this.meridians_}getParallel_(t,e,i,s,a){const n=parallel(t,e,i,this.projection_,s);let l=this.parallels_[a];return l?(l.setFlatCoordinates("XY",n),l.changed()):l=new LineString(n,"XY"),l}getParallelPoint_(t,e,i){const s=t.getFlatCoordinates();let a=0,n=s.length-2;s[a]>s[n]&&(a=n,n=0);const l=Math.max(e[0],s[a]),o=Math.min(e[2],s[n]),r=clamp(e[0]+Math.abs(e[0]-e[2])*this.latLabelPosition_,l,o),h=[r,s[a+1]+(s[n+1]-s[a+1])*(r-s[a])/(s[n]-s[a])],_=this.parallelsLabels_[i].geom;return _.setCoordinates(h),_}getParallels(){return this.parallels_}updateProjectionInfo_(t){const e=getProjection("EPSG:4326"),i=t.getWorldExtent();this.maxLat_=i[3],this.maxLon_=i[2],this.minLat_=i[1],this.minLon_=i[0];const s=getTransform(t,e);if(this.minLon_<this.maxLon_)this.toLonLatTransform_=s;else{const t=this.minLon_+this.maxLon_/2;this.maxLon_+=360,this.toLonLatTransform_=function(e,i,a){const n=s(e,i,a=a||2);for(let e=0,i=n.length;e<i;e+=a)n[e]<t&&(n[e]+=360);return n}}this.fromLonLatTransform_=getTransform(e,t);const a=applyTransform([this.minLon_,this.minLat_,this.maxLon_,this.maxLat_],this.fromLonLatTransform_,void 0,8);this.minX_=a[0],this.maxX_=a[2],this.minY_=a[1],this.maxY_=a[3],this.bottomLeft_=this.fromLonLatTransform_([this.minLon_,this.minLat_]),this.bottomRight_=this.fromLonLatTransform_([this.maxLon_,this.minLat_]),this.topLeft_=this.fromLonLatTransform_([this.minLon_,this.maxLat_]),this.topRight_=this.fromLonLatTransform_([this.maxLon_,this.maxLat_]),this.projectionCenterLonLat_=this.toLonLatTransform_(getCenter(t.getExtent())),isNaN(this.projectionCenterLonLat_[1])&&(this.projectionCenterLonLat_[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_),this.projection_=t}}export default Graticule;
//# sourceMappingURL=/sm/657fd530144fea1187d6b7a2e67286252618e60079c85d81377c54145120fb29.map