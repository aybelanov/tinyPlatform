/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/layer/Group.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BaseLayer from"./Base.js";import Collection from"../Collection.js";import CollectionEventType from"../CollectionEventType.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import ObjectEventType from"../ObjectEventType.js";import{assert}from"../asserts.js";import{clear}from"../obj.js";import{getIntersection}from"../extent.js";import{getUid}from"../util.js";import{listen,unlistenByKey}from"../events.js";export class GroupEvent extends Event{constructor(e,t){super(e),this.layer=t}}const Property={LAYERS:"layers"};class LayerGroup extends BaseLayer{constructor(e){e=e||{};const t=Object.assign({},e);delete t.layers;let s=e.layers;super(t),this.on,this.once,this.un,this.layersListenerKeys_=[],this.listenerKeys_={},this.addChangeListener(Property.LAYERS,this.handleLayersChanged_),s?Array.isArray(s)?s=new Collection(s.slice(),{unique:!0}):assert("function"==typeof s.getArray,"Expected `layers` to be an array or a `Collection`"):s=new Collection(void 0,{unique:!0}),this.setLayers(s)}handleLayerChange_(){this.changed()}handleLayersChanged_(){this.layersListenerKeys_.forEach(unlistenByKey),this.layersListenerKeys_.length=0;const e=this.getLayers();this.layersListenerKeys_.push(listen(e,CollectionEventType.ADD,this.handleLayersAdd_,this),listen(e,CollectionEventType.REMOVE,this.handleLayersRemove_,this));for(const e in this.listenerKeys_)this.listenerKeys_[e].forEach(unlistenByKey);clear(this.listenerKeys_);const t=e.getArray();for(let e=0,s=t.length;e<s;e++){const s=t[e];this.registerLayerListeners_(s),this.dispatchEvent(new GroupEvent("addlayer",s))}this.changed()}registerLayerListeners_(e){const t=[listen(e,ObjectEventType.PROPERTYCHANGE,this.handleLayerChange_,this),listen(e,EventType.CHANGE,this.handleLayerChange_,this)];e instanceof LayerGroup&&t.push(listen(e,"addlayer",this.handleLayerGroupAdd_,this),listen(e,"removelayer",this.handleLayerGroupRemove_,this)),this.listenerKeys_[getUid(e)]=t}handleLayerGroupAdd_(e){this.dispatchEvent(new GroupEvent("addlayer",e.layer))}handleLayerGroupRemove_(e){this.dispatchEvent(new GroupEvent("removelayer",e.layer))}handleLayersAdd_(e){const t=e.element;this.registerLayerListeners_(t),this.dispatchEvent(new GroupEvent("addlayer",t)),this.changed()}handleLayersRemove_(e){const t=e.element,s=getUid(t);this.listenerKeys_[s].forEach(unlistenByKey),delete this.listenerKeys_[s],this.dispatchEvent(new GroupEvent("removelayer",t)),this.changed()}getLayers(){return this.get(Property.LAYERS)}setLayers(e){const t=this.getLayers();if(t){const e=t.getArray();for(let t=0,s=e.length;t<s;++t)this.dispatchEvent(new GroupEvent("removelayer",e[t]))}this.set(Property.LAYERS,e)}getLayersArray(e){return e=void 0!==e?e:[],this.getLayers().forEach((function(t){t.getLayersArray(e)})),e}getLayerStatesArray(e){const t=void 0!==e?e:[],s=t.length;this.getLayers().forEach((function(e){e.getLayerStatesArray(t)}));const r=this.getLayerState();let n=r.zIndex;e||void 0!==r.zIndex||(n=0);for(let e=s,i=t.length;e<i;e++){const s=t[e];s.opacity*=r.opacity,s.visible=s.visible&&r.visible,s.maxResolution=Math.min(s.maxResolution,r.maxResolution),s.minResolution=Math.max(s.minResolution,r.minResolution),s.minZoom=Math.max(s.minZoom,r.minZoom),s.maxZoom=Math.min(s.maxZoom,r.maxZoom),void 0!==r.extent&&(void 0!==s.extent?s.extent=getIntersection(s.extent,r.extent):s.extent=r.extent),void 0===s.zIndex&&(s.zIndex=n)}return t}getSourceState(){return"ready"}}export default LayerGroup;
//# sourceMappingURL=/sm/39e3365dfc6ad6972bd38f1267f9b3b78c875f3f54983e8355349d9ecc4a8f96.map