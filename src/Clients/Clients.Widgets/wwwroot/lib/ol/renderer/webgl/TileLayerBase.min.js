/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/renderer/webgl/TileLayerBase.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import LRUCache from"../../structs/LRUCache.js";import ReprojDataTile from"../../reproj/DataTile.js";import ReprojTile from"../../reproj/Tile.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import WebGLLayerRenderer from"./Layer.js";import{abstract,getUid}from"../../util.js";import{create as createMat4}from"../../vec/mat4.js";import{createOrUpdate as createTileCoord,getKey as getTileCoordKey}from"../../tilecoord.js";import{create as createTransform,reset as resetTransform,rotate as rotateTransform,scale as scaleTransform,translate as translateTransform}from"../../transform.js";import{descending}from"../../array.js";import{fromUserExtent}from"../../proj.js";import{getIntersection,isEmpty}from"../../extent.js";import{toSize}from"../../size.js";export const Uniforms={TILE_TRANSFORM:"u_tileTransform",TRANSITION_ALPHA:"u_transitionAlpha",DEPTH:"u_depth",RENDER_EXTENT:"u_renderExtent",RESOLUTION:"u_resolution",ZOOM:"u_zoom",GLOBAL_ALPHA:"u_globalAlpha",PROJECTION_MATRIX:"u_projectionMatrix",SCREEN_TO_WORLD_MATRIX:"u_screenToWorldMatrix"};const empty={};function depthForZ(e){return 1/(e+2)}export function newTileRepresentationLookup(){return{tileIds:new Set,representationsByZ:{}}}function lookupHasTile(e,t){return e.tileIds.has(getUid(t))}function addTileRepresentationToLookup(e,t,r){const i=e.representationsByZ;r in i||(i[r]=new Set),i[r].add(t),e.tileIds.add(getUid(t.tile))}function getRenderExtent(e,t){const r=e.layerStatesArray[e.layerIndex];r.extent&&(t=getIntersection(t,fromUserExtent(r.extent,e.viewState.projection)));const i=r.layer.getRenderSource();if(!i.getWrapX()){const r=i.getTileGridForProjection(e.viewState.projection).getExtent();r&&(t=getIntersection(t,r))}return t}export function getCacheKey(e,t){return`${e.getKey()},${getTileCoordKey(t)}`}class WebGLBaseTileLayerRenderer extends WebGLLayerRenderer{constructor(e,t){super(e,{uniforms:t.uniforms,postProcesses:t.postProcesses}),this.renderComplete=!1,this.tileTransform_=createTransform(),this.tempMat4=createMat4(),this.tempTileRange_=new TileRange(0,0,0,0),this.tempTileCoord_=createTileCoord(0,0,0),this.tempSize_=[0,0];const r=void 0!==t.cacheSize?t.cacheSize:512;this.tileRepresentationCache=new LRUCache(r),this.frameState=null,this.projection_=void 0}reset(e){super.reset({uniforms:e.uniforms})}isDrawableTile_(e){const t=this.getLayer(),r=e.getState(),i=t.getUseInterimTilesOnError();return r==TileState.LOADED||r==TileState.EMPTY||r==TileState.ERROR&&!i}prepareFrameInternal(e){this.projection_?e.viewState.projection!==this.projection_&&(this.clearCache(),this.projection_=e.viewState.projection):this.projection_=e.viewState.projection;const t=this.getLayer().getRenderSource();return!!t&&(!isEmpty(getRenderExtent(e,e.extent))&&"ready"===t.getState())}createTileRepresentation(e){return abstract()}enqueueTiles(e,t,r,i,o){const n=e.viewState,s=this.getLayer(),a=s.getRenderSource(),l=a.getTileGridForProjection(n.projection),c=a.getGutterForProjection(n.projection),p=getUid(a);p in e.wantedTiles||(e.wantedTiles[p]={});const T=e.wantedTiles[p],d=this.tileRepresentationCache,m=s.getMapInternal(),h=Math.max(r-o,l.getMinZoom(),l.getZForResolution(Math.min(s.getMaxResolution(),m?m.getView().getResolutionForZoom(Math.max(s.getMinZoom(),0)):l.getResolution(0)),a.zDirection));for(let o=r;o>=h;--o){const r=l.getTileRangeForExtentAndZ(t,o,this.tempTileRange_),s=l.getResolution(o);for(let t=r.minX;t<=r.maxX;++t)for(let m=r.minY;m<=r.maxY;++m){const r=createTileCoord(o,t,m,this.tempTileCoord_),h=getCacheKey(a,r);let u,f;if(d.containsKey(h)&&(u=d.get(h),f=u.tile),u&&u.tile.key===a.getKey()||(f=a.getTile(o,t,m,e.pixelRatio,n.projection)),lookupHasTile(i,f))continue;if(u)if(this.isDrawableTile_(f))u.setTile(f);else{const e=f.getInterimTile();u.setTile(e)}else u=this.createTileRepresentation({tile:f,grid:l,helper:this.helper,gutter:c}),d.set(h,u);addTileRepresentationToLookup(i,u,o);const g=f.getKey();T[g]=!0,f.getState()===TileState.IDLE&&(e.tileQueue.isKeyQueued(g)||e.tileQueue.enqueue([f,p,l.getTileCoordCenter(r),s]))}}}beforeTilesRender(e,t){this.helper.prepareDraw(this.frameState,!t,!0)}renderTile(e,t,r,i,o,n,s,a,l,c,p){}drawTile_(e,t,r,i,o,n,s){if(!t.loaded)return;const a=t.tile.tileCoord,l=getTileCoordKey(a),c=l in n?n[l]:1,p=s.getResolution(r),T=toSize(s.getTileSize(r),this.tempSize_),d=s.getOrigin(r),m=s.getTileCoordExtent(a),h=c<1?-1:depthForZ(r);c<1&&(e.animate=!0);const u=e.viewState,f=u.center[0],g=u.center[1],R=T[0]+2*i,j=T[1]+2*i,S=R/j,C=(f-d[0])/(T[0]*p),_=(d[1]-g)/(T[1]*p),y=u.resolution/p,x=a[1],E=a[2];resetTransform(this.tileTransform_),scaleTransform(this.tileTransform_,2/(e.size[0]*y/R),-2/(e.size[1]*y/R)),rotateTransform(this.tileTransform_,u.rotation),scaleTransform(this.tileTransform_,1,1/S),translateTransform(this.tileTransform_,(T[0]*(x-C)-i)/R,(T[1]*(E-_)-i)/j),this.renderTile(t,this.tileTransform_,e,o,p,T,d,m,h,i,c)}renderFrame(e){this.frameState=e,this.renderComplete=!0;const t=this.helper.getGL();this.preRender(t,e);const r=e.viewState,i=this.getLayer(),o=i.getRenderSource(),n=o.getTileGridForProjection(r.projection),s=o.getGutterForProjection(r.projection),a=getRenderExtent(e,e.extent),l=n.getZForResolution(r.resolution,o.zDirection),c=newTileRepresentationLookup(),p=i.getPreload();if(e.nextExtent){const t=n.getZForResolution(r.nextResolution,o.zDirection),i=getRenderExtent(e,e.nextExtent);this.enqueueTiles(e,i,t,c,p)}this.enqueueTiles(e,a,l,c,0),p>0&&setTimeout((()=>{this.enqueueTiles(e,a,l-1,c,p-1)}),0);const T={},d=getUid(this),m=e.time;let h=!1;for(const e of c.representationsByZ[l]){const t=e.tile;if((t instanceof ReprojTile||t instanceof ReprojDataTile)&&t.getState()===TileState.EMPTY)continue;const r=t.tileCoord;if(e.loaded){const e=t.getAlpha(d,m);if(1===e){t.endTransition(d);continue}h=!0;T[getTileCoordKey(r)]=e}this.renderComplete=!1;if(this.findAltTiles_(n,r,l+1,c))continue;const i=n.getMinZoom();for(let e=l-1;e>=i;--e){if(this.findAltTiles_(n,r,e,c))break}}this.beforeTilesRender(e,h);const u=c.representationsByZ,f=Object.keys(u).map(Number).sort(descending);for(let t=0,r=f.length;t<r;++t){const r=f[t];for(const t of u[r]){const i=t.tile.tileCoord;getTileCoordKey(i)in T||this.drawTile_(e,t,r,s,a,T,n)}}for(const t of u[l]){const r=t.tile.tileCoord;getTileCoordKey(r)in T&&this.drawTile_(e,t,l,s,a,T,n)}this.helper.finalizeDraw(e,this.dispatchPreComposeEvent,this.dispatchPostComposeEvent);const g=this.helper.getCanvas(),R=this.tileRepresentationCache;for(;R.canExpireCache();){R.pop().dispose()}return e.postRenderFunctions.push((function(e,t){o.updateCacheSize(.1,t.viewState.projection),o.expireCache(t.viewState.projection,empty)})),this.postRender(t,e),g}findAltTiles_(e,t,r,i){const o=e.getTileRangeForTileCoordAndZ(t,r,this.tempTileRange_);if(!o)return!1;let n=!0;const s=this.tileRepresentationCache,a=this.getLayer().getRenderSource();for(let e=o.minX;e<=o.maxX;++e)for(let t=o.minY;t<=o.maxY;++t){const o=getCacheKey(a,[r,e,t]);let l=!1;if(s.containsKey(o)){const e=s.get(o);e.loaded&&!lookupHasTile(i,e.tile)&&(addTileRepresentationToLookup(i,e,r),l=!0)}l||(n=!1)}return n}clearCache(){const e=this.tileRepresentationCache;e.forEach((e=>e.dispose())),e.clear()}removeHelper(){this.helper&&this.clearCache(),super.removeHelper()}disposeInternal(){super.disposeInternal(),delete this.frameState}}export default WebGLBaseTileLayerRenderer;
//# sourceMappingURL=/sm/321cde093a90213e54f37cd739f36f2d765b99aed93a8122429f4b535fb872c8.map