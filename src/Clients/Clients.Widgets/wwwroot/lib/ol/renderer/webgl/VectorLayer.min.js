/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/renderer/webgl/VectorLayer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BaseVector from"../../layer/BaseVector.js";import MixedGeometryBatch from"../../render/webgl/MixedGeometryBatch.js";import VectorEventType from"../../source/VectorEventType.js";import VectorStyleRenderer from"../../render/webgl/VectorStyleRenderer.js";import ViewHint from"../../ViewHint.js";import WebGLLayerRenderer from"./Layer.js";import{DefaultUniform}from"../../webgl/Helper.js";import{buffer,createEmpty,equals,getWidth}from"../../extent.js";import{create as createMat4,fromTransform as mat4FromTransform}from"../../vec/mat4.js";import{create as createTransform,makeInverse as makeInverseTransform,multiply as multiplyTransform,setFromArray as setFromTransform,translate as translateTransform}from"../../transform.js";import{listen,unlistenByKey}from"../../events.js";export const Uniforms={...DefaultUniform,RENDER_EXTENT:"u_renderExtent",GLOBAL_ALPHA:"u_globalAlpha"};class WebGLVectorLayerRenderer extends WebGLLayerRenderer{constructor(e,t){super(e,{uniforms:{[Uniforms.RENDER_EXTENT]:[0,0,0,0],[Uniforms.GLOBAL_ALPHA]:1},postProcesses:t.postProcesses}),this.sourceRevision_=-1,this.previousExtent_=createEmpty(),this.currentTransform_=createTransform(),this.tmpTransform_=createTransform(),this.tmpMat4_=createMat4(),this.currentFrameStateTransform_=createTransform(),this.styles_=[],this.styleRenderers_=[],this.buffers_=[],this.applyOptions_(t),this.batch_=new MixedGeometryBatch;const r=this.getLayer().getSource();this.batch_.addFeatures(r.getFeatures()),this.sourceListenKeys_=[listen(r,VectorEventType.ADDFEATURE,this.handleSourceFeatureAdded_,this),listen(r,VectorEventType.CHANGEFEATURE,this.handleSourceFeatureChanged_,this),listen(r,VectorEventType.REMOVEFEATURE,this.handleSourceFeatureDelete_,this),listen(r,VectorEventType.CLEAR,this.handleSourceFeatureClear_,this)]}applyOptions_(e){this.styles_=Array.isArray(e.style)?e.style:[e.style]}createRenderers_(){this.buffers_=[],this.styleRenderers_=this.styles_.map((e=>new VectorStyleRenderer(e,this.helper)))}reset(e){this.applyOptions_(e),this.helper&&this.createRenderers_(),super.reset(e)}afterHelperCreated(){this.createRenderers_()}handleSourceFeatureAdded_(e){const t=e.feature;this.batch_.addFeature(t)}handleSourceFeatureChanged_(e){const t=e.feature;this.batch_.changeFeature(t)}handleSourceFeatureDelete_(e){const t=e.feature;this.batch_.removeFeature(t)}handleSourceFeatureClear_(){this.batch_.clear()}applyUniforms_(e){setFromTransform(this.tmpTransform_,this.currentFrameStateTransform_),multiplyTransform(this.tmpTransform_,e),this.helper.setUniformMatrixValue(Uniforms.PROJECTION_MATRIX,mat4FromTransform(this.tmpMat4_,this.tmpTransform_)),makeInverseTransform(this.tmpTransform_,this.tmpTransform_),this.helper.setUniformMatrixValue(Uniforms.SCREEN_TO_WORLD_MATRIX,mat4FromTransform(this.tmpMat4_,this.tmpTransform_))}renderFrame(e){const t=this.helper.getGL();this.preRender(t,e),this.helper.prepareDraw(e),this.currentFrameStateTransform_=this.helper.makeProjectionTransform(e,this.currentFrameStateTransform_);const r=this.getLayer().getSource(),s=e.viewState.projection,a=r.getWrapX()&&s.canWrapX(),n=s.getExtent(),o=e.extent,i=a?getWidth(n):null,h=a?Math.ceil((o[2]-n[2])/i)+1:1;let m=a?Math.floor((o[0]-n[0])/i):0;translateTransform(this.currentFrameStateTransform_,m*i,0);do{for(let t=0,r=this.styleRenderers_.length;t<r;t++){const r=this.styleRenderers_[t],s=this.buffers_[t];s&&r.render(s,e,(()=>{this.applyUniforms_(s.invertVerticesTransform)}))}translateTransform(this.currentFrameStateTransform_,i,0)}while(++m<h);this.helper.finalizeDraw(e);const l=this.helper.getCanvas(),c=e.layerStatesArray[e.layerIndex].opacity;return c!==parseFloat(l.style.opacity)&&(l.style.opacity=String(c)),this.postRender(t,e),l}prepareFrameInternal(e){const t=this.getLayer(),r=t.getSource(),s=e.viewState,a=!e.viewHints[ViewHint.ANIMATING]&&!e.viewHints[ViewHint.INTERACTING],n=!equals(this.previousExtent_,e.extent),o=this.sourceRevision_<r.getRevision();if(o&&(this.sourceRevision_=r.getRevision()),a&&(n||o)){const a=s.projection,n=s.resolution,o=t instanceof BaseVector?t.getRenderBuffer():0,i=buffer(e.extent,o*n);r.loadFeatures(i,n,a),this.ready=!1;const h=this.helper.makeProjectionTransform(e,createTransform()),m=this.styleRenderers_.map(((e,t)=>e.generateBuffers(this.batch_,h).then((e=>{this.buffers_[t]=e}))));Promise.all(m).then((()=>{this.ready=!0,this.getLayer().changed()})),this.previousExtent_=e.extent.slice()}return!0}forEachFeatureAtCoordinate(e,t,r,s,a){}disposeInternal(){this.sourceListenKeys_.forEach((function(e){unlistenByKey(e)})),this.sourceListenKeys_=null,super.disposeInternal()}}export default WebGLVectorLayerRenderer;
//# sourceMappingURL=/sm/db39143357b2428b66093af0047d5ed0f2f6231d8b28bb3e24e7597e97ce4df9.map