/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/renderer/canvas/VectorTileLayer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasBuilderGroup from"../../render/canvas/BuilderGroup.js";import CanvasExecutorGroup from"../../render/canvas/ExecutorGroup.js";import CanvasTileLayerRenderer from"./TileLayer.js";import TileState from"../../TileState.js";import ViewHint from"../../ViewHint.js";import{HIT_DETECT_RESOLUTION,createHitDetectionImageData,hitDetect}from"../../render/canvas/hitdetect.js";import{apply as applyTransform,create as createTransform,multiply,reset as resetTransform,scale,scale as scaleTransform,translate as translateTransform}from"../../transform.js";import{boundingExtent,buffer,containsExtent,equals,getIntersection,getTopLeft,intersects}from"../../extent.js";import{getSquaredTolerance as getSquaredRenderTolerance,renderFeature}from"../vector.js";import{getUid}from"../../util.js";import{toSize}from"../../size.js";import{wrapX}from"../../coordinate.js";const IMAGE_REPLAYS={image:["Polygon","Circle","LineString","Image","Text"],hybrid:["Polygon","LineString"],vector:[]},VECTOR_REPLAYS={hybrid:["Image","Text","Default"],vector:["Polygon","Circle","LineString","Image","Text","Default"]};class CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer{constructor(e){super(e),this.boundHandleStyleImageChange_=this.handleStyleImageChange_.bind(this),this.renderedLayerRevision_,this.renderedPixelToCoordinateTransform_=null,this.renderedRotation_,this.tmpTransform_=createTransform()}prepareTile(e,t,r){let o;const i=e.getState();return i!==TileState.LOADED&&i!==TileState.ERROR||(this.updateExecutorGroup_(e,t,r),this.tileImageNeedsRender_(e)&&(o=!0)),o}getTile(e,t,r,o){const i=o.pixelRatio,n=o.viewState,s=n.resolution,a=n.projection,l=this.getLayer(),d=l.getSource().getTile(e,t,r,i,a),c=o.viewHints,g=!(c[ViewHint.ANIMATING]||c[ViewHint.INTERACTING]);!g&&d.wantedResolution||(d.wantedResolution=s);return this.prepareTile(d,i,a)&&(g||Date.now()-o.time<8)&&"vector"!==l.getRenderMode()&&this.renderTileImage_(d,o),super.getTile(e,t,r,o)}isDrawableTile(e){const t=this.getLayer();return super.isDrawableTile(e)&&("vector"===t.getRenderMode()?getUid(t)in e.executorGroups:e.hasContext(t))}getTileImage(e){return e.getImage(this.getLayer())}prepareFrame(e){const t=this.getLayer().getRevision();return this.renderedLayerRevision_!==t&&(this.renderedLayerRevision_=t,this.renderedTiles.length=0),super.prepareFrame(e)}updateExecutorGroup_(e,t,r){const o=this.getLayer(),i=o.getRevision(),n=o.getRenderOrder()||null,s=e.wantedResolution,a=e.getReplayState(o);if(!a.dirty&&a.renderedResolution===s&&a.renderedRevision==i&&a.renderedRenderOrder==n)return;const l=o.getSource(),d=o.getDeclutter(),c=l.getTileGrid(),g=l.getTileGridForProjection(r).getTileCoordExtent(e.wrappedTileCoord),u=l.getSourceTiles(t,r,e),T=getUid(o);delete e.hitDetectionImageData[T],e.executorGroups[T]=[],d&&(e.declutterExecutorGroups[T]=[]),a.dirty=!1;for(let r=0,i=u.length;r<i;++r){const i=u[r];if(i.getState()!=TileState.LOADED)continue;const p=i.tileCoord,h=c.getTileCoordExtent(p),f=getIntersection(g,h),m=buffer(f,o.getRenderBuffer()*s,this.tmpExtent),R=equals(h,f)?null:m,S=new CanvasBuilderGroup(0,m,s,t),C=d?new CanvasBuilderGroup(0,f,s,t):void 0,v=getSquaredRenderTolerance(s,t),y=function(e){let t;const r=e.getStyleFunction()||o.getStyleFunction();if(r&&(t=r(e,s)),t){const r=this.renderFeature(e,v,t,S,C);a.dirty=a.dirty||r}},x=i.getFeatures();n&&n!==a.renderedRenderOrder&&x.sort(n);for(let e=0,t=x.length;e<t;++e){const t=x[e];R&&!intersects(R,t.getGeometry().getExtent())||y.call(this,t)}const E=S.finish(),I="vector"!==o.getRenderMode()&&d&&1===u.length?null:f,w=new CanvasExecutorGroup(I,s,t,l.getOverlaps(),E,o.getRenderBuffer());if(e.executorGroups[T].push(w),C){const r=new CanvasExecutorGroup(null,s,t,l.getOverlaps(),C.finish(),o.getRenderBuffer());e.declutterExecutorGroups[T].push(r)}}a.renderedRevision=i,a.renderedRenderOrder=n,a.renderedResolution=s}forEachFeatureAtCoordinate(e,t,r,o,i){const n=t.viewState.resolution,s=t.viewState.rotation;r=null==r?0:r;const a=this.getLayer(),l=a.getSource().getTileGridForProjection(t.viewState.projection),d=boundingExtent([e]);buffer(d,n*r,d);const c={},g=function(e,t,r){let n=e.getId();void 0===n&&(n=getUid(e));const s=c[n];if(s){if(!0!==s&&r<s.distanceSq){if(0===r)return c[n]=!0,i.splice(i.lastIndexOf(s),1),o(e,a,t);s.geometry=t,s.distanceSq=r}}else{if(0===r)return c[n]=!0,o(e,a,t);i.push(c[n]={feature:e,layer:a,geometry:t,distanceSq:r,callback:o})}},u=this.renderedTiles;let T;for(let o=0,i=u.length;!T&&o<i;++o){const i=u[o],c=l.getTileCoordExtent(i.wrappedTileCoord);if(!intersects(c,d))continue;const p=getUid(a),h=[i.executorGroups[p]],f=i.declutterExecutorGroups[p];f&&h.push(f),h.some((o=>{const i=o===f?t.declutterTree.all().map((e=>e.value)):null;for(let t=0,a=o.length;t<a;++t){const a=o[t];if(T=a.forEachFeatureAtCoordinate(e,n,s,r,g,i),T)return!0}}))}return T}getFeatures(e){return new Promise(((t,r)=>{const o=this.getLayer(),i=getUid(o),n=o.getSource(),s=this.renderedProjection,a=s.getExtent(),l=this.renderedResolution,d=n.getTileGridForProjection(s),c=applyTransform(this.renderedPixelToCoordinateTransform_,e.slice()),g=d.getTileCoordForCoordAndResolution(c,l);let u;for(let e=0,t=this.renderedTiles.length;e<t;++e)if(g.toString()===this.renderedTiles[e].tileCoord.toString()){if(u=this.renderedTiles[e],u.getState()===TileState.LOADED){const e=d.getTileCoordExtent(u.tileCoord);n.getWrapX()&&s.canWrapX()&&!containsExtent(a,e)&&wrapX(c,s);break}u=void 0}if(!u||u.loadingSourceTiles>0)return void t([]);const T=d.getTileCoordExtent(u.wrappedTileCoord),p=getTopLeft(T),h=[(c[0]-p[0])/l,(p[1]-c[1])/l],f=u.getSourceTiles().reduce((function(e,t){return e.concat(t.getFeatures())}),[]);let m=u.hitDetectionImageData[i];if(!m){const e=toSize(d.getTileSize(d.getZForResolution(l,n.zDirection))),t=this.renderedRotation_,r=[this.getRenderTransform(d.getTileCoordCenter(u.wrappedTileCoord),l,0,HIT_DETECT_RESOLUTION,e[0]*HIT_DETECT_RESOLUTION,e[1]*HIT_DETECT_RESOLUTION,0)];m=createHitDetectionImageData(e,r,f,o.getStyleFunction(),d.getTileCoordExtent(u.wrappedTileCoord),u.getReplayState(o).renderedResolution,t),u.hitDetectionImageData[i]=m}t(hitDetect(h,f,m))}))}handleFontsChanged(){const e=this.getLayer();e.getVisible()&&void 0!==this.renderedLayerRevision_&&e.changed()}handleStyleImageChange_(e){this.renderIfReadyAndVisible()}renderDeclutter(e){const t=this.context,r=t.globalAlpha;t.globalAlpha=this.getLayer().getOpacity();const o=e.viewHints,i=!(o[ViewHint.ANIMATING]||o[ViewHint.INTERACTING]),n=this.renderedTiles;for(let t=0,r=n.length;t<r;++t){const r=n[t],o=r.declutterExecutorGroups[getUid(this.getLayer())];if(o)for(let t=o.length-1;t>=0;--t)o[t].execute(this.context,1,this.getTileRenderTransform(r,e),e.viewState.rotation,i,void 0,e.declutterTree)}t.globalAlpha=r}getTileRenderTransform(e,t){const r=t.pixelRatio,o=t.viewState,i=o.center,n=o.resolution,s=o.rotation,a=t.size,l=Math.round(a[0]*r),d=Math.round(a[1]*r),c=this.getLayer().getSource().getTileGridForProjection(t.viewState.projection),g=e.tileCoord,u=c.getTileCoordExtent(e.wrappedTileCoord),T=c.getTileCoordExtent(g,this.tmpExtent)[0]-u[0];return multiply(scale(this.inversePixelTransform.slice(),1/r,1/r),this.getRenderTransform(i,n,s,r,l,d,T))}postRender(e,t){const r=t.viewHints,o=!(r[ViewHint.ANIMATING]||r[ViewHint.INTERACTING]);this.renderedPixelToCoordinateTransform_=t.pixelToCoordinateTransform.slice(),this.renderedRotation_=t.viewState.rotation;const i=this.getLayer(),n=i.getRenderMode(),s=e.globalAlpha;e.globalAlpha=i.getOpacity();const a=VECTOR_REPLAYS[n],l=t.viewState,d=l.rotation,c=i.getSource(),g=c.getTileGridForProjection(l.projection).getZForResolution(l.resolution,c.zDirection),u=this.renderedTiles,T=[],p=[];let h=!0;for(let r=u.length-1;r>=0;--r){const n=u[r];h=h&&!n.getReplayState(i).dirty;const s=n.executorGroups[getUid(i)].filter((e=>e.hasExecutors(a)));if(0===s.length)continue;const l=this.getTileRenderTransform(n,t),c=n.tileCoord[0];let f=!1;const m=s[0].getClipCoords(l);if(m){for(let t=0,r=T.length;t<r;++t)if(g!==c&&c<p[t]){const r=T[t];intersects([m[0],m[3],m[4],m[7]],[r[0],r[3],r[4],r[7]])&&(f||(e.save(),f=!0),e.beginPath(),e.moveTo(m[0],m[1]),e.lineTo(m[2],m[3]),e.lineTo(m[4],m[5]),e.lineTo(m[6],m[7]),e.moveTo(r[6],r[7]),e.lineTo(r[4],r[5]),e.lineTo(r[2],r[3]),e.lineTo(r[0],r[1]),e.clip())}T.push(m),p.push(c)}for(let t=0,r=s.length;t<r;++t){s[t].execute(e,1,l,d,o,a)}f&&e.restore()}e.globalAlpha=s,this.ready=h,super.postRender(e,t)}renderFeature(e,t,r,o,i){if(!r)return!1;let n=!1;if(Array.isArray(r))for(let s=0,a=r.length;s<a;++s)n=renderFeature(o,e,r[s],t,this.boundHandleStyleImageChange_,void 0,i)||n;else n=renderFeature(o,e,r,t,this.boundHandleStyleImageChange_,void 0,i);return n}tileImageNeedsRender_(e){const t=this.getLayer();if("vector"===t.getRenderMode())return!1;const r=e.getReplayState(t),o=t.getRevision(),i=e.wantedResolution;return r.renderedTileResolution!==i||r.renderedTileRevision!==o}renderTileImage_(e,t){const r=this.getLayer(),o=e.getReplayState(r),i=r.getRevision(),n=e.executorGroups[getUid(r)];o.renderedTileRevision=i;const s=e.wrappedTileCoord,a=s[0],l=r.getSource();let d=t.pixelRatio;const c=t.viewState.projection,g=l.getTileGridForProjection(c),u=g.getResolution(e.tileCoord[0]),T=t.pixelRatio/e.wantedResolution*u,p=g.getResolution(a),h=e.getContext(r);d=Math.round(Math.max(d,T/d));const f=l.getTilePixelSize(a,d,c);h.canvas.width=f[0],h.canvas.height=f[1];const m=d/T;if(1!==m){const e=resetTransform(this.tmpTransform_);scaleTransform(e,m,m),h.setTransform.apply(h,e)}const R=g.getTileCoordExtent(s,this.tmpExtent),S=T/p,C=resetTransform(this.tmpTransform_);scaleTransform(C,S,-S),translateTransform(C,-R[0],-R[3]);for(let e=0,t=n.length;e<t;++e){n[e].execute(h,m,C,0,!0,IMAGE_REPLAYS[r.getRenderMode()])}o.renderedTileResolution=e.wantedResolution}}export default CanvasVectorTileLayerRenderer;
//# sourceMappingURL=/sm/de5baeb2f9c1a3105992dced746f12f0bb1f0ca087b441c082921c464542ee47.map