/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/renderer/canvas/TileLayer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasLayerRenderer from"./Layer.js";import ImageTile from"../../ImageTile.js";import ReprojTile from"../../reproj/Tile.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import{apply as applyTransform,compose as composeTransform,makeInverse,toString as toTransformString}from"../../transform.js";import{ascending}from"../../array.js";import{containsCoordinate,createEmpty,equals,getHeight,getIntersection,getRotatedViewport,getTopLeft,getWidth,intersects}from"../../extent.js";import{fromUserExtent}from"../../proj.js";import{getUid}from"../../util.js";import{toSize}from"../../size.js";class CanvasTileLayerRenderer extends CanvasLayerRenderer{constructor(e){super(e),this.extentChanged=!0,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=createEmpty(),this.tmpTileRange_=new TileRange(0,0,0,0)}isDrawableTile(e){const t=this.getLayer(),i=e.getState(),r=t.getUseInterimTilesOnError();return i==TileState.LOADED||i==TileState.EMPTY||i==TileState.ERROR&&!r}getTile(e,t,i,r){const o=r.pixelRatio,n=r.viewState.projection,s=this.getLayer();let a=s.getSource().getTile(e,t,i,o,n);return a.getState()==TileState.ERROR&&s.getUseInterimTilesOnError()&&s.getPreload()>0&&(this.newTiles_=!0),this.isDrawableTile(a)||(a=a.getInterimTile()),a}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),r=applyTransform(t.pixelToCoordinateTransform,e.slice()),o=i.getExtent();if(o&&!containsCoordinate(o,r))return null;const n=t.pixelRatio,s=t.viewState.projection,a=t.viewState,l=i.getRenderSource(),d=l.getTileGridForProjection(a.projection),g=l.getTilePixelRatio(t.pixelRatio);for(let e=d.getZForResolution(a.resolution);e>=d.getMinZoom();--e){const t=d.getTileCoordForCoordAndZ(r,e),i=l.getTile(e,t[1],t[2],n,s);if(!(i instanceof ImageTile||i instanceof ReprojTile)||i instanceof ReprojTile&&i.getState()===TileState.EMPTY)return null;if(i.getState()!==TileState.LOADED)continue;const o=d.getOrigin(e),h=toSize(d.getTileSize(e)),c=d.getResolution(e),T=Math.floor(g*((r[0]-o[0])/c-t[1]*h[0])),m=Math.floor(g*((o[1]-r[1])/c-t[2]*h[1])),p=Math.round(g*l.getGutterForProjection(a.projection));return this.getImageData(i.getImage(),T+p,m+p)}return null}loadedTileCallback(e,t,i){return!!this.isDrawableTile(i)&&super.loadedTileCallback(e,t,i)}prepareFrame(e){return!!this.getLayer().getSource()}renderFrame(e,t){const i=e.layerStatesArray[e.layerIndex],r=e.viewState,o=r.projection,n=r.resolution,s=r.center,a=r.rotation,l=e.pixelRatio,d=this.getLayer(),g=d.getSource(),h=g.getRevision(),c=g.getTileGridForProjection(o),T=c.getZForResolution(n,g.zDirection),m=c.getResolution(T);let p=e.extent;const u=e.viewState.resolution,f=g.getTilePixelRatio(l),x=Math.round(getWidth(p)/u*l),R=Math.round(getHeight(p)/u*l),S=i.extent&&fromUserExtent(i.extent,o);S&&(p=getIntersection(p,fromUserExtent(i.extent,o)));const y=m*x/2/f,w=m*R/2/f,C=[s[0]-y,s[1]-w,s[0]+y,s[1]+w],E=c.getTileRangeForExtentAndZ(p,T),j={};j[T]={};const v=this.createLoadedTileFinder(g,o,j),I=this.tmpExtent,P=this.tmpTileRange_;this.newTiles_=!1;const L=a?getRotatedViewport(r.center,u,a,e.size):void 0;for(let t=E.minX;t<=E.maxX;++t)for(let r=E.minY;r<=E.maxY;++r){if(a&&!c.tileCoordIntersectsViewport([T,t,r],L))continue;const o=this.getTile(T,t,r,e);if(this.isDrawableTile(o)){const t=getUid(this);if(o.getState()==TileState.LOADED){j[T][o.tileCoord.toString()]=o;let e=o.inTransition(t);e&&1!==i.opacity&&(o.endTransition(t),e=!1),this.newTiles_||!e&&this.renderedTiles.includes(o)||(this.newTiles_=!0)}if(1===o.getAlpha(t,e.time))continue}const n=c.getTileCoordChildTileRange(o.tileCoord,P,I);let s=!1;n&&(s=v(T+1,n)),s||c.forEachTileCoordParentTileRange(o.tileCoord,v,P,I)}const U=m/n*l/f;composeTransform(this.pixelTransform,e.size[0]/2,e.size[1]/2,1/l,1/l,a,-x/2,-R/2);const b=toTransformString(this.pixelTransform);this.useContainer(t,b,this.getBackground(e));const A=this.context,D=A.canvas;makeInverse(this.inversePixelTransform,this.pixelTransform),composeTransform(this.tempTransform,x/2,R/2,U,U,0,-x/2,-R/2),D.width!=x||D.height!=R?(D.width=x,D.height=R):this.containerReused||A.clearRect(0,0,x,R),S&&this.clipUnrotated(A,e,S),g.getInterpolate()||(A.imageSmoothingEnabled=!1),this.preRender(A,e),this.renderedTiles.length=0;let F,M,z,_=Object.keys(j).map(Number);_.sort(ascending),1!==i.opacity||this.containerReused&&!g.getOpaque(e.viewState.projection)?(F=[],M=[]):_=_.reverse();for(let t=_.length-1;t>=0;--t){const i=_[t],r=g.getTilePixelSize(i,l,o),n=c.getResolution(i)/m,s=r[0]*n*U,a=r[1]*n*U,d=c.getTileCoordForCoordAndZ(getTopLeft(C),i),h=c.getTileCoordExtent(d),p=applyTransform(this.tempTransform,[f*(h[0]-C[0])/m,f*(C[3]-h[3])/m]),u=f*g.getGutterForProjection(o),x=j[i];for(const t in x){const r=x[t],o=r.tileCoord,n=d[1]-o[1],l=Math.round(p[0]-(n-1)*s),h=d[2]-o[2],c=Math.round(p[1]-(h-1)*a),m=Math.round(p[0]-n*s),f=Math.round(p[1]-h*a),R=l-m,S=c-f,y=T===i,w=y&&1!==r.getAlpha(getUid(this),e.time);let C=!1;if(!w)if(F){z=[m,f,m+R,f,m+R,f+S,m,f+S];for(let e=0,t=F.length;e<t;++e)if(T!==i&&i<M[e]){const t=F[e];intersects([m,f,m+R,f+S],[t[0],t[3],t[4],t[7]])&&(C||(A.save(),C=!0),A.beginPath(),A.moveTo(z[0],z[1]),A.lineTo(z[2],z[3]),A.lineTo(z[4],z[5]),A.lineTo(z[6],z[7]),A.moveTo(t[6],t[7]),A.lineTo(t[4],t[5]),A.lineTo(t[2],t[3]),A.lineTo(t[0],t[1]),A.clip())}F.push(z),M.push(i)}else A.clearRect(m,f,R,S);this.drawTileImage(r,e,m,f,R,S,u,y),F&&!w?(C&&A.restore(),this.renderedTiles.unshift(r)):this.renderedTiles.push(r),this.updateUsedTiles(e.usedTiles,g,r)}}return this.renderedRevision=h,this.renderedResolution=m,this.extentChanged=!this.renderedExtent_||!equals(this.renderedExtent_,C),this.renderedExtent_=C,this.renderedPixelRatio=l,this.renderedProjection=o,this.manageTilePyramid(e,g,c,l,o,p,T,d.getPreload()),this.scheduleExpireCache(e,g),this.postRender(A,e),i.extent&&A.restore(),A.imageSmoothingEnabled=!0,b!==D.style.transform&&(D.style.transform=b),this.container}drawTileImage(e,t,i,r,o,n,s,a){const l=this.getTileImage(e);if(!l)return;const d=getUid(this),g=t.layerStatesArray[t.layerIndex],h=g.opacity*(a?e.getAlpha(d,t.time):1),c=h!==this.context.globalAlpha;c&&(this.context.save(),this.context.globalAlpha=h),this.context.drawImage(l,s,s,l.width-2*s,l.height-2*s,i,r,o,n),c&&this.context.restore(),h!==g.opacity?t.animate=!0:a&&e.endTransition(d)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}scheduleExpireCache(e,t){if(t.canExpireCache()){const i=function(e,t,i){const r=getUid(e);r in i.usedTiles&&e.expireCache(i.viewState.projection,i.usedTiles[r])}.bind(null,t);e.postRenderFunctions.push(i)}}updateUsedTiles(e,t,i){const r=getUid(t);r in e||(e[r]={}),e[r][i.getKey()]=!0}manageTilePyramid(e,t,i,r,o,n,s,a,l){const d=getUid(t);d in e.wantedTiles||(e.wantedTiles[d]={});const g=e.wantedTiles[d],h=e.tileQueue,c=i.getMinZoom(),T=e.viewState.rotation,m=T?getRotatedViewport(e.viewState.center,e.viewState.resolution,T,e.size):void 0;let p,u,f,x,R,S,y=0;for(S=c;S<=s;++S)for(u=i.getTileRangeForExtentAndZ(n,S,u),f=i.getResolution(S),x=u.minX;x<=u.maxX;++x)for(R=u.minY;R<=u.maxY;++R)T&&!i.tileCoordIntersectsViewport([S,x,R],m)||(s-S<=a?(++y,p=t.getTile(S,x,R,r,o),p.getState()==TileState.IDLE&&(g[p.getKey()]=!0,h.isKeyQueued(p.getKey())||h.enqueue([p,d,i.getTileCoordCenter(p.tileCoord),f])),void 0!==l&&l(p)):t.useTile(S,x,R,o));t.updateCacheSize(y,o)}}export default CanvasTileLayerRenderer;
//# sourceMappingURL=/sm/5af37a28c2e1590bd200b1a53ff95aa93307d860a736b156909cda26b8a9d473.map