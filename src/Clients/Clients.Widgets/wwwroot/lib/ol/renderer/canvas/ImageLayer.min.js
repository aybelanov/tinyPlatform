/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/renderer/canvas/ImageLayer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasLayerRenderer from"./Layer.js";import ImageState from"../../ImageState.js";import ViewHint from"../../ViewHint.js";import{apply as applyTransform,compose as composeTransform,makeInverse,toString as toTransformString}from"../../transform.js";import{containsCoordinate,containsExtent,getHeight,getIntersection,getWidth,intersects as intersectsExtent,isEmpty}from"../../extent.js";import{fromUserExtent}from"../../proj.js";class CanvasImageLayerRenderer extends CanvasLayerRenderer{constructor(t){super(t),this.image_=null}getImage(){return this.image_?this.image_.getImage():null}prepareFrame(t){const e=t.layerStatesArray[t.layerIndex],r=t.pixelRatio,i=t.viewState,n=i.resolution,a=this.getLayer().getSource(),s=t.viewHints;let o=t.extent;if(void 0!==e.extent&&(o=getIntersection(o,fromUserExtent(e.extent,i.projection))),!s[ViewHint.ANIMATING]&&!s[ViewHint.INTERACTING]&&!isEmpty(o))if(a){const t=i.projection,e=a.getImage(o,n,r,t);e&&(this.loadImage(e)?this.image_=e:e.getState()===ImageState.EMPTY&&(this.image_=null))}else this.image_=null;return!!this.image_}getData(t){const e=this.frameState;if(!e)return null;const r=this.getLayer(),i=applyTransform(e.pixelToCoordinateTransform,t.slice()),n=r.getExtent();if(n&&!containsCoordinate(n,i))return null;const a=this.image_.getExtent(),s=this.image_.getImage(),o=getWidth(a),g=Math.floor(s.width*((i[0]-a[0])/o));if(g<0||g>=s.width)return null;const m=getHeight(a),h=Math.floor(s.height*((a[3]-i[1])/m));return h<0||h>=s.height?null:this.getImageData(s,g,h)}renderFrame(t,e){const r=this.image_,i=r.getExtent(),n=r.getResolution(),[a,s]=Array.isArray(n)?n:[n,n],o=r.getPixelRatio(),g=t.layerStatesArray[t.layerIndex],m=t.pixelRatio,h=t.viewState,l=h.center,c=h.resolution,p=m*a/(c*o),f=m*s/(c*o),d=t.extent,x=h.resolution,u=h.rotation,y=Math.round(getWidth(d)/x*m),I=Math.round(getHeight(d)/x*m);composeTransform(this.pixelTransform,t.size[0]/2,t.size[1]/2,1/m,1/m,u,-y/2,-I/2),makeInverse(this.inversePixelTransform,this.pixelTransform);const T=toTransformString(this.pixelTransform);this.useContainer(e,T,this.getBackground(t));const E=this.context,S=E.canvas;S.width!=y||S.height!=I?(S.width=y,S.height=I):this.containerReused||E.clearRect(0,0,y,I);let w=!1,R=!0;if(g.extent){const e=fromUserExtent(g.extent,h.projection);R=intersectsExtent(e,t.extent),w=R&&!containsExtent(e,t.extent),w&&this.clipUnrotated(E,t,e)}const v=r.getImage(),j=composeTransform(this.tempTransform,y/2,I/2,p,f,0,o*(i[0]-l[0])/a,o*(l[1]-i[3])/s);this.renderedResolution=s*m/o;const A=v.width*j[0],_=v.height*j[3];if(this.getLayer().getSource().getInterpolate()||(E.imageSmoothingEnabled=!1),this.preRender(E,t),R&&A>=.5&&_>=.5){const t=j[4],e=j[5],r=g.opacity;let i;1!==r&&(i=E.globalAlpha,E.globalAlpha=r),E.drawImage(v,0,0,+v.width,+v.height,t,e,A,_),1!==r&&(E.globalAlpha=i)}return this.postRender(E,t),w&&E.restore(),E.imageSmoothingEnabled=!0,T!==S.style.transform&&(S.style.transform=T),this.container}}export default CanvasImageLayerRenderer;
//# sourceMappingURL=/sm/d1fa763e40ed41d86944c15fa338aa37a77fe952064910f4492b326b948a3004.map