/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/render/canvas/Executor.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasInstruction from"./Instruction.js";import{TEXT_ALIGN}from"./TextBuilder.js";import{apply as applyTransform,compose as composeTransform,create as createTransform,setFromArray as transformSetFromArray}from"../../transform.js";import{createEmpty,createOrUpdate,intersects}from"../../extent.js";import{defaultPadding,defaultTextAlign,defaultTextBaseline,drawImageOrLabel,getTextDimensions,measureAndCacheTextWidth}from"../canvas.js";import{drawTextOnPath}from"../../geom/flat/textpath.js";import{equals}from"../../array.js";import{lineStringLength}from"../../geom/flat/length.js";import{transform2D}from"../../geom/flat/transform.js";const tmpExtent=createEmpty(),p1=[],p2=[],p3=[],p4=[];function getDeclutterBox(t){return t[3].declutterBox}const rtlRegEx=new RegExp("["+String.fromCharCode(1425)+"-"+String.fromCharCode(2303)+String.fromCharCode(64285)+"-"+String.fromCharCode(65023)+String.fromCharCode(65136)+"-"+String.fromCharCode(65276)+String.fromCharCode(67584)+"-"+String.fromCharCode(69631)+String.fromCharCode(124928)+"-"+String.fromCharCode(126975)+"]");function horizontalTextAlign(t,e){return"start"===e?e=rtlRegEx.test(t)?"right":"left":"end"===e&&(e=rtlRegEx.test(t)?"left":"right"),TEXT_ALIGN[e]}function createTextChunks(t,e,i){return i>0&&t.push("\n",""),t.push(e,""),t}class Executor{constructor(t,e,i,a){this.overlaps=i,this.pixelRatio=e,this.resolution=t,this.alignFill_,this.instructions=a.instructions,this.coordinates=a.coordinates,this.coordinateCache_={},this.renderedTransform_=createTransform(),this.hitDetectionInstructions=a.hitDetectionInstructions,this.pixelCoordinates_=null,this.viewRotation_=0,this.fillStates=a.fillStates||{},this.strokeStates=a.strokeStates||{},this.textStates=a.textStates||{},this.widths_={},this.labels_={}}createLabel(t,e,i,a){const s=t+e+i+a;if(this.labels_[s])return this.labels_[s];const n=a?this.strokeStates[a]:null,r=i?this.fillStates[i]:null,o=this.textStates[e],l=this.pixelRatio,h=[o.scale[0]*l,o.scale[1]*l],c=Array.isArray(t),p=o.justify?TEXT_ALIGN[o.justify]:horizontalTextAlign(Array.isArray(t)?t[0]:t,o.textAlign||defaultTextAlign),u=a&&n.lineWidth?n.lineWidth:0,m=c?t:t.split("\n").reduce(createTextChunks,[]),{width:d,height:f,widths:g,heights:x,lineWidths:_}=getTextDimensions(o,m),T=d+u,C=[],y=(T+2)*h[0],I=(f+u)*h[1],S={width:y<0?Math.floor(y):Math.ceil(y),height:I<0?Math.floor(I):Math.ceil(I),contextInstructions:C};1==h[0]&&1==h[1]||C.push("scale",h),a&&(C.push("strokeStyle",n.strokeStyle),C.push("lineWidth",u),C.push("lineCap",n.lineCap),C.push("lineJoin",n.lineJoin),C.push("miterLimit",n.miterLimit),C.push("setLineDash",[n.lineDash]),C.push("lineDashOffset",n.lineDashOffset)),i&&C.push("fillStyle",r.fillStyle),C.push("textBaseline","middle"),C.push("textAlign","center");const b=.5-p;let E=p*T+b*u;const w=[],k=[];let v,L=0,A=0,O=0,R=0;for(let t=0,e=m.length;t<e;t+=2){const e=m[t];if("\n"===e){A+=L,L=0,E=p*T+b*u,++R;continue}const s=m[t+1]||o.font;s!==v&&(a&&w.push("font",s),i&&k.push("font",s),v=s),L=Math.max(L,x[O]);const n=[e,E+b*g[O]+p*(g[O]-_[R]),.5*(u+L)+A];E+=g[O],a&&w.push("strokeText",n),i&&k.push("fillText",n),++O}return Array.prototype.push.apply(C,w),Array.prototype.push.apply(C,k),this.labels_[s]=S,S}replayTextBackground_(t,e,i,a,s,n,r){t.beginPath(),t.moveTo.apply(t,e),t.lineTo.apply(t,i),t.lineTo.apply(t,a),t.lineTo.apply(t,s),t.lineTo.apply(t,e),n&&(this.alignFill_=n[2],this.fill_(t)),r&&(this.setStrokeStyle_(t,r),t.stroke())}calculateImageOrLabelDimensions_(t,e,i,a,s,n,r,o,l,h,c,p,u,m,d,f){let g=i-(r*=p[0]),x=a-(o*=p[1]);const _=s+l>t?t-l:s,T=n+h>e?e-h:n,C=m[3]+_*p[0]+m[1],y=m[0]+T*p[1]+m[2],I=g-m[3],S=x-m[0];let b;return(d||0!==c)&&(p1[0]=I,p4[0]=I,p1[1]=S,p2[1]=S,p2[0]=I+C,p3[0]=p2[0],p3[1]=S+y,p4[1]=p3[1]),0!==c?(b=composeTransform(createTransform(),i,a,1,1,c,-i,-a),applyTransform(b,p1),applyTransform(b,p2),applyTransform(b,p3),applyTransform(b,p4),createOrUpdate(Math.min(p1[0],p2[0],p3[0],p4[0]),Math.min(p1[1],p2[1],p3[1],p4[1]),Math.max(p1[0],p2[0],p3[0],p4[0]),Math.max(p1[1],p2[1],p3[1],p4[1]),tmpExtent)):createOrUpdate(Math.min(I,I+C),Math.min(S,S+y),Math.max(I,I+C),Math.max(S,S+y),tmpExtent),u&&(g=Math.round(g),x=Math.round(x)),{drawImageX:g,drawImageY:x,drawImageW:_,drawImageH:T,originX:l,originY:h,declutterBox:{minX:tmpExtent[0],minY:tmpExtent[1],maxX:tmpExtent[2],maxY:tmpExtent[3],value:f},canvasTransform:b,scale:p}}replayImageOrLabel_(t,e,i,a,s,n,r){const o=!(!n&&!r),l=a.declutterBox,h=t.canvas,c=r?r[2]*a.scale[0]/2:0;return l.minX-c<=h.width/e&&l.maxX+c>=0&&l.minY-c<=h.height/e&&l.maxY+c>=0&&(o&&this.replayTextBackground_(t,p1,p2,p3,p4,n,r),drawImageOrLabel(t,a.canvasTransform,s,i,a.originX,a.originY,a.drawImageW,a.drawImageH,a.drawImageX,a.drawImageY,a.scale)),!0}fill_(t){if(this.alignFill_){const e=applyTransform(this.renderedTransform_,[0,0]),i=512*this.pixelRatio;t.save(),t.translate(e[0]%i,e[1]%i),t.rotate(this.viewRotation_)}t.fill(),this.alignFill_&&t.restore()}setStrokeStyle_(t,e){t.strokeStyle=e[1],t.lineWidth=e[2],t.lineCap=e[3],t.lineJoin=e[4],t.miterLimit=e[5],t.lineDashOffset=e[7],t.setLineDash(e[6])}drawLabelWithPointPlacement_(t,e,i,a){const s=this.textStates[e],n=this.createLabel(t,e,a,i),r=this.strokeStates[i],o=this.pixelRatio,l=horizontalTextAlign(Array.isArray(t)?t[0]:t,s.textAlign||defaultTextAlign),h=TEXT_ALIGN[s.textBaseline||defaultTextBaseline],c=r&&r.lineWidth?r.lineWidth:0;return{label:n,anchorX:l*(n.width/o-2*s.scale[0])+2*(.5-l)*c,anchorY:h*n.height/o+2*(.5-h)*c}}execute_(t,e,i,a,s,n,r,o){let l;this.pixelCoordinates_&&equals(i,this.renderedTransform_)?l=this.pixelCoordinates_:(this.pixelCoordinates_||(this.pixelCoordinates_=[]),l=transform2D(this.coordinates,0,this.coordinates.length,2,i,this.pixelCoordinates_),transformSetFromArray(this.renderedTransform_,i));let h=0;const c=a.length;let p,u,m,d,f,g,x,_,T,C,y,I,S=0,b=0,E=0,w=null,k=null;const v=this.coordinateCache_,L=this.viewRotation_,A=Math.round(1e12*Math.atan2(-i[1],i[0]))/1e12,O={context:t,pixelRatio:this.pixelRatio,resolution:this.resolution,rotation:L},R=this.instructions!=a||this.overlaps?0:200;let M,D,B,P;for(;h<c;){const i=a[h];switch(i[0]){case CanvasInstruction.BEGIN_GEOMETRY:M=i[1],P=i[3],M.getGeometry()?void 0===r||intersects(r,P.getExtent())?++h:h=i[2]+1:h=i[2];break;case CanvasInstruction.BEGIN_PATH:b>R&&(this.fill_(t),b=0),E>R&&(t.stroke(),E=0),b||E||(t.beginPath(),d=NaN,f=NaN),++h;break;case CanvasInstruction.CIRCLE:S=i[1];const a=l[S],c=l[S+1],W=l[S+2]-a,X=l[S+3]-c,Y=Math.sqrt(W*W+X*X);t.moveTo(a+Y,c),t.arc(a,c,Y,0,2*Math.PI,!0),++h;break;case CanvasInstruction.CLOSE_PATH:t.closePath(),++h;break;case CanvasInstruction.CUSTOM:S=i[1],p=i[2];const N=i[3],j=i[4],F=6==i.length?i[5]:void 0;O.geometry=N,O.feature=M,h in v||(v[h]=[]);const G=v[h];F?F(l,S,p,2,G):(G[0]=l[S],G[1]=l[S+1],G.length=2),j(G,O),++h;break;case CanvasInstruction.DRAW_IMAGE:S=i[1],p=i[2],_=i[3],u=i[4],m=i[5];let H=i[6];const z=i[7],U=i[8],q=i[9],J=i[10];let K=i[11];const V=i[12];let Q=i[13];const Z=i[14],$=i[15];if(!_&&i.length>=20){T=i[19],C=i[20],y=i[21],I=i[22];const t=this.drawLabelWithPointPlacement_(T,C,y,I);_=t.label,i[3]=_;const e=i[23];u=(t.anchorX-e)*this.pixelRatio,i[4]=u;const a=i[24];m=(t.anchorY-a)*this.pixelRatio,i[5]=m,H=_.height,i[6]=H,Q=_.width,i[13]=Q}let tt,et,it,at;i.length>25&&(tt=i[25]),i.length>17?(et=i[16],it=i[17],at=i[18]):(et=defaultPadding,it=!1,at=!1),J&&A?K+=L:J||A||(K-=L);let st=0;for(;S<p;S+=2){if(tt&&tt[st++]<Q/this.pixelRatio)continue;const i=this.calculateImageOrLabelDimensions_(_.width,_.height,l[S],l[S+1],Q,H,u,m,U,q,K,V,s,et,it||at,M),a=[t,e,_,i,z,it?w:null,at?k:null];if(o){if("none"===Z)continue;if("obstacle"===Z){o.insert(i.declutterBox);continue}{let t,e;if($){const i=p-S;if(!$[i]){$[i]=a;continue}if(t=$[i],delete $[i],e=getDeclutterBox(t),o.collides(e))continue}if(o.collides(i.declutterBox))continue;t&&(o.insert(e),this.replayImageOrLabel_.apply(this,t)),o.insert(i.declutterBox)}}this.replayImageOrLabel_.apply(this,a)}++h;break;case CanvasInstruction.DRAW_CHARS:const nt=i[1],rt=i[2],ot=i[3],lt=i[4];I=i[5];const ht=i[6],ct=i[7],pt=i[8];y=i[9];const ut=i[10];T=i[11],C=i[12];const mt=[i[13],i[13]],dt=this.textStates[C],ft=dt.font,gt=[dt.scale[0]*ct,dt.scale[1]*ct];let xt;ft in this.widths_?xt=this.widths_[ft]:(xt={},this.widths_[ft]=xt);const _t=lineStringLength(l,nt,rt,2),Tt=Math.abs(gt[0])*measureAndCacheTextWidth(ft,T,xt);if(lt||Tt<=_t){const i=(_t-Tt)*horizontalTextAlign(T,this.textStates[C].textAlign),a=drawTextOnPath(l,nt,rt,2,T,i,ht,Math.abs(gt[0]),measureAndCacheTextWidth,ft,xt,A?0:this.viewRotation_);t:if(a){const i=[];let s,n,r,l,h;if(y)for(s=0,n=a.length;s<n;++s){h=a[s],r=h[4],l=this.createLabel(r,C,"",y),u=h[2]+(gt[0]<0?-ut:ut),m=ot*l.height+2*(.5-ot)*ut*gt[1]/gt[0]-pt;const n=this.calculateImageOrLabelDimensions_(l.width,l.height,h[0],h[1],l.width,l.height,u,m,0,0,h[3],mt,!1,defaultPadding,!1,M);if(o&&o.collides(n.declutterBox))break t;i.push([t,e,l,n,1,null,null])}if(I)for(s=0,n=a.length;s<n;++s){h=a[s],r=h[4],l=this.createLabel(r,C,I,""),u=h[2],m=ot*l.height-pt;const n=this.calculateImageOrLabelDimensions_(l.width,l.height,h[0],h[1],l.width,l.height,u,m,0,0,h[3],mt,!1,defaultPadding,!1,M);if(o&&o.collides(n.declutterBox))break t;i.push([t,e,l,n,1,null,null])}o&&o.load(i.map(getDeclutterBox));for(let t=0,e=i.length;t<e;++t)this.replayImageOrLabel_.apply(this,i[t])}}++h;break;case CanvasInstruction.END_GEOMETRY:if(void 0!==n){M=i[1];const t=n(M,P);if(t)return t}++h;break;case CanvasInstruction.FILL:R?b++:this.fill_(t),++h;break;case CanvasInstruction.MOVE_TO_LINE_TO:for(S=i[1],p=i[2],D=l[S],B=l[S+1],g=D+.5|0,x=B+.5|0,g===d&&x===f||(t.moveTo(D,B),d=g,f=x),S+=2;S<p;S+=2)D=l[S],B=l[S+1],g=D+.5|0,x=B+.5|0,S!=p-2&&g===d&&x===f||(t.lineTo(D,B),d=g,f=x);++h;break;case CanvasInstruction.SET_FILL_STYLE:w=i,this.alignFill_=i[2],b&&(this.fill_(t),b=0,E&&(t.stroke(),E=0)),t.fillStyle=i[1],++h;break;case CanvasInstruction.SET_STROKE_STYLE:k=i,E&&(t.stroke(),E=0),this.setStrokeStyle_(t,i),++h;break;case CanvasInstruction.STROKE:R?E++:t.stroke(),++h;break;default:++h}}b&&this.fill_(t),E&&t.stroke()}execute(t,e,i,a,s,n){this.viewRotation_=a,this.execute_(t,e,i,this.instructions,s,void 0,void 0,n)}executeHitDetection(t,e,i,a,s){return this.viewRotation_=i,this.execute_(t,1,e,this.hitDetectionInstructions,!0,a,s)}}export default Executor;
//# sourceMappingURL=/sm/8fc77a7f335d5d03c31c92cc2f6f3292a9821fd960f07a46092daf768bca8d3a.map