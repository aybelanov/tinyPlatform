/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/render/canvas/Builder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasInstruction from"./Instruction.js";import Relationship from"../../extent/Relationship.js";import VectorContext from"../VectorContext.js";import{asColorLike}from"../../colorlike.js";import{buffer,clone,containsCoordinate,coordinateRelationship}from"../../extent.js";import{defaultFillStyle,defaultLineCap,defaultLineDash,defaultLineDashOffset,defaultLineJoin,defaultLineWidth,defaultMiterLimit,defaultStrokeStyle}from"../canvas.js";import{equals,reverseSubArray}from"../../array.js";import{inflateCoordinates,inflateCoordinatesArray,inflateMultiCoordinatesArray}from"../../geom/flat/inflate.js";class CanvasBuilder extends VectorContext{constructor(t,e,i,n){super(),this.tolerance=t,this.maxExtent=e,this.pixelRatio=n,this.maxLineWidth=0,this.resolution=i,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_=null,this.bufferedMaxExtent_=null,this.instructions=[],this.coordinates=[],this.tmpCoordinate_=[],this.hitDetectionInstructions=[],this.state={}}applyPixelRatio(t){const e=this.pixelRatio;return 1==e?t:t.map((function(t){return t*e}))}appendFlatPointCoordinates(t,e){const i=this.getBufferedMaxExtent(),n=this.tmpCoordinate_,s=this.coordinates;let o=s.length;for(let r=0,a=t.length;r<a;r+=e)n[0]=t[r],n[1]=t[r+1],containsCoordinate(i,n)&&(s[o++]=n[0],s[o++]=n[1]);return o}appendFlatLineCoordinates(t,e,i,n,s,o){const r=this.coordinates;let a=r.length;const l=this.getBufferedMaxExtent();o&&(e+=n);let h=t[e],u=t[e+1];const c=this.tmpCoordinate_;let d,f,C,p=!0;for(d=e+n;d<i;d+=n)c[0]=t[d],c[1]=t[d+1],C=coordinateRelationship(l,c),C!==f?(p&&(r[a++]=h,r[a++]=u,p=!1),r[a++]=c[0],r[a++]=c[1]):C===Relationship.INTERSECTING?(r[a++]=c[0],r[a++]=c[1],p=!1):p=!0,h=c[0],u=c[1],f=C;return(s&&p||d===e+n)&&(r[a++]=h,r[a++]=u),a}drawCustomCoordinates_(t,e,i,n,s){for(let o=0,r=i.length;o<r;++o){const r=i[o],a=this.appendFlatLineCoordinates(t,e,r,n,!1,!1);s.push(a),e=r}return e}drawCustom(t,e,i,n){this.beginGeometry(t,e);const s=t.getType(),o=t.getStride(),r=this.coordinates.length;let a,l,h,u,c;switch(s){case"MultiPolygon":a=t.getOrientedFlatCoordinates(),u=[];const e=t.getEndss();c=0;for(let t=0,i=e.length;t<i;++t){const i=[];c=this.drawCustomCoordinates_(a,c,e[t],o,i),u.push(i)}this.instructions.push([CanvasInstruction.CUSTOM,r,u,t,i,inflateMultiCoordinatesArray]),this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM,r,u,t,n||i,inflateMultiCoordinatesArray]);break;case"Polygon":case"MultiLineString":h=[],a="Polygon"==s?t.getOrientedFlatCoordinates():t.getFlatCoordinates(),c=this.drawCustomCoordinates_(a,0,t.getEnds(),o,h),this.instructions.push([CanvasInstruction.CUSTOM,r,h,t,i,inflateCoordinatesArray]),this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM,r,h,t,n||i,inflateCoordinatesArray]);break;case"LineString":case"Circle":a=t.getFlatCoordinates(),l=this.appendFlatLineCoordinates(a,0,a.length,o,!1,!1),this.instructions.push([CanvasInstruction.CUSTOM,r,l,t,i,inflateCoordinates]),this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM,r,l,t,n||i,inflateCoordinates]);break;case"MultiPoint":a=t.getFlatCoordinates(),l=this.appendFlatPointCoordinates(a,o),l>r&&(this.instructions.push([CanvasInstruction.CUSTOM,r,l,t,i,inflateCoordinates]),this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM,r,l,t,n||i,inflateCoordinates]));break;case"Point":a=t.getFlatCoordinates(),this.coordinates.push(a[0],a[1]),l=this.coordinates.length,this.instructions.push([CanvasInstruction.CUSTOM,r,l,t,i]),this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM,r,l,t,n||i])}this.endGeometry(e)}beginGeometry(t,e){this.beginGeometryInstruction1_=[CanvasInstruction.BEGIN_GEOMETRY,e,0,t],this.instructions.push(this.beginGeometryInstruction1_),this.beginGeometryInstruction2_=[CanvasInstruction.BEGIN_GEOMETRY,e,0,t],this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)}finish(){return{instructions:this.instructions,hitDetectionInstructions:this.hitDetectionInstructions,coordinates:this.coordinates}}reverseHitDetectionInstructions(){const t=this.hitDetectionInstructions;let e;t.reverse();const i=t.length;let n,s,o=-1;for(e=0;e<i;++e)n=t[e],s=n[0],s==CanvasInstruction.END_GEOMETRY?o=e:s==CanvasInstruction.BEGIN_GEOMETRY&&(n[2]=e,reverseSubArray(this.hitDetectionInstructions,o,e),o=-1)}setFillStrokeStyle(t,e){const i=this.state;if(t){const e=t.getColor();i.fillStyle=asColorLike(e||defaultFillStyle)}else i.fillStyle=void 0;if(e){const t=e.getColor();i.strokeStyle=asColorLike(t||defaultStrokeStyle);const n=e.getLineCap();i.lineCap=void 0!==n?n:defaultLineCap;const s=e.getLineDash();i.lineDash=s?s.slice():defaultLineDash;const o=e.getLineDashOffset();i.lineDashOffset=o||defaultLineDashOffset;const r=e.getLineJoin();i.lineJoin=void 0!==r?r:defaultLineJoin;const a=e.getWidth();i.lineWidth=void 0!==a?a:defaultLineWidth;const l=e.getMiterLimit();i.miterLimit=void 0!==l?l:defaultMiterLimit,i.lineWidth>this.maxLineWidth&&(this.maxLineWidth=i.lineWidth,this.bufferedMaxExtent_=null)}else i.strokeStyle=void 0,i.lineCap=void 0,i.lineDash=null,i.lineDashOffset=void 0,i.lineJoin=void 0,i.lineWidth=void 0,i.miterLimit=void 0}createFill(t){const e=t.fillStyle,i=[CanvasInstruction.SET_FILL_STYLE,e];return"string"!=typeof e&&i.push(!0),i}applyStroke(t){this.instructions.push(this.createStroke(t))}createStroke(t){return[CanvasInstruction.SET_STROKE_STYLE,t.strokeStyle,t.lineWidth*this.pixelRatio,t.lineCap,t.lineJoin,t.miterLimit,this.applyPixelRatio(t.lineDash),t.lineDashOffset*this.pixelRatio]}updateFillStyle(t,e){const i=t.fillStyle;"string"==typeof i&&t.currentFillStyle==i||(void 0!==i&&this.instructions.push(e.call(this,t)),t.currentFillStyle=i)}updateStrokeStyle(t,e){const i=t.strokeStyle,n=t.lineCap,s=t.lineDash,o=t.lineDashOffset,r=t.lineJoin,a=t.lineWidth,l=t.miterLimit;(t.currentStrokeStyle!=i||t.currentLineCap!=n||s!=t.currentLineDash&&!equals(t.currentLineDash,s)||t.currentLineDashOffset!=o||t.currentLineJoin!=r||t.currentLineWidth!=a||t.currentMiterLimit!=l)&&(void 0!==i&&e.call(this,t),t.currentStrokeStyle=i,t.currentLineCap=n,t.currentLineDash=s,t.currentLineDashOffset=o,t.currentLineJoin=r,t.currentLineWidth=a,t.currentMiterLimit=l)}endGeometry(t){this.beginGeometryInstruction1_[2]=this.instructions.length,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_[2]=this.hitDetectionInstructions.length,this.beginGeometryInstruction2_=null;const e=[CanvasInstruction.END_GEOMETRY,t];this.instructions.push(e),this.hitDetectionInstructions.push(e)}getBufferedMaxExtent(){if(!this.bufferedMaxExtent_&&(this.bufferedMaxExtent_=clone(this.maxExtent),this.maxLineWidth>0)){const t=this.resolution*(this.maxLineWidth+1)/2;buffer(this.bufferedMaxExtent_,t,this.bufferedMaxExtent_)}return this.bufferedMaxExtent_}}export default CanvasBuilder;
//# sourceMappingURL=/sm/9398e630dba00010c7eb665408b82d3d0a6c7b740118bfdd7312fee04e720a3b.map