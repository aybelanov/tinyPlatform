/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/render/canvas/ExecutorGroup.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Executor from"./Executor.js";import{ascending}from"../../array.js";import{buffer,createEmpty,extendCoordinate}from"../../extent.js";import{compose as composeTransform,create as createTransform}from"../../transform.js";import{createCanvasContext2D}from"../../dom.js";import{isEmpty}from"../../obj.js";import{transform2D}from"../../geom/flat/transform.js";const ORDER=["Polygon","Circle","LineString","Image","Text","Default"];class ExecutorGroup{constructor(t,e,r,o,n,s){this.maxExtent_=t,this.overlaps_=o,this.pixelRatio_=r,this.resolution_=e,this.renderBuffer_=s,this.executorsByZIndex_={},this.hitDetectionContext_=null,this.hitDetectionTransform_=createTransform(),this.createExecutors_(n)}clip(t,e){const r=this.getClipCoords(e);t.beginPath(),t.moveTo(r[0],r[1]),t.lineTo(r[2],r[3]),t.lineTo(r[4],r[5]),t.lineTo(r[6],r[7]),t.clip()}createExecutors_(t){for(const e in t){let r=this.executorsByZIndex_[e];void 0===r&&(r={},this.executorsByZIndex_[e]=r);const o=t[e];for(const t in o){const e=o[t];r[t]=new Executor(this.resolution_,this.pixelRatio_,this.overlaps_,e)}}}hasExecutors(t){for(const e in this.executorsByZIndex_){const r=this.executorsByZIndex_[e];for(let e=0,o=t.length;e<o;++e)if(t[e]in r)return!0}return!1}forEachFeatureAtCoordinate(t,e,r,o,n,s){const i=2*(o=Math.round(o))+1,c=composeTransform(this.hitDetectionTransform_,o+.5,o+.5,1/e,-1/e,-r,-t[0],-t[1]),a=!this.hitDetectionContext_;a&&(this.hitDetectionContext_=createCanvasContext2D(i,i,void 0,{willReadFrequently:!0}));const x=this.hitDetectionContext_;let h;x.canvas.width!==i||x.canvas.height!==i?(x.canvas.width=i,x.canvas.height=i):a||x.clearRect(0,0,i,i),void 0!==this.renderBuffer_&&(h=createEmpty(),extendCoordinate(h,t),buffer(h,e*(this.renderBuffer_+o),h));const l=getPixelIndexArray(o);let u;function f(t,e){const r=x.getImageData(0,0,i,i).data;for(let c=0,a=l.length;c<a;c++)if(r[l[c]]>0){if(!s||"Image"!==u&&"Text"!==u||s.includes(t)){const r=(l[c]-3)/4,s=o-r%i,a=o-(r/i|0),x=n(t,e,s*s+a*a);if(x)return x}x.clearRect(0,0,i,i);break}}const m=Object.keys(this.executorsByZIndex_).map(Number);let d,p,_,y,g;for(m.sort(ascending),d=m.length-1;d>=0;--d){const t=m[d].toString();for(_=this.executorsByZIndex_[t],p=ORDER.length-1;p>=0;--p)if(u=ORDER[p],y=_[u],void 0!==y&&(g=y.executeHitDetection(x,c,r,f,h),g))return g}}getClipCoords(t){const e=this.maxExtent_;if(!e)return null;const r=e[0],o=e[1],n=e[2],s=e[3],i=[r,o,r,s,n,s,n,o];return transform2D(i,0,8,2,t,i),i}isEmpty(){return isEmpty(this.executorsByZIndex_)}execute(t,e,r,o,n,s,i){const c=Object.keys(this.executorsByZIndex_).map(Number);let a,x,h,l,u,f;for(c.sort(ascending),this.maxExtent_&&(t.save(),this.clip(t,r)),s=s||ORDER,i&&c.reverse(),a=0,x=c.length;a<x;++a){const x=c[a].toString();for(u=this.executorsByZIndex_[x],h=0,l=s.length;h<l;++h){f=u[s[h]],void 0!==f&&f.execute(t,e,r,o,n,i)}}this.maxExtent_&&t.restore()}}const circlePixelIndexArrayCache={};export function getPixelIndexArray(t){if(void 0!==circlePixelIndexArrayCache[t])return circlePixelIndexArrayCache[t];const e=2*t+1,r=t*t,o=new Array(r+1);for(let n=0;n<=t;++n)for(let s=0;s<=t;++s){const i=n*n+s*s;if(i>r)break;let c=o[i];c||(c=[],o[i]=c),c.push(4*((t+n)*e+(t+s))+3),n>0&&c.push(4*((t-n)*e+(t+s))+3),s>0&&(c.push(4*((t+n)*e+(t-s))+3),n>0&&c.push(4*((t-n)*e+(t-s))+3))}const n=[];for(let t=0,e=o.length;t<e;++t)o[t]&&n.push(...o[t]);return circlePixelIndexArrayCache[t]=n,n}export default ExecutorGroup;
//# sourceMappingURL=/sm/ad0ae5904e424d036b00a0f2646326940db27ac234203dcdd5910acf01ca8338.map