/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/render/webgl/VectorStyleRenderer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import WebGLArrayBuffer from"../../webgl/Buffer.js";import{ARRAY_BUFFER,DYNAMIC_DRAW,ELEMENT_ARRAY_BUFFER}from"../../webgl.js";import{AttributeType}from"../../webgl/Helper.js";import{WebGLWorkerMessageType}from"./constants.js";import{create as createTransform,makeInverse as makeInverseTransform}from"../../transform.js";import{create as createWebGLWorker}from"../../worker/webgl.js";import{generateLineStringRenderInstructions,generatePointRenderInstructions,generatePolygonRenderInstructions,getCustomAttributesSize}from"./renderinstructions.js";import{parseLiteralStyle}from"../../webgl/styleparser.js";const WEBGL_WORKER=createWebGLWorker();let workerMessageCounter=0;export const Attributes={POSITION:"a_position",INDEX:"a_index",SEGMENT_START:"a_segmentStart",SEGMENT_END:"a_segmentEnd",PARAMETERS:"a_parameters",JOIN_ANGLES:"a_joinAngles",DISTANCE:"a_distance"};class VectorStyleRenderer{constructor(e,t){this.helper_=t;let r=e;if(!("fill"in e||"stroke"in e||"symbol"in e&&"vertex"in e.symbol)){const t=parseLiteralStyle(e);r={fill:{vertex:t.builder.getFillVertexShader(),fragment:t.builder.getFillFragmentShader()},stroke:{vertex:t.builder.getStrokeVertexShader(),fragment:t.builder.getStrokeFragmentShader()},symbol:{vertex:t.builder.getSymbolVertexShader(),fragment:t.builder.getSymbolFragmentShader()},attributes:t.attributes,uniforms:t.uniforms}}this.hasFill_=!!r.fill?.vertex,this.hasFill_&&(this.fillVertexShader_=r.fill.vertex,this.fillFragmentShader_=r.fill.fragment,this.fillProgram_=this.helper_.getProgram(this.fillFragmentShader_,this.fillVertexShader_)),this.hasStroke_=!!r.stroke?.vertex,this.hasStroke_&&(this.strokeVertexShader_=r.stroke&&r.stroke.vertex,this.strokeFragmentShader_=r.stroke&&r.stroke.fragment,this.strokeProgram_=this.helper_.getProgram(this.strokeFragmentShader_,this.strokeVertexShader_)),this.hasSymbol_=!!r.symbol?.vertex,this.hasSymbol_&&(this.symbolVertexShader_=r.symbol&&r.symbol.vertex,this.symbolFragmentShader_=r.symbol&&r.symbol.fragment,this.symbolProgram_=this.helper_.getProgram(this.symbolFragmentShader_,this.symbolVertexShader_)),this.customAttributes_=r.attributes,this.uniforms_=r.uniforms;const s=Object.keys(this.customAttributes_).map((e=>({name:`a_${e}`,size:this.customAttributes_[e].size||1,type:AttributeType.FLOAT})));this.polygonAttributesDesc_=[{name:Attributes.POSITION,size:2,type:AttributeType.FLOAT},...s],this.lineStringAttributesDesc_=[{name:Attributes.SEGMENT_START,size:2,type:AttributeType.FLOAT},{name:Attributes.SEGMENT_END,size:2,type:AttributeType.FLOAT},{name:Attributes.JOIN_ANGLES,size:2,type:AttributeType.FLOAT},{name:Attributes.DISTANCE,size:1,type:AttributeType.FLOAT},{name:Attributes.PARAMETERS,size:1,type:AttributeType.FLOAT},...s],this.pointAttributesDesc_=[{name:Attributes.POSITION,size:2,type:AttributeType.FLOAT},{name:Attributes.INDEX,size:1,type:AttributeType.FLOAT},...s],r.uniforms&&this.helper_.addUniforms(r.uniforms)}async generateBuffers(e,t){const r=this.generateRenderInstructions_(e,t),[s,i,n]=await Promise.all([this.generateBuffersForType_(r.polygonInstructions,"Polygon",t),this.generateBuffersForType_(r.lineStringInstructions,"LineString",t),this.generateBuffersForType_(r.pointInstructions,"Point",t)]);return{polygonBuffers:s,lineStringBuffers:i,pointBuffers:n,invertVerticesTransform:makeInverseTransform(createTransform(),t)}}generateRenderInstructions_(e,t){return{polygonInstructions:this.hasFill_?generatePolygonRenderInstructions(e.polygonBatch,new Float32Array(0),this.customAttributes_,t):null,lineStringInstructions:this.hasStroke_?generateLineStringRenderInstructions(e.lineStringBatch,new Float32Array(0),this.customAttributes_,t):null,pointInstructions:this.hasSymbol_?generatePointRenderInstructions(e.pointBatch,new Float32Array(0),this.customAttributes_,t):null}}generateBuffersForType_(e,t,r){if(null===e)return null;const s=workerMessageCounter++;let i;switch(t){case"Polygon":i=WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;break;case"LineString":i=WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;break;case"Point":i=WebGLWorkerMessageType.GENERATE_POINT_BUFFERS}const n={id:s,type:i,renderInstructions:e.buffer,renderInstructionsTransform:r,customAttributesSize:getCustomAttributesSize(this.customAttributes_)};return WEBGL_WORKER.postMessage(n,[e.buffer]),e=null,new Promise((e=>{const t=r=>{const i=r.data;if(i.id!==s)return;if(WEBGL_WORKER.removeEventListener("message",t),!this.helper_.getGL())return;const n=new WebGLArrayBuffer(ARRAY_BUFFER,DYNAMIC_DRAW).fromArrayBuffer(i.vertexBuffer),o=new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER,DYNAMIC_DRAW).fromArrayBuffer(i.indexBuffer);this.helper_.flushBufferData(n),this.helper_.flushBufferData(o),e([o,n])};WEBGL_WORKER.addEventListener("message",t)}))}render(e,t,r){this.hasFill_&&this.renderInternal_(e.polygonBuffers[0],e.polygonBuffers[1],this.fillProgram_,this.polygonAttributesDesc_,t,r),this.hasStroke_&&this.renderInternal_(e.lineStringBuffers[0],e.lineStringBuffers[1],this.strokeProgram_,this.lineStringAttributesDesc_,t,r),this.hasSymbol_&&this.renderInternal_(e.pointBuffers[0],e.pointBuffers[1],this.symbolProgram_,this.pointAttributesDesc_,t,r)}renderInternal_(e,t,r,s,i,n){this.helper_.useProgram(r,i),this.helper_.bindBuffer(t),this.helper_.bindBuffer(e),this.helper_.enableAttributes(s),n();const o=e.getSize();this.helper_.drawElements(0,o)}}export default VectorStyleRenderer;
//# sourceMappingURL=/sm/f87d6a5cb65988a0218e17026e4032b4c4f2f10c21d29f333e1cd880ab0b6bb0.map