/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/format/EsriJSON.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Feature from"../Feature.js";import JSONFeature from"./JSONFeature.js";import LineString from"../geom/LineString.js";import LinearRing from"../geom/LinearRing.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import Polygon from"../geom/Polygon.js";import{containsExtent}from"../extent.js";import{deflateCoordinates}from"../geom/flat/deflate.js";import{get as getProjection}from"../proj.js";import{isEmpty}from"../obj.js";import{linearRingIsClockwise}from"../geom/flat/orient.js";import{transformGeometryWithOptions}from"./Feature.js";const GEOMETRY_READERS={Point:readPointGeometry,LineString:readLineStringGeometry,Polygon:readPolygonGeometry,MultiPoint:readMultiPointGeometry,MultiLineString:readMultiLineStringGeometry,MultiPolygon:readMultiPolygonGeometry},GEOMETRY_WRITERS={Point:writePointGeometry,LineString:writeLineStringGeometry,Polygon:writePolygonGeometry,MultiPoint:writeMultiPointGeometry,MultiLineString:writeMultiLineStringGeometry,MultiPolygon:writeMultiPolygonGeometry};class EsriJSON extends JSONFeature{constructor(t){t=t||{},super(),this.geometryName_=t.geometryName}readFeatureFromObject(t,e,r){const o=t,n=readGeometry(o.geometry,e),i=new Feature;if(this.geometryName_&&i.setGeometryName(this.geometryName_),i.setGeometry(n),o.attributes){i.setProperties(o.attributes,!0);const t=o.attributes[r];void 0!==t&&i.setId(t)}return i}readFeaturesFromObject(t,e){if(e=e||{},t.features){const r=[],o=t.features;for(let n=0,i=o.length;n<i;++n)r.push(this.readFeatureFromObject(o[n],e,t.objectIdFieldName));return r}return[this.readFeatureFromObject(t,e)]}readGeometryFromObject(t,e){return readGeometry(t,e)}readProjectionFromObject(t){if(t.spatialReference&&void 0!==t.spatialReference.wkid){const e=t.spatialReference.wkid;return getProjection("EPSG:"+e)}return null}writeGeometryObject(t,e){return writeGeometry(t,this.adaptOptions(e))}writeFeatureObject(t,e){e=this.adaptOptions(e);const r={};if(!t.hasProperties())return r.attributes={},r;const o=t.getProperties(),n=t.getGeometry();if(n){r.geometry=writeGeometry(n,e);const i=e&&(e.dataProjection||e.featureProjection);i&&(r.geometry.spatialReference={wkid:Number(getProjection(i).getCode().split(":").pop())}),delete o[t.getGeometryName()]}return isEmpty(o)?r.attributes={}:r.attributes=o,r}writeFeaturesObject(t,e){e=this.adaptOptions(e);const r=[];for(let o=0,n=t.length;o<n;++o)r.push(this.writeFeatureObject(t[o],e));return{features:r}}}function readGeometry(t,e){if(!t)return null;let r;if("number"==typeof t.x&&"number"==typeof t.y)r="Point";else if(t.points)r="MultiPoint";else if(t.paths){r=1===t.paths.length?"LineString":"MultiLineString"}else if(t.rings){const e=t,o=getGeometryLayout(e),n=convertRings(e.rings,o);1===n.length?(r="Polygon",t=Object.assign({},t,{rings:n[0]})):(r="MultiPolygon",t=Object.assign({},t,{rings:n}))}return transformGeometryWithOptions((0,GEOMETRY_READERS[r])(t),!1,e)}function convertRings(t,e){const r=[],o=[],n=[];let i,s;for(i=0,s=t.length;i<s;++i){r.length=0,deflateCoordinates(r,0,t[i],e.length);linearRingIsClockwise(r,0,r.length,e.length)?o.push([t[i]]):n.push(t[i])}for(;n.length;){const t=n.shift();let e=!1;for(i=o.length-1;i>=0;i--){const r=o[i][0];if(containsExtent(new LinearRing(r).getExtent(),new LinearRing(t).getExtent())){o[i].push(t),e=!0;break}}e||o.push([t.reverse()])}return o}function readPointGeometry(t){let e;return e=void 0!==t.m&&void 0!==t.z?new Point([t.x,t.y,t.z,t.m],"XYZM"):void 0!==t.z?new Point([t.x,t.y,t.z],"XYZ"):void 0!==t.m?new Point([t.x,t.y,t.m],"XYM"):new Point([t.x,t.y]),e}function readLineStringGeometry(t){const e=getGeometryLayout(t);return new LineString(t.paths[0],e)}function readMultiLineStringGeometry(t){const e=getGeometryLayout(t);return new MultiLineString(t.paths,e)}function getGeometryLayout(t){let e="XY";return!0===t.hasZ&&!0===t.hasM?e="XYZM":!0===t.hasZ?e="XYZ":!0===t.hasM&&(e="XYM"),e}function readMultiPointGeometry(t){const e=getGeometryLayout(t);return new MultiPoint(t.points,e)}function readMultiPolygonGeometry(t){const e=getGeometryLayout(t);return new MultiPolygon(t.rings,e)}function readPolygonGeometry(t){const e=getGeometryLayout(t);return new Polygon(t.rings,e)}function writePointGeometry(t,e){const r=t.getCoordinates();let o;const n=t.getLayout();if("XYZ"===n)o={x:r[0],y:r[1],z:r[2]};else if("XYM"===n)o={x:r[0],y:r[1],m:r[2]};else if("XYZM"===n)o={x:r[0],y:r[1],z:r[2],m:r[3]};else{if("XY"!==n)throw new Error("Invalid geometry layout");o={x:r[0],y:r[1]}}return o}function getHasZM(t){const e=t.getLayout();return{hasZ:"XYZ"===e||"XYZM"===e,hasM:"XYM"===e||"XYZM"===e}}function writeLineStringGeometry(t,e){const r=getHasZM(t);return{hasZ:r.hasZ,hasM:r.hasM,paths:[t.getCoordinates()]}}function writePolygonGeometry(t,e){const r=getHasZM(t);return{hasZ:r.hasZ,hasM:r.hasM,rings:t.getCoordinates(!1)}}function writeMultiLineStringGeometry(t,e){const r=getHasZM(t);return{hasZ:r.hasZ,hasM:r.hasM,paths:t.getCoordinates()}}function writeMultiPointGeometry(t,e){const r=getHasZM(t);return{hasZ:r.hasZ,hasM:r.hasM,points:t.getCoordinates()}}function writeMultiPolygonGeometry(t,e){const r=getHasZM(t),o=t.getCoordinates(!1),n=[];for(let t=0;t<o.length;t++)for(let e=o[t].length-1;e>=0;e--)n.push(o[t][e]);return{hasZ:r.hasZ,hasM:r.hasM,rings:n}}function writeGeometry(t,e){return(0,GEOMETRY_WRITERS[t.getType()])(transformGeometryWithOptions(t,!0,e),e)}export default EsriJSON;
//# sourceMappingURL=/sm/1c0cbd9f5173f11884cffd6a48b7ac1b9838b0454c91b1f34a093e7cfe66dfbf.map