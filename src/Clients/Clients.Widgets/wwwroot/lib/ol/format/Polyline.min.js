/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/format/Polyline.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Feature from"../Feature.js";import LineString from"../geom/LineString.js";import TextFeature from"./TextFeature.js";import{flipXY}from"../geom/flat/flip.js";import{get as getProjection}from"../proj.js";import{getStrideForLayout}from"../geom/SimpleGeometry.js";import{inflateCoordinates}from"../geom/flat/inflate.js";import{transformGeometryWithOptions}from"./Feature.js";class Polyline extends TextFeature{constructor(e){super(),e=e||{},this.dataProjection=getProjection("EPSG:4326"),this.factor_=e.factor?e.factor:1e5,this.geometryLayout_=e.geometryLayout?e.geometryLayout:"XY"}readFeatureFromText(e,t){const r=this.readGeometryFromText(e,t);return new Feature(r)}readFeaturesFromText(e,t){return[this.readFeatureFromText(e,t)]}readGeometryFromText(e,t){const r=getStrideForLayout(this.geometryLayout_),o=decodeDeltas(e,r,this.factor_);flipXY(o,0,o.length,r,o);const n=inflateCoordinates(o,0,o.length,r),i=new LineString(n,this.geometryLayout_);return transformGeometryWithOptions(i,!1,this.adaptOptions(t))}writeFeatureText(e,t){const r=e.getGeometry();if(r)return this.writeGeometryText(r,t);throw new Error("Expected `feature` to have a geometry")}writeFeaturesText(e,t){return this.writeFeatureText(e[0],t)}writeGeometryText(e,t){const r=(e=transformGeometryWithOptions(e,!0,this.adaptOptions(t))).getFlatCoordinates(),o=e.getStride();return flipXY(r,0,r.length,o,r),encodeDeltas(r,o,this.factor_)}}export function encodeDeltas(e,t,r){let o;r=r||1e5;const n=new Array(t);for(o=0;o<t;++o)n[o]=0;for(let r=0,i=e.length;r<i;)for(o=0;o<t;++o,++r){const t=e[r],i=t-n[o];n[o]=t,e[r]=i}return encodeFloats(e,r)}export function decodeDeltas(e,t,r){let o;r=r||1e5;const n=new Array(t);for(o=0;o<t;++o)n[o]=0;const i=decodeFloats(e,r);for(let e=0,r=i.length;e<r;)for(o=0;o<t;++o,++e)n[o]+=i[e],i[e]=n[o];return i}export function encodeFloats(e,t){t=t||1e5;for(let r=0,o=e.length;r<o;++r)e[r]=Math.round(e[r]*t);return encodeSignedIntegers(e)}export function decodeFloats(e,t){t=t||1e5;const r=decodeSignedIntegers(e);for(let e=0,o=r.length;e<o;++e)r[e]/=t;return r}export function encodeSignedIntegers(e){for(let t=0,r=e.length;t<r;++t){const r=e[t];e[t]=r<0?~(r<<1):r<<1}return encodeUnsignedIntegers(e)}export function decodeSignedIntegers(e){const t=decodeUnsignedIntegers(e);for(let e=0,r=t.length;e<r;++e){const r=t[e];t[e]=1&r?~(r>>1):r>>1}return t}export function encodeUnsignedIntegers(e){let t="";for(let r=0,o=e.length;r<o;++r)t+=encodeUnsignedInteger(e[r]);return t}export function decodeUnsignedIntegers(e){const t=[];let r=0,o=0;for(let n=0,i=e.length;n<i;++n){const i=e.charCodeAt(n)-63;r|=(31&i)<<o,i<32?(t.push(r),r=0,o=0):o+=5}return t}export function encodeUnsignedInteger(e){let t,r="";for(;e>=32;)t=63+(32|31&e),r+=String.fromCharCode(t),e>>=5;return t=e+63,r+=String.fromCharCode(t),r}export default Polyline;
//# sourceMappingURL=/sm/82665166a56ba65f78186e09d8603b4a24b7a5240730dbddd9a959ef62b973bd.map