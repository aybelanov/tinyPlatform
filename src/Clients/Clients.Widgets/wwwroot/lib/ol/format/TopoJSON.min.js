/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/format/TopoJSON.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Feature from"../Feature.js";import JSONFeature from"./JSONFeature.js";import LineString from"../geom/LineString.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import Polygon from"../geom/Polygon.js";import{get as getProjection}from"../proj.js";import{transformGeometryWithOptions}from"./Feature.js";class TopoJSON extends JSONFeature{constructor(t){super(),t=t||{},this.layerName_=t.layerName,this.layers_=t.layers?t.layers:null,this.dataProjection=getProjection(t.dataProjection?t.dataProjection:"EPSG:4326")}readFeaturesFromObject(t,e){if("Topology"==t.type){const r=t;let o,n=null,i=null;r.transform&&(o=r.transform,n=o.scale,i=o.translate);const s=r.arcs;o&&transformArcs(s,n,i);const l=[],a=r.objects,c=this.layerName_;let m;for(const t in a)this.layers_&&!this.layers_.includes(t)||("GeometryCollection"===a[t].type?(m=a[t],l.push.apply(l,readFeaturesFromGeometryCollection(m,s,n,i,c,t,e))):(m=a[t],l.push(readFeatureFromGeometry(m,s,n,i,c,t,e))));return l}return[]}readProjectionFromObject(t){return this.dataProjection}}const GEOMETRY_READERS={Point:readPointGeometry,LineString:readLineStringGeometry,Polygon:readPolygonGeometry,MultiPoint:readMultiPointGeometry,MultiLineString:readMultiLineStringGeometry,MultiPolygon:readMultiPolygonGeometry};function concatenateArcs(t,e){const r=[];let o;for(let n=0,i=t.length;n<i;++n)if(o=t[n],n>0&&r.pop(),o>=0){const t=e[o];for(let e=0,o=t.length;e<o;++e)r.push(t[e].slice(0))}else{const t=e[~o];for(let e=t.length-1;e>=0;--e)r.push(t[e].slice(0))}return r}function readPointGeometry(t,e,r){const o=t.coordinates;return e&&r&&transformVertex(o,e,r),new Point(o)}function readMultiPointGeometry(t,e,r){const o=t.coordinates;if(e&&r)for(let t=0,n=o.length;t<n;++t)transformVertex(o[t],e,r);return new MultiPoint(o)}function readLineStringGeometry(t,e){const r=concatenateArcs(t.arcs,e);return new LineString(r)}function readMultiLineStringGeometry(t,e){const r=[];for(let o=0,n=t.arcs.length;o<n;++o)r[o]=concatenateArcs(t.arcs[o],e);return new MultiLineString(r)}function readPolygonGeometry(t,e){const r=[];for(let o=0,n=t.arcs.length;o<n;++o)r[o]=concatenateArcs(t.arcs[o],e);return new Polygon(r)}function readMultiPolygonGeometry(t,e){const r=[];for(let o=0,n=t.arcs.length;o<n;++o){const n=t.arcs[o],i=[];for(let t=0,r=n.length;t<r;++t)i[t]=concatenateArcs(n[t],e);r[o]=i}return new MultiPolygon(r)}function readFeaturesFromGeometryCollection(t,e,r,o,n,i,s){const l=t.geometries,a=[];for(let t=0,c=l.length;t<c;++t)a[t]=readFeatureFromGeometry(l[t],e,r,o,n,i,s);return a}function readFeatureFromGeometry(t,e,r,o,n,i,s){let l=null;const a=t.type;if(a){const n=GEOMETRY_READERS[a];l="Point"===a||"MultiPoint"===a?n(t,r,o):n(t,e),l=transformGeometryWithOptions(l,!1,s)}const c=new Feature({geometry:l});void 0!==t.id&&c.setId(t.id);let m=t.properties;return n&&(m||(m={}),m[n]=i),m&&c.setProperties(m,!0),c}function transformArcs(t,e,r){for(let o=0,n=t.length;o<n;++o)transformArc(t[o],e,r)}function transformArc(t,e,r){let o=0,n=0;for(let i=0,s=t.length;i<s;++i){const s=t[i];o+=s[0],n+=s[1],s[0]=o,s[1]=n,transformVertex(s,e,r)}}function transformVertex(t,e,r){t[0]=t[0]*e[0]+r[0],t[1]=t[1]*e[1]+r[1]}export default TopoJSON;
//# sourceMappingURL=/sm/19319b54742f91be40f34b1d7bcdc918cb3ec7b8fda491e94c9b85b12a64273f.map