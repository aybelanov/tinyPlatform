/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/expr/cpu.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{LiteralExpression,Ops,overlapsType,parse,typeName}from"./expression.js";export function newEvaluationContext(){return{variables:{},properties:{},resolution:NaN}}export function buildExpression(e,r,s){const t=parse(e,s);if(!overlapsType(r,t.type)){const e=typeName(r),s=typeName(t.type);throw new Error(`Expected expression to be of type ${e}, got ${s}`)}return compileExpression(t,s)}function compileExpression(e,r){if(e instanceof LiteralExpression)return function(){return e.value};const s=e.operator;switch(s){case Ops.Number:case Ops.String:return compileAssertionExpression(e,r);case Ops.Get:case Ops.Var:return compileAccessorExpression(e,r);case Ops.Resolution:return e=>e.resolution;case Ops.Any:case Ops.All:case Ops.Not:return compileLogicalExpression(e,r);case Ops.Equal:case Ops.NotEqual:case Ops.LessThan:case Ops.LessThanOrEqualTo:case Ops.GreaterThan:case Ops.GreaterThanOrEqualTo:return compileComparisonExpression(e,r);case Ops.Multiply:case Ops.Divide:case Ops.Add:case Ops.Subtract:case Ops.Clamp:case Ops.Mod:case Ops.Pow:case Ops.Abs:case Ops.Floor:case Ops.Ceil:case Ops.Round:case Ops.Sin:case Ops.Cos:case Ops.Atan:case Ops.Sqrt:return compileNumericExpression(e,r);case Ops.Match:return compileMatchExpression(e,r);default:throw new Error(`Unsupported operator ${s}`)}}function compileAssertionExpression(e,r){const s=e.operator,t=e.args.length,o=new Array(t);for(let s=0;s<t;++s)o[s]=compileExpression(e.args[s],r);switch(s){case Ops.Number:case Ops.String:return e=>{for(let r=0;r<t;++r){const t=o[r](e);if(typeof t===s)return t}throw new Error(`Expected one of the values to be a ${s}`)};default:throw new Error(`Unsupported assertion operator ${s}`)}}function compileAccessorExpression(e,r){const s=e.args[0];if(!(s instanceof LiteralExpression))throw new Error("Expected literal name");const t=s.value;if("string"!=typeof t)throw new Error("Expected string name");switch(e.operator){case Ops.Get:return e=>e.properties[t];case Ops.Var:return e=>e.variables[t];default:throw new Error(`Unsupported accessor operator ${e.operator}`)}}function compileComparisonExpression(e,r){const s=e.operator,t=compileExpression(e.args[0],r),o=compileExpression(e.args[1],r);switch(s){case Ops.Equal:return e=>t(e)===o(e);case Ops.NotEqual:return e=>t(e)!==o(e);case Ops.LessThan:return e=>t(e)<o(e);case Ops.LessThanOrEqualTo:return e=>t(e)<=o(e);case Ops.GreaterThan:return e=>t(e)>o(e);case Ops.GreaterThanOrEqualTo:return e=>t(e)>=o(e);default:throw new Error(`Unsupported comparison operator ${s}`)}}function compileLogicalExpression(e,r){const s=e.operator,t=e.args.length,o=new Array(t);for(let s=0;s<t;++s)o[s]=compileExpression(e.args[s],r);switch(s){case Ops.Any:return e=>{for(let r=0;r<t;++r)if(o[r](e))return!0;return!1};case Ops.All:return e=>{for(let r=0;r<t;++r)if(!o[r](e))return!1;return!0};case Ops.Not:return e=>!o[0](e);default:throw new Error(`Unsupported logical operator ${s}`)}}function compileNumericExpression(e,r){const s=e.operator,t=e.args.length,o=new Array(t);for(let s=0;s<t;++s)o[s]=compileExpression(e.args[s],r);switch(s){case Ops.Multiply:return e=>{let r=1;for(let s=0;s<t;++s)r*=o[s](e);return r};case Ops.Divide:return e=>o[0](e)/o[1](e);case Ops.Add:return e=>{let r=0;for(let s=0;s<t;++s)r+=o[s](e);return r};case Ops.Subtract:return e=>o[0](e)-o[1](e);case Ops.Clamp:return e=>{const r=o[0](e),s=o[1](e);if(r<s)return s;const t=o[2](e);return r>t?t:r};case Ops.Mod:return e=>o[0](e)%o[1](e);case Ops.Pow:return e=>Math.pow(o[0](e),o[1](e));case Ops.Abs:return e=>Math.abs(o[0](e));case Ops.Floor:return e=>Math.floor(o[0](e));case Ops.Ceil:return e=>Math.ceil(o[0](e));case Ops.Round:return e=>Math.round(o[0](e));case Ops.Sin:return e=>Math.sin(o[0](e));case Ops.Cos:return e=>Math.cos(o[0](e));case Ops.Atan:return 2===t?e=>Math.atan2(o[0](e),o[1](e)):e=>Math.atan(o[0](e));case Ops.Sqrt:return e=>Math.sqrt(o[0](e));default:throw new Error(`Unsupported numeric operator ${s}`)}}function compileMatchExpression(e,r){const s=e.args.length,t=new Array(s);for(let o=0;o<s;++o)t[o]=compileExpression(e.args[o],r);return e=>{const r=t[0](e);for(let o=1;o<s;o+=2)if(r===t[o](e))return t[o+1](e);return t[s-1](e)}}
//# sourceMappingURL=/sm/065a95f5da304a4b6a14b0505b18235f6099bf39bb4353144ee48a5f38cafea8.map