/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/expr/expression.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ascending}from"../array.js";let numTypes=0;export const NoneType=0;export const BooleanType=1<<numTypes++;export const NumberType=1<<numTypes++;export const StringType=1<<numTypes++;export const ColorType=1<<numTypes++;export const NumberArrayType=1<<numTypes++;export const AnyType=Math.pow(2,numTypes)-1;const typeNames={[BooleanType]:"boolean",[NumberType]:"number",[StringType]:"string",[ColorType]:"color",[NumberArrayType]:"number[]"},namedTypes=Object.keys(typeNames).map(Number).sort(ascending);export function typeName(e){const r=[];for(const t of namedTypes)includesType(e,t)&&r.push(typeNames[t]);return 0===r.length?"untyped":r.length<3?r.join(" or "):r.slice(0,-1).join(", ")+", or "+r[r.length-1]}export function includesType(e,r){return(e&r)===r}export function overlapsType(e,r){return!!(e&r)}export function isType(e,r){return e===r}export class LiteralExpression{constructor(e,r){this.type=e,this.value=r}}export class CallExpression{constructor(e,r,...t){this.type=e,this.operator=r,this.args=t}}export function newParsingContext(){return{variables:new Set,properties:new Set}}export function parse(e,r){switch(typeof e){case"boolean":return new LiteralExpression(BooleanType,e);case"number":return new LiteralExpression(NumberType,e);case"string":return new LiteralExpression(StringType,e)}if(!Array.isArray(e))throw new Error("Expression must be an array or a primitive value");if(0===e.length)throw new Error("Empty expression");if("string"==typeof e[0])return parseCallExpression(e,r);for(const r of e)if("number"!=typeof r)throw new Error("Expected an array of numbers");let t=NumberArrayType;return 3!==e.length&&4!==e.length||(t|=ColorType),new LiteralExpression(t,e)}export const Ops={Number:"number",String:"string",Get:"get",Var:"var",Any:"any",All:"all",Not:"!",Resolution:"resolution",Equal:"==",NotEqual:"!=",GreaterThan:">",GreaterThanOrEqualTo:">=",LessThan:"<",LessThanOrEqualTo:"<=",Multiply:"*",Divide:"/",Add:"+",Subtract:"-",Clamp:"clamp",Mod:"%",Pow:"^",Abs:"abs",Floor:"floor",Ceil:"ceil",Round:"round",Sin:"sin",Cos:"cos",Atan:"atan",Sqrt:"sqrt",Match:"match"};const parsers={[Ops.Number]:createParser(withArgs(1,1/0,AnyType),NumberType),[Ops.String]:createParser(withArgs(1,1/0,AnyType),StringType),[Ops.Get]:createParser(withGetArgs,AnyType),[Ops.Var]:createParser(withVarArgs,AnyType),[Ops.Resolution]:createParser(withNoArgs,NumberType),[Ops.Any]:createParser(withArgs(2,1/0,BooleanType),BooleanType),[Ops.All]:createParser(withArgs(2,1/0,BooleanType),BooleanType),[Ops.Not]:createParser(withArgs(1,1,BooleanType),BooleanType),[Ops.Equal]:createParser(withArgs(2,2,AnyType),BooleanType),[Ops.NotEqual]:createParser(withArgs(2,2,AnyType),BooleanType),[Ops.GreaterThan]:createParser(withArgs(2,2,AnyType),BooleanType),[Ops.GreaterThanOrEqualTo]:createParser(withArgs(2,2,AnyType),BooleanType),[Ops.LessThan]:createParser(withArgs(2,2,AnyType),BooleanType),[Ops.LessThanOrEqualTo]:createParser(withArgs(2,2,AnyType),BooleanType),[Ops.Multiply]:createParser(withArgs(2,1/0,NumberType),NumberType),[Ops.Divide]:createParser(withArgs(2,2,NumberType),NumberType),[Ops.Add]:createParser(withArgs(2,1/0,NumberType),NumberType),[Ops.Subtract]:createParser(withArgs(2,2,NumberType),NumberType),[Ops.Clamp]:createParser(withArgs(3,3,NumberType),NumberType),[Ops.Mod]:createParser(withArgs(2,2,NumberType),NumberType),[Ops.Pow]:createParser(withArgs(2,2,NumberType),NumberType),[Ops.Abs]:createParser(withArgs(1,1,NumberType),NumberType),[Ops.Floor]:createParser(withArgs(1,1,NumberType),NumberType),[Ops.Ceil]:createParser(withArgs(1,1,NumberType),NumberType),[Ops.Round]:createParser(withArgs(1,1,NumberType),NumberType),[Ops.Sin]:createParser(withArgs(1,1,NumberType),NumberType),[Ops.Cos]:createParser(withArgs(1,1,NumberType),NumberType),[Ops.Atan]:createParser(withArgs(1,2,NumberType),NumberType),[Ops.Sqrt]:createParser(withArgs(1,1,NumberType),NumberType),[Ops.Match]:createParser(withArgs(4,1/0,StringType|NumberType),AnyType)};function withGetArgs(e,r){if(2!==e.length)throw new Error("Expected 1 argument for get operation");const t=parse(e[1],r);if(!(t instanceof LiteralExpression))throw new Error("Expected a literal argument for get operation");if("string"!=typeof t.value)throw new Error("Expected a string argument for get operation");return r.properties.add(t.value),[t]}function withVarArgs(e,r){if(2!==e.length)throw new Error("Expected 1 argument for var operation");const t=parse(e[1],r);if(!(t instanceof LiteralExpression))throw new Error("Expected a literal argument for var operation");if("string"!=typeof t.value)throw new Error("Expected a string argument for get operation");return r.variables.add(t.value),[t]}function withNoArgs(e,r){const t=e[0];if(1!==e.length)throw new Error(`Expected no arguments for ${t} operation`);return[]}function withArgs(e,r,t){return function(n,o){const s=n[0],a=n.length-1;if(e===r){if(a!==e){throw new Error(`Expected ${e} argument${1===e?"":"s"} for operation ${s}, got ${a}`)}}else if(a<e||a>r)throw new Error(`Expected ${e} to ${r} arguments for operation ${s}, got ${a}`);const p=new Array(a);for(let e=0;e<a;++e){const r=parse(n[e+1],o);if(!overlapsType(t,r.type)){const n=typeName(t),o=typeName(r.type);throw new Error(`Unexpected type for argument ${e} of ${s} operation : got ${n} but expected ${o}`)}p[e]=r}return p}}function createParser(e,r){return function(t,n){const o=t[0],s=e(t,n);return new CallExpression(r,o,...s)}}function parseCallExpression(e,r){const t=e[0],n=parsers[t];if(!n)throw new Error(`Unknown operator: ${t}`);return n(e,r)}
//# sourceMappingURL=/sm/eb1c9a7e4c1e8f923a244535ff449a44f8e9ac20c68d91c17fe80c31cf6845d9.map