/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/interaction/Draw.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Circle from"../geom/Circle.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import Feature from"../Feature.js";import GeometryCollection from"../geom/GeometryCollection.js";import InteractionProperty from"./Property.js";import LineString from"../geom/LineString.js";import MapBrowserEvent from"../MapBrowserEvent.js";import MapBrowserEventType from"../MapBrowserEventType.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import PointerInteraction from"./Pointer.js";import Polygon,{fromCircle,makeRegular}from"../geom/Polygon.js";import VectorLayer from"../layer/Vector.js";import VectorSource from"../source/Vector.js";import{FALSE,TRUE}from"../functions.js";import{always,never,noModifierKeys,shiftKeyOnly}from"../events/condition.js";import{boundingExtent,getBottomLeft,getBottomRight,getTopLeft,getTopRight}from"../extent.js";import{clamp,squaredDistance,toFixed}from"../math.js";import{createEditingStyle}from"../style/Style.js";import{distance,squaredDistance as squaredCoordinateDistance}from"../coordinate.js";import{fromUserCoordinate,getUserProjection}from"../proj.js";import{getStrideForLayout}from"../geom/SimpleGeometry.js";const DrawEventType={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};export class DrawEvent extends Event{constructor(t,e){super(t),this.feature=e}}function getTraceTargets(t,e){const i=[];for(let o=0;o<e.length;++o){appendGeometryTraceTargets(t,e[o].getGeometry(),i)}return i}function getSquaredDistance(t,e){return squaredDistance(t[0],t[1],e[0],e[1])}function getCoordinate(t,e){const i=t.length;return e<0?t[e+i]:e>=i?t[e-i]:t[e]}function getCumulativeSquaredDistance(t,e,i){let o,n;e<i?(o=e,n=i):(o=i,n=e);const s=Math.ceil(o),r=Math.floor(n);if(s>r){return getSquaredDistance(interpolateCoordinate(t,o),interpolateCoordinate(t,n))}let a=0;if(o<s){a+=getSquaredDistance(interpolateCoordinate(t,o),getCoordinate(t,s))}if(r<n){a+=getSquaredDistance(getCoordinate(t,r),interpolateCoordinate(t,n))}for(let e=s;e<r-1;++e){a+=getSquaredDistance(getCoordinate(t,e),getCoordinate(t,e+1))}return a}function appendGeometryTraceTargets(t,e,i){if(e instanceof LineString)appendTraceTarget(t,e.getCoordinates(),!1,i);else if(e instanceof MultiLineString){const o=e.getCoordinates();for(let e=0,n=o.length;e<n;++e)appendTraceTarget(t,o[e],!1,i)}else if(e instanceof Polygon){const o=e.getCoordinates();for(let e=0,n=o.length;e<n;++e)appendTraceTarget(t,o[e],!0,i)}else if(e instanceof MultiPolygon){const o=e.getCoordinates();for(let e=0,n=o.length;e<n;++e){const n=o[e];for(let e=0,o=n.length;e<o;++e)appendTraceTarget(t,n[e],!0,i)}}else if(e instanceof GeometryCollection){const o=e.getGeometries();for(let e=0;e<o.length;++e)appendGeometryTraceTargets(t,o[e],i)}else;}const sharedUpdateInfo={index:-1,endIndex:NaN};function getTraceTargetUpdate(t,e,i,o){const n=t[0],s=t[1];let r=1/0,a=-1,h=NaN;for(let t=0;t<e.targets.length;++t){const i=e.targets[t],o=i.coordinates;let d,c=1/0;for(let t=0;t<o.length-1;++t){const e=getPointSegmentRelationship(n,s,o[t],o[t+1]);e.squaredDistance<c&&(c=e.squaredDistance,d=t+e.along)}c<r&&(r=c,i.ring&&e.targetIndex===t&&(i.endIndex>i.startIndex?d<i.startIndex&&(d+=o.length):i.endIndex<i.startIndex&&d>i.startIndex&&(d-=o.length)),h=d,a=t)}const d=e.targets[a];let c=d.ring;if(e.targetIndex===a&&c){const t=interpolateCoordinate(d.coordinates,h),n=i.getPixelFromCoordinate(t);distance(n,e.startPx)>o&&(c=!1)}if(c){const t=d.coordinates,e=t.length,i=d.startIndex,o=h;if(i<o){const n=getCumulativeSquaredDistance(t,i,o);getCumulativeSquaredDistance(t,i,o-e)<n&&(h-=e)}else{const n=getCumulativeSquaredDistance(t,i,o);getCumulativeSquaredDistance(t,i,o+e)<n&&(h+=e)}}return sharedUpdateInfo.index=a,sharedUpdateInfo.endIndex=h,sharedUpdateInfo}function appendTraceTarget(t,e,i,o){const n=t[0],s=t[1];for(let t=0,r=e.length-1;t<r;++t){const r=getPointSegmentRelationship(n,s,e[t],e[t+1]);if(0===r.squaredDistance){const n=t+r.along;return void o.push({coordinates:e,ring:i,startIndex:n,endIndex:n})}}}const sharedRel={along:0,squaredDistance:0};function getPointSegmentRelationship(t,e,i,o){const n=i[0],s=i[1],r=o[0]-n,a=o[1]-s;let h=0,d=n,c=s;return 0===r&&0===a||(h=clamp(((t-n)*r+(e-s)*a)/(r*r+a*a),0,1),d+=r*h,c+=a*h),sharedRel.along=h,sharedRel.squaredDistance=toFixed(squaredDistance(t,e,d,c),10),sharedRel}function interpolateCoordinate(t,e){const i=t.length;let o=Math.floor(e);const n=e-o;o>=i?o-=i:o<0&&(o+=i);let s=o+1;s>=i&&(s-=i);const r=t[o],a=r[0],h=r[1],d=t[s];return[a+(d[0]-a)*n,h+(d[1]-h)*n]}class Draw extends PointerInteraction{constructor(t){const e=t;e.stopDown||(e.stopDown=FALSE),super(e),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=getMode(this.type_),this.stopClick_=!!t.stopClick,this.minPoints_=t.minPoints?t.minPoints:"Polygon"===this.mode_?3:2,this.maxPoints_="Circle"===this.mode_?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:TRUE,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let i=t.geometryFunction;if(!i){const t=this.mode_;if("Circle"===t)i=function(t,e,i){const o=e||new Circle([NaN,NaN]),n=fromUserCoordinate(t[0],i),s=squaredCoordinateDistance(n,fromUserCoordinate(t[t.length-1],i));o.setCenterAndRadius(n,Math.sqrt(s),this.geometryLayout_);const r=getUserProjection();return r&&o.transform(i,r),o};else{let e;"Point"===t?e=Point:"LineString"===t?e=LineString:"Polygon"===t&&(e=Polygon),i=function(i,o,n){return o?"Polygon"===t?i[0].length?o.setCoordinates([i[0].concat([i[0][0]])],this.geometryLayout_):o.setCoordinates([],this.geometryLayout_):o.setCoordinates(i,this.geometryLayout_):o=new e(i,this.geometryLayout_),o}}}this.geometryFunction_=i,this.dragVertexDelay_=void 0!==t.dragVertexDelay?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:!!t.wrapX&&t.wrapX}),style:t.style?t.style:getDefaultStyleFunction(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:noModifierKeys,this.freehandCondition_,t.freehand?this.freehandCondition_=always:this.freehandCondition_=t.freehandCondition?t.freehandCondition:shiftKeyOnly,this.traceCondition_,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(InteractionProperty.ACTIVE,this.updateState_)}setTrace(t){let e;e=t?!0===t?always:t:never,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(t){t.originalEvent.type===EventType.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_="Point"!==this.mode_&&this.freehandCondition_(t);let e=t.type===MapBrowserEventType.POINTERMOVE,i=!0;if(!this.freehand_&&this.lastDragTime_&&t.type===MapBrowserEventType.POINTERDRAG){Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)}return this.freehand_&&t.type===MapBrowserEventType.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(t.coordinate),i=!1):this.freehand_&&t.type===MapBrowserEventType.POINTERDOWN?i=!1:e&&this.getPointerCount()<2?(i=t.type===MapBrowserEventType.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):("mouse"===t.originalEvent.pointerType||t.type===MapBrowserEventType.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(t)):t.type===MapBrowserEventType.DBLCLICK&&(i=!1),super.handleEvent(t)&&i}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout((()=>{this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))}),this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active)return void this.deactivateTrace_();const e=this.getMap(),i=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),o=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),n=boundingExtent([i,o]),s=this.traceSource_.getFeaturesInExtent(n);if(0===s.length)return;const r=getTraceTargets(t.coordinate,s);r.length&&(this.traceState_={active:!0,startPx:t.pixel.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const i=t.startIndex<=t.endIndex;i===t.startIndex<=e?i&&e>t.endIndex||!i&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(i&&e<t.endIndex||!i&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let i=0;if(t<e){const o=Math.ceil(t);let n=Math.floor(e);n===e&&(n-=1),i=n-o+1}else{const o=Math.floor(t);let n=Math.ceil(e);n===e&&(n+=1),i=o-n+1}i>0&&this.removeLastPoints_(i)}addTracedCoordinates_(t,e,i){if(e===i)return;const o=[];if(e<i){const n=Math.ceil(e);let s=Math.floor(i);s===i&&(s-=1);for(let e=n;e<=s;++e)o.push(getCoordinate(t.coordinates,e))}else{const n=Math.floor(e);let s=Math.ceil(i);s===i&&(s+=1);for(let e=n;e>=s;--e)o.push(getCoordinate(t.coordinates,e))}o.length&&this.appendCoordinates(o)}updateTrace_(t){const e=this.traceState_;if(!e.active)return;if(-1===e.targetIndex&&distance(e.startPx,t.pixel)<this.snapTolerance_)return;const i=getTraceTargetUpdate(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==i.index){if(-1!==e.targetIndex){const t=e.targets[e.targetIndex];this.removeTracedCoordinates_(t.startIndex,t.endIndex)}const t=e.targets[i.index];this.addTracedCoordinates_(t,t.startIndex,i.endIndex)}else{const t=e.targets[e.targetIndex];this.addOrRemoveTracedCoordinates_(t,i.endIndex)}e.targetIndex=i.index;const o=e.targets[e.targetIndex];o.endIndex=i.endIndex;const n=interpolateCoordinate(o.coordinates,o.endIndex),s=this.getMap().getPixelFromCoordinate(n);t.coordinate=n,t.pixel=[Math.round(s[0]),Math.round(s[1])]}handleUpEvent(t){let e=!0;if(0===this.getPointerCount()){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const i=this.traceState_.active;if(this.toggleTraceState_(t),this.shouldHandle_){const o=!this.finishCoordinate_;o&&this.startDrawing_(t.coordinate),!o&&this.freehand_?this.finishDrawing():this.freehand_||o&&"Point"!==this.mode_||(this.atFinish_(t.pixel,i)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,i=t.pixel,o=e[0]-i[0],n=e[1]-i[1],s=o*o+n*n;if(this.shouldHandle_=this.freehand_?s>this.squaredClickTolerance_:s<=this.squaredClickTolerance_,!this.shouldHandle_)return}this.finishCoordinate_?(this.updateTrace_(t),this.modifyDrawing_(t.coordinate)):this.createOrUpdateSketchPoint_(t.coordinate.slice())}atFinish_(t,e){let i=!1;if(this.sketchFeature_){let o=!1,n=[this.finishCoordinate_];const s=this.mode_;if("Point"===s)i=!0;else if("Circle"===s)i=2===this.sketchCoords_.length;else if("LineString"===s)o=!e&&this.sketchCoords_.length>this.minPoints_;else if("Polygon"===s){const t=this.sketchCoords_;o=t[0].length>this.minPoints_,n=[t[0][0],t[0][t[0].length-2]],n=e?[t[0][0]]:[t[0][0],t[0][t[0].length-2]]}if(o){const e=this.getMap();for(let o=0,s=n.length;o<s;o++){const s=n[o],r=e.getPixelFromCoordinate(s),a=t[0]-r[0],h=t[1]-r[1],d=this.freehand_?1:this.snapTolerance_;if(i=Math.sqrt(a*a+h*h)<=d,i){this.finishCoordinate_=s;break}}}}return i}createOrUpdateSketchPoint_(t){if(this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(t)}else this.sketchPoint_=new Feature(new Point(t)),this.updateSketchFeatures_()}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new Feature);const e=t.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),i.changed()):(i=new LineString(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(t){const e=this.getMap().getView().getProjection(),i=getStrideForLayout(this.geometryLayout_);for(;t.length<i;)t.push(0);this.finishCoordinate_=t,"Point"===this.mode_?this.sketchCoords_=t.slice():"Polygon"===this.mode_?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new Feature(new LineString(this.sketchLineCoords_)));const o=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new Feature,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(o),this.updateSketchFeatures_(),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),i=this.sketchFeature_.getGeometry(),o=e.getView().getProjection(),n=getStrideForLayout(this.geometryLayout_);let s,r;for(;t.length<n;)t.push(0);if("Point"===this.mode_?r=this.sketchCoords_:"Polygon"===this.mode_?(s=this.sketchCoords_[0],r=s[s.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(s=this.sketchCoords_,r=s[s.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,i,o),this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(t)}if("Polygon"===i.getType()&&"Polygon"!==this.mode_)this.createOrUpdateCustomSketchLine_(i);else if(this.sketchLineCoords_){this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_)}this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let o,n;const s=this.mode_;"LineString"===s||"Circle"===s?(this.finishCoordinate_=t.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():o=!0),n.push(t.slice()),this.geometryFunction_(n,e,i)):"Polygon"===s&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():o=!0),n.push(t.slice()),o&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,e,i)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),o&&this.finishDrawing()}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection(),o=this.mode_;for(let n=0;n<t;++n){let t;if("LineString"===o||"Circle"===o){if(t=this.sketchCoords_,t.splice(-2,1),t.length>=2){this.finishCoordinate_=t[t.length-2].slice();const e=this.finishCoordinate_.slice();t[t.length-1]=e,this.createOrUpdateSketchPoint_(e)}this.geometryFunction_(t,e,i),"Polygon"===e.getType()&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if("Polygon"===o){t=this.sketchCoords_[0],t.splice(-2,1);const o=this.sketchLine_.getGeometry();if(t.length>=2){const e=t[t.length-2].slice();t[t.length-1]=e,this.createOrUpdateSketchPoint_(e)}o.setCoordinates(t),this.geometryFunction_(this.sketchCoords_,e,i)}if(1===t.length){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return;let e=this.sketchCoords_;const i=t.getGeometry(),o=this.getMap().getView().getProjection();"LineString"===this.mode_?(e.pop(),this.geometryFunction_(e,i,o)):"Polygon"===this.mode_&&(e[0].pop(),this.geometryFunction_(e,i,o),e=i.getCoordinates()),"MultiPoint"===this.type_?t.setGeometry(new MultiPoint([e])):"MultiLineString"===this.type_?t.setGeometry(new MultiLineString([e])):"MultiPolygon"===this.type_&&t.setGeometry(new MultiPolygon([e])),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t)}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT,t))}appendCoordinates(t){const e=this.mode_,i=!this.sketchFeature_;let o;if(i&&this.startDrawing_(t[0]),"LineString"===e||"Circle"===e)o=this.sketchCoords_;else{if("Polygon"!==e)return;o=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[]}i&&o.shift(),o.pop();for(let e=0;e<t.length;e++)this.addToDrawing_(t[e]);const n=t[t.length-1];this.addToDrawing_(n),this.modifyDrawing_(n)}extend(t){const e=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=e.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new Feature(new Point(i)),this.updateSketchFeatures_(),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();t&&e||this.abortDrawing(),this.overlay_.setMap(e?t:null)}}function getDefaultStyleFunction(){const t=createEditingStyle();return function(e,i){return t[e.getGeometry().getType()]}}export function createRegularPolygon(t,e){return function(i,o,n){const s=fromUserCoordinate(i[0],n),r=fromUserCoordinate(i[i.length-1],n),a=Math.sqrt(squaredCoordinateDistance(s,r));o=o||fromCircle(new Circle(s),t);let h=e;if(!e&&0!==e){const t=r[0]-s[0],e=r[1]-s[1];h=Math.atan2(e,t)}makeRegular(o,s,a,h);const d=getUserProjection();return d&&o.transform(n,d),o}}export function createBox(){return function(t,e,i){const o=boundingExtent([t[0],t[t.length-1]].map((function(t){return fromUserCoordinate(t,i)}))),n=[[getBottomLeft(o),getBottomRight(o),getTopRight(o),getTopLeft(o),getBottomLeft(o)]];e?e.setCoordinates(n):e=new Polygon(n);const s=getUserProjection();return s&&e.transform(i,s),e}}function getMode(t){switch(t){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+t)}}export default Draw;
//# sourceMappingURL=/sm/178a73f6f7de96a10d5208cd54bed08a68f7a0f54e432fca00e291fc1116ba5b.map