/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/interaction/Snap.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CollectionEventType from"../CollectionEventType.js";import EventType from"../events/EventType.js";import PointerInteraction from"./Pointer.js";import RBush from"../structs/RBush.js";import VectorEventType from"../source/VectorEventType.js";import{FALSE,TRUE}from"../functions.js";import{SnapEvent,SnapEventType}from"../events/SnapEvent.js";import{boundingExtent,buffer,createEmpty}from"../extent.js";import{closestOnCircle,closestOnSegment,squaredDistance}from"../coordinate.js";import{fromCircle}from"../geom/Polygon.js";import{fromUserCoordinate,getUserProjection,toUserCoordinate,toUserExtent}from"../proj.js";import{getUid}from"../util.js";import{listen,unlistenByKey}from"../events.js";function getFeatureFromEvent(e){return e.feature?e.feature:e.element?e.element:null}const tempSegment=[];class Snap extends PointerInteraction{constructor(e){const t=e=e||{};t.handleDownEvent||(t.handleDownEvent=TRUE),t.stopDown||(t.stopDown=FALSE),super(t),this.on,this.once,this.un,this.source_=e.source?e.source:null,this.vertex_=void 0===e.vertex||e.vertex,this.edge_=void 0===e.edge||e.edge,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.rBush_=new RBush,this.GEOMETRY_SEGMENTERS_={Point:this.segmentPointGeometry_.bind(this),LineString:this.segmentLineStringGeometry_.bind(this),LinearRing:this.segmentLineStringGeometry_.bind(this),Polygon:this.segmentPolygonGeometry_.bind(this),MultiPoint:this.segmentMultiPointGeometry_.bind(this),MultiLineString:this.segmentMultiLineStringGeometry_.bind(this),MultiPolygon:this.segmentMultiPolygonGeometry_.bind(this),GeometryCollection:this.segmentGeometryCollectionGeometry_.bind(this),Circle:this.segmentCircleGeometry_.bind(this)}}addFeature(e,t){t=void 0===t||t;const n=getUid(e),s=e.getGeometry();if(s){const t=this.GEOMETRY_SEGMENTERS_[s.getType()];if(t){this.indexedFeaturesExtents_[n]=s.getExtent(createEmpty());const r=[];if(t(r,s),1===r.length)this.rBush_.insert(boundingExtent(r[0]),{feature:e,segment:r[0]});else if(r.length>1){const t=r.map((e=>boundingExtent(e))),n=r.map((t=>({feature:e,segment:t})));this.rBush_.load(t,n)}}}t&&(this.featureChangeListenerKeys_[n]=listen(e,EventType.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel,this.dispatchEvent(new SnapEvent(SnapEventType.SNAP,{vertex:e.coordinate,vertexPixel:e.pixel,feature:t.feature}))),super.handleEvent(e)}handleFeatureAdd_(e){const t=getFeatureFromEvent(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=getFeatureFromEvent(e);t&&this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const e=getUid(t);e in this.pendingFeatures_||(this.pendingFeatures_[e]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(e,t){const n=void 0===t||t,s=getUid(e),r=this.indexedFeaturesExtents_[s];if(r){const t=this.rBush_,n=[];t.forEachInExtent(r,(function(t){e===t.feature&&n.push(t)}));for(let e=n.length-1;e>=0;--e)t.remove(n[e])}n&&(unlistenByKey(this.featureChangeListenerKeys_[s]),delete this.featureChangeListenerKeys_[s])}setMap(e){const t=this.getMap(),n=this.featuresListenerKeys_,s=this.getFeatures_();t&&(n.forEach(unlistenByKey),n.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey),this.featureChangeListenerKeys_={}),super.setMap(e),e&&(this.features_?n.push(listen(this.features_,CollectionEventType.ADD,this.handleFeatureAdd_,this),listen(this.features_,CollectionEventType.REMOVE,this.handleFeatureRemove_,this)):this.source_&&n.push(listen(this.source_,VectorEventType.ADDFEATURE,this.handleFeatureAdd_,this),listen(this.source_,VectorEventType.REMOVEFEATURE,this.handleFeatureRemove_,this)),s.forEach((e=>this.addFeature(e))))}snapTo(e,t,n){const s=n.getView().getProjection(),r=fromUserCoordinate(t,s),o=toUserExtent(buffer(boundingExtent([r]),n.getView().getResolution()*this.pixelTolerance_),s),i=this.rBush_.getInExtent(o),a=i.length;if(0===a)return null;let h,l,u=1/0;const c=this.pixelTolerance_*this.pixelTolerance_,g=()=>{if(h){const t=n.getPixelFromCoordinate(h);if(squaredDistance(e,t)<=c)return{vertex:h,vertexPixel:[Math.round(t[0]),Math.round(t[1])],feature:l}}return null};if(this.vertex_){for(let e=0;e<a;++e){const t=i[e];"Circle"!==t.feature.getGeometry().getType()&&t.segment.forEach((e=>{const n=fromUserCoordinate(e,s),o=squaredDistance(r,n);o<u&&(h=e,u=o,l=t.feature)}))}const e=g();if(e)return e}if(this.edge_){for(let e=0;e<a;++e){let t=null;const n=i[e];if("Circle"===n.feature.getGeometry().getType()){let e=n.feature.getGeometry();const o=getUserProjection();o&&(e=e.clone().transform(o,s)),t=closestOnCircle(r,e)}else{const[e,o]=n.segment;o&&(tempSegment[0]=fromUserCoordinate(e,s),tempSegment[1]=fromUserCoordinate(o,s),t=closestOnSegment(r,tempSegment))}if(t){const e=squaredDistance(r,t);e<u&&(h=toUserCoordinate(t,s),u=e)}}const e=g();if(e)return e}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}segmentCircleGeometry_(e,t){const n=this.getMap().getView().getProjection();let s=t;const r=getUserProjection();r&&(s=s.clone().transform(r,n));const o=fromCircle(s);r&&o.transform(n,r);const i=o.getCoordinates()[0];for(let t=0,n=i.length-1;t<n;++t)e.push(i.slice(t,t+2))}segmentGeometryCollectionGeometry_(e,t){const n=t.getGeometriesArray();for(let t=0;t<n.length;++t){const s=this.GEOMETRY_SEGMENTERS_[n[t].getType()];s&&s(e,n[t])}}segmentLineStringGeometry_(e,t){const n=t.getCoordinates();for(let t=0,s=n.length-1;t<s;++t)e.push(n.slice(t,t+2))}segmentMultiLineStringGeometry_(e,t){const n=t.getCoordinates();for(let t=0,s=n.length;t<s;++t){const s=n[t];for(let t=0,n=s.length-1;t<n;++t)e.push(s.slice(t,t+2))}}segmentMultiPointGeometry_(e,t){t.getCoordinates().forEach((t=>{e.push([t])}))}segmentMultiPolygonGeometry_(e,t){const n=t.getCoordinates();for(let t=0,s=n.length;t<s;++t){const s=n[t];for(let t=0,n=s.length;t<n;++t){const n=s[t];for(let t=0,s=n.length-1;t<s;++t)e.push(n.slice(t,t+2))}}}segmentPointGeometry_(e,t){e.push([t.getCoordinates()])}segmentPolygonGeometry_(e,t){const n=t.getCoordinates();for(let t=0,s=n.length;t<s;++t){const s=n[t];for(let t=0,n=s.length-1;t<n;++t)e.push(s.slice(t,t+2))}}}export default Snap;
//# sourceMappingURL=/sm/1cfe76239df981de6fc034f7e7b96d95fbd4deafcd1c5e91a329168d0e35f303.map