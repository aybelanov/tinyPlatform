/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/interaction/Extent.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Event from"../events/Event.js";import Feature from"../Feature.js";import MapBrowserEventType from"../MapBrowserEventType.js";import Point from"../geom/Point.js";import PointerInteraction from"./Pointer.js";import VectorLayer from"../layer/Vector.js";import VectorSource from"../source/Vector.js";import{always}from"../events/condition.js";import{boundingExtent,getArea}from"../extent.js";import{closestOnSegment,distance as coordinateDistance,squaredDistance as squaredCoordinateDistance,squaredDistanceToSegment}from"../coordinate.js";import{createEditingStyle}from"../style/Style.js";import{fromExtent as polygonFromExtent}from"../geom/Polygon.js";import{toUserExtent}from"../proj.js";const ExtentEventType={EXTENTCHANGED:"extentchanged"};export class ExtentEvent extends Event{constructor(e){super(ExtentEventType.EXTENTCHANGED),this.extent=e}}class Extent extends PointerInteraction{constructor(e){super(e=e||{}),this.on,this.once,this.un,this.condition_=e.condition?e.condition:always,this.extent_=null,this.pointerHandler_=null,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.extentFeature_=null,this.vertexFeature_=null,e||(e={}),this.extentOverlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.boxStyle?e.boxStyle:getDefaultExtentStyleFunction(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.vertexOverlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.pointerStyle?e.pointerStyle:getDefaultPointerStyleFunction(),updateWhileAnimating:!0,updateWhileInteracting:!0}),e.extent&&this.setExtent(e.extent)}snapToVertex_(e,t){const n=t.getCoordinateFromPixelInternal(e),r=function(e,t){return squaredDistanceToSegment(n,e)-squaredDistanceToSegment(n,t)},o=this.getExtentInternal();if(o){const i=getSegments(o);i.sort(r);const a=i[0];let s=closestOnSegment(n,a);const l=t.getPixelFromCoordinateInternal(s);if(coordinateDistance(e,l)<=this.pixelTolerance_){const e=t.getPixelFromCoordinateInternal(a[0]),n=t.getPixelFromCoordinateInternal(a[1]),r=squaredCoordinateDistance(l,e),o=squaredCoordinateDistance(l,n),i=Math.sqrt(Math.min(r,o));return this.snappedToVertex_=i<=this.pixelTolerance_,this.snappedToVertex_&&(s=r>o?a[1]:a[0]),s}}return null}handlePointerMove_(e){const t=e.pixel,n=e.map;let r=this.snapToVertex_(t,n);r||(r=n.getCoordinateFromPixelInternal(t)),this.createOrUpdatePointerFeature_(r)}createOrUpdateExtentFeature_(e){let t=this.extentFeature_;return t?e?t.setGeometry(polygonFromExtent(e)):t.setGeometry(void 0):(t=new Feature(e?polygonFromExtent(e):{}),this.extentFeature_=t,this.extentOverlay_.getSource().addFeature(t)),t}createOrUpdatePointerFeature_(e){let t=this.vertexFeature_;if(t){t.getGeometry().setCoordinates(e)}else t=new Feature(new Point(e)),this.vertexFeature_=t,this.vertexOverlay_.getSource().addFeature(t);return t}handleEvent(e){return!e.originalEvent||!this.condition_(e)||(e.type!=MapBrowserEventType.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),super.handleEvent(e),!1)}handleDownEvent(e){const t=e.pixel,n=e.map,r=this.getExtentInternal();let o=this.snapToVertex_(t,n);const i=function(e){let t=null,n=null;return e[0]==r[0]?t=r[2]:e[0]==r[2]&&(t=r[0]),e[1]==r[1]?n=r[3]:e[1]==r[3]&&(n=r[1]),null!==t&&null!==n?[t,n]:null};if(o&&r){const e=o[0]==r[0]||o[0]==r[2]?o[0]:null,t=o[1]==r[1]||o[1]==r[3]?o[1]:null;null!==e&&null!==t?this.pointerHandler_=getPointHandler(i(o)):null!==e?this.pointerHandler_=getEdgeHandler(i([e,r[1]]),i([e,r[3]])):null!==t&&(this.pointerHandler_=getEdgeHandler(i([r[0],t]),i([r[2],t])))}else o=n.getCoordinateFromPixelInternal(t),this.setExtent([o[0],o[1],o[0],o[1]]),this.pointerHandler_=getPointHandler(o);return!0}handleDragEvent(e){if(this.pointerHandler_){const t=e.coordinate;this.setExtent(this.pointerHandler_(t)),this.createOrUpdatePointerFeature_(t)}}handleUpEvent(e){this.pointerHandler_=null;const t=this.getExtentInternal();return t&&0!==getArea(t)||this.setExtent(null),!1}setMap(e){this.extentOverlay_.setMap(e),this.vertexOverlay_.setMap(e),super.setMap(e)}getExtent(){return toUserExtent(this.getExtentInternal(),this.getMap().getView().getProjection())}getExtentInternal(){return this.extent_}setExtent(e){this.extent_=e||null,this.createOrUpdateExtentFeature_(e),this.dispatchEvent(new ExtentEvent(this.extent_))}}function getDefaultExtentStyleFunction(){const e=createEditingStyle();return function(t,n){return e.Polygon}}function getDefaultPointerStyleFunction(){const e=createEditingStyle();return function(t,n){return e.Point}}function getPointHandler(e){return function(t){return boundingExtent([e,t])}}function getEdgeHandler(e,t){return e[0]==t[0]?function(n){return boundingExtent([e,[n[0],t[1]]])}:e[1]==t[1]?function(n){return boundingExtent([e,[t[0],n[1]]])}:null}function getSegments(e){return[[[e[0],e[1]],[e[0],e[3]]],[[e[0],e[3]],[e[2],e[3]]],[[e[2],e[3]],[e[2],e[1]]],[[e[2],e[1]],[e[0],e[1]]]]}export default Extent;
//# sourceMappingURL=/sm/4c7c9d3ba3081f4d6317aec27b4a3a6dcd203c7b6cf3da4626536e887812286d.map