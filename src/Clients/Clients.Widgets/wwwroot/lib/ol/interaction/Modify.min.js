/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/ol@8.1.0/interaction/Modify.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Collection from"../Collection.js";import CollectionEventType from"../CollectionEventType.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import Feature from"../Feature.js";import MapBrowserEventType from"../MapBrowserEventType.js";import Point from"../geom/Point.js";import PointerInteraction from"./Pointer.js";import RBush from"../structs/RBush.js";import VectorEventType from"../source/VectorEventType.js";import VectorLayer from"../layer/Vector.js";import VectorSource from"../source/Vector.js";import{altKeyOnly,always,primaryAction,singleClick}from"../events/condition.js";import{boundingExtent,buffer as bufferExtent,createOrUpdateFromCoordinate as createExtent}from"../extent.js";import{closestOnSegment,distance as coordinateDistance,equals as coordinatesEqual,squaredDistance as squaredCoordinateDistance,squaredDistanceToSegment}from"../coordinate.js";import{createEditingStyle}from"../style/Style.js";import{equals}from"../array.js";import{fromCircle}from"../geom/Polygon.js";import{fromUserCoordinate,fromUserExtent,getUserProjection,toUserCoordinate,toUserExtent}from"../proj.js";import{getUid}from"../util.js";const CIRCLE_CENTER_INDEX=0,CIRCLE_CIRCUMFERENCE_INDEX=1,tempExtent=[0,0,0,0],tempSegment=[],ModifyEventType={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};export class ModifyEvent extends Event{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}}class Modify extends PointerInteraction{constructor(e){let t;if(super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:primaryAction,this.defaultDeleteCondition_=function(e){return altKeyOnly(e)&&singleClick(e)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:always,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new RBush,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:getDefaultStyleFunction(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null,e.features?t=e.features:e.source&&(this.source_=e.source,t=new Collection(this.source_.getFeatures()),this.source_.addEventListener(VectorEventType.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(VectorEventType.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(CollectionEventType.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(CollectionEventType.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=void 0===e.snapToPointer?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),e.addEventListener(EventType.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new Collection;const i=this.featuresBeingModified_.getArray();for(let e=0,n=t.length;e<n;++e){const n=t[e];for(let e=0,t=n.length;e<t;++e){const t=n[e].feature;t&&!i.includes(t)&&this.featuresBeingModified_.push(t)}}0===this.featuresBeingModified_.getLength()?this.featuresBeingModified_=null:this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(EventType.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,i=[];t.forEach((function(t){e===t.feature&&i.push(t)}));for(let e=i.length-1;e>=0;--e){const n=i[e];for(let e=this.dragSegments_.length-1;e>=0;--e)this.dragSegments_[e][0]===n&&this.dragSegments_.splice(e,1);t.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const i=t.getCoordinates(),n={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),n)}writeMultiPointGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n],o={feature:e,geometry:t,depth:[n],index:n,segment:[r,r]};this.rBush_.insert(t.getExtent(),o)}}writeLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length-1;n<r;++n){const r=i.slice(n,n+2),o={feature:e,geometry:t,index:n,segment:r};this.rBush_.insert(boundingExtent(r),o)}}writeMultiLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n];for(let i=0,o=r.length-1;i<o;++i){const o=r.slice(i,i+2),s={feature:e,geometry:t,depth:[n],index:i,segment:o};this.rBush_.insert(boundingExtent(o),s)}}}writePolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n];for(let i=0,o=r.length-1;i<o;++i){const o=r.slice(i,i+2),s={feature:e,geometry:t,depth:[n],index:i,segment:o};this.rBush_.insert(boundingExtent(o),s)}}}writeMultiPolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){const r=i[n];for(let i=0,o=r.length;i<o;++i){const o=r[i];for(let r=0,s=o.length-1;r<s;++r){const s=o.slice(r,r+2),a={feature:e,geometry:t,depth:[i,n],index:r,segment:s};this.rBush_.insert(boundingExtent(s),a)}}}}writeCircleGeometry_(e,t){const i=t.getCenter(),n={feature:e,geometry:t,index:0,segment:[i,i]},r={feature:e,geometry:t,index:1,segment:[i,i]},o=[n,r];n.featureSegments=o,r.featureSegments=o,this.rBush_.insert(createExtent(i),n);let s=t;const a=getUserProjection();if(a&&this.getMap()){const e=this.getMap().getView().getProjection();s=s.clone().transform(a,e),s=fromCircle(s).transform(e,a)}this.rBush_.insert(s.getExtent(),r)}writeGeometryCollectionGeometry_(e,t){const i=t.getGeometriesArray();for(let t=0;t<i.length;++t){const n=i[t];(0,this.SEGMENT_WRITERS_[n.getType()])(e,n)}}createOrUpdateVertexFeature_(e,t,i){let n=this.vertexFeature_;if(n){n.getGeometry().setCoordinates(e)}else n=new Feature(new Point(e)),this.vertexFeature_=n,this.overlay_.getSource().addFeature(n);return n.set("features",t),n.set("geometries",i),n}handleEvent(e){if(!e.originalEvent)return!0;let t;return this.lastPointerEvent_=e,e.map.getView().getInteracting()||e.type!=MapBrowserEventType.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(t=!(e.type!=MapBrowserEventType.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==MapBrowserEventType.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_);const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],i=[],n=[];for(let r=0,o=this.dragSegments_.length;r<o;++r){const o=this.dragSegments_[r],s=o[0],a=s.feature;i.includes(a)||i.push(a);const h=s.geometry;n.includes(h)||n.push(h);const d=s.depth;let g;const l=s.segment,u=o[1];for(;t.length<h.getStride();)t.push(l[u][t.length]);switch(h.getType()){case"Point":g=t,l[0]=t,l[1]=t;break;case"MultiPoint":g=h.getCoordinates(),g[s.index]=t,l[0]=t,l[1]=t;break;case"LineString":g=h.getCoordinates(),g[s.index+u]=t,l[u]=t;break;case"MultiLineString":case"Polygon":g=h.getCoordinates(),g[d[0]][s.index+u]=t,l[u]=t;break;case"MultiPolygon":g=h.getCoordinates(),g[d[1]][d[0]][s.index+u]=t,l[u]=t;break;case"Circle":if(l[0]=t,l[1]=t,0===s.index)this.changingFeature_=!0,h.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0;const i=e.map.getView().getProjection();let n=coordinateDistance(fromUserCoordinate(h.getCenter(),i),fromUserCoordinate(t,i));const r=getUserProjection();if(r){const e=h.clone().transform(r,i);e.setRadius(n),n=e.transform(i,r).getRadius()}h.setRadius(n),this.changingFeature_=!1}}g&&this.setGeometryCoordinates_(h,g)}this.createOrUpdateVertexFeature_(t,i,n)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate;this.handlePointerAtPixel_(e.pixel,e.map,t),this.dragSegments_.length=0,this.featuresBeingModified_=null;const i=this.vertexFeature_;if(i){const n=e.map.getView().getProjection(),r=[],o=i.getGeometry().getCoordinates(),s=boundingExtent([o]),a=this.rBush_.getInExtent(s),h={};a.sort(compareIndexes);for(let i=0,s=a.length;i<s;++i){const s=a[i],d=s.segment;let g=getUid(s.geometry);const l=s.depth;if(l&&(g+="-"+l.join("-")),h[g]||(h[g]=new Array(2)),"Circle"!==s.geometry.getType()||1!==s.index)if(!coordinatesEqual(d[0],o)||h[g][0])if(!coordinatesEqual(d[1],o)||h[g][1])getUid(d)in this.vertexSegments_&&!h[g][0]&&!h[g][1]&&this.insertVertexCondition_(e)&&r.push(s);else{if(h[g][0]&&0===h[g][0].index){let e=s.geometry.getCoordinates();switch(s.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":e=e[l[1]];case"Polygon":if(s.index!==e[l[0]].length-2)continue}}this.dragSegments_.push([s,1]),h[g][1]=s}else this.dragSegments_.push([s,0]),h[g][0]=s;else{const e=closestOnSegmentData(t,s,n);coordinatesEqual(e,o)&&!h[g][0]&&(this.dragSegments_.push([s,0]),h[g][0]=s)}}r.length&&this.willModifyFeatures_(e,[r]);for(let e=r.length-1;e>=0;--e)this.insertVertex_(r[e],o)}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const i=this.dragSegments_[t][0],n=i.geometry;if("Circle"===n.getType()){const t=n.getCenter(),r=i.featureSegments[0],o=i.featureSegments[1];r.segment[0]=t,r.segment[1]=t,o.segment[0]=t,o.segment[1]=t,this.rBush_.update(createExtent(t),r);let s=n;const a=getUserProjection();if(a){const t=e.map.getView().getProjection();s=s.clone().transform(a,t),s=fromCircle(s).transform(t,a)}this.rBush_.update(s.getExtent(),o)}else this.rBush_.update(boundingExtent(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map,e.coordinate)}handlePointerAtPixel_(e,t,i){const n=i||t.getCoordinateFromPixel(e),r=t.getView().getProjection(),o=function(e,t){return projectedDistanceToSegmentDataSquared(n,e,r)-projectedDistanceToSegmentDataSquared(n,t,r)};let s,a;if(this.hitDetection_){const i="object"==typeof this.hitDetection_?e=>e===this.hitDetection_:void 0;t.forEachFeatureAtPixel(e,((e,t,i)=>{i&&(i=new Point(toUserCoordinate(i.getCoordinates(),r)));const n=i||e.getGeometry();if("Point"===n.getType()&&e instanceof Feature&&this.features_.getArray().includes(e)){a=n;const t=e.getGeometry().getFlatCoordinates().slice(0,2);s=[{feature:e,geometry:a,segment:[t,t]}]}return!0}),{layerFilter:i})}if(!s){const e=fromUserExtent(createExtent(n,tempExtent),r),i=t.getView().getResolution()*this.pixelTolerance_,o=toUserExtent(bufferExtent(e,i,tempExtent),r);s=this.rBush_.getInExtent(o)}if(s&&s.length>0){const i=s.sort(o)[0],h=i.segment;let d=closestOnSegmentData(n,i,r);const g=t.getPixelFromCoordinate(d);let l=coordinateDistance(e,g);if(a||l<=this.pixelTolerance_){const e={};if(e[getUid(h)]=!0,this.snapToPointer_||(this.delta_[0]=d[0]-n[0],this.delta_[1]=d[1]-n[1]),"Circle"===i.geometry.getType()&&1===i.index)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(d,[i.feature],[i.geometry]);else{const n=t.getPixelFromCoordinate(h[0]),r=t.getPixelFromCoordinate(h[1]),o=squaredCoordinateDistance(g,n),a=squaredCoordinateDistance(g,r);l=Math.sqrt(Math.min(o,a)),this.snappedToVertex_=l<=this.pixelTolerance_,this.snappedToVertex_&&(d=o>a?h[1]:h[0]),this.createOrUpdateVertexFeature_(d,[i.feature],[i.geometry]);const u={};u[getUid(i.geometry)]=!0;for(let t=1,i=s.length;t<i;++t){const i=s[t].segment;if(!(coordinatesEqual(h[0],i[0])&&coordinatesEqual(h[1],i[1])||coordinatesEqual(h[0],i[1])&&coordinatesEqual(h[1],i[0])))break;{const n=getUid(s[t].geometry);n in u||(u[n]=!0,e[getUid(i)]=!0)}}}return void(this.vertexSegments_=e)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const i=e.segment,n=e.feature,r=e.geometry,o=e.depth,s=e.index;let a;for(;t.length<r.getStride();)t.push(0);switch(r.getType()){case"MultiLineString":case"Polygon":a=r.getCoordinates(),a[o[0]].splice(s+1,0,t);break;case"MultiPolygon":a=r.getCoordinates(),a[o[1]][o[0]].splice(s+1,0,t);break;case"LineString":a=r.getCoordinates(),a.splice(s+1,0,t);break;default:return}this.setGeometryCoordinates_(r,a);const h=this.rBush_;h.remove(e),this.updateSegmentIndices_(r,s,o,1);const d={segment:[i[0],t],feature:n,geometry:r,depth:o,index:s};h.insert(boundingExtent(d.segment),d),this.dragSegments_.push([d,1]);const g={segment:[t,i[1]],feature:n,geometry:r,depth:o,index:s+1};h.insert(boundingExtent(g.segment),g),this.dragSegments_.push([g,0]),this.ignoreNextSingleClick_=!0}removePoint(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=MapBrowserEventType.POINTERDRAG){const e=this.lastPointerEvent_;this.willModifyFeatures_(e,this.dragSegments_);const t=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null,t}return!1}removeVertex_(){const e=this.dragSegments_,t={};let i,n,r,o,s,a,h,d,g,l,u,c=!1;for(s=e.length-1;s>=0;--s)r=e[s],l=r[0],u=getUid(l.feature),l.depth&&(u+="-"+l.depth.join("-")),u in t||(t[u]={}),0===r[1]?(t[u].right=l,t[u].index=l.index):1==r[1]&&(t[u].left=l,t[u].index=l.index+1);for(u in t){switch(g=t[u].right,h=t[u].left,a=t[u].index,d=a-1,l=void 0!==h?h:g,d<0&&(d=0),o=l.geometry,n=o.getCoordinates(),i=n,c=!1,o.getType()){case"MultiLineString":n[l.depth[0]].length>2&&(n[l.depth[0]].splice(a,1),c=!0);break;case"LineString":n.length>2&&(n.splice(a,1),c=!0);break;case"MultiPolygon":i=i[l.depth[1]];case"Polygon":i=i[l.depth[0]],i.length>4&&(a==i.length-1&&(a=0),i.splice(a,1),c=!0,0===a&&(i.pop(),i.push(i[0]),d=i.length-1))}if(c){this.setGeometryCoordinates_(o,n);const t=[];if(void 0!==h&&(this.rBush_.remove(h),t.push(h.segment[0])),void 0!==g&&(this.rBush_.remove(g),t.push(g.segment[1])),void 0!==h&&void 0!==g){const e={depth:l.depth,feature:l.feature,geometry:l.geometry,index:d,segment:t};this.rBush_.insert(boundingExtent(e.segment),e)}this.updateSegmentIndices_(o,a,l.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return c}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,i,n){this.rBush_.forEachInExtent(e.getExtent(),(function(r){r.geometry===e&&(void 0===i||void 0===r.depth||equals(r.depth,i))&&r.index>t&&(r.index+=n)}))}}function compareIndexes(e,t){return e.index-t.index}function projectedDistanceToSegmentDataSquared(e,t,i){const n=t.geometry;if("Circle"===n.getType()){let r=n;if(1===t.index){const t=getUserProjection();t&&(r=r.clone().transform(t,i));const n=squaredCoordinateDistance(r.getCenter(),fromUserCoordinate(e,i)),o=Math.sqrt(n)-r.getRadius();return o*o}}const r=fromUserCoordinate(e,i);return tempSegment[0]=fromUserCoordinate(t.segment[0],i),tempSegment[1]=fromUserCoordinate(t.segment[1],i),squaredDistanceToSegment(r,tempSegment)}function closestOnSegmentData(e,t,i){const n=t.geometry;if("Circle"===n.getType()&&1===t.index){let t=n;const r=getUserProjection();return r&&(t=t.clone().transform(r,i)),toUserCoordinate(t.getClosestPoint(fromUserCoordinate(e,i)),i)}const r=fromUserCoordinate(e,i);return tempSegment[0]=fromUserCoordinate(t.segment[0],i),tempSegment[1]=fromUserCoordinate(t.segment[1],i),toUserCoordinate(closestOnSegment(r,tempSegment),i)}function getDefaultStyleFunction(){const e=createEditingStyle();return function(t,i){return e.Point}}export default Modify;
//# sourceMappingURL=/sm/ca2c19a4a12c35748ba83e537a0edcceacc042dfadc2b9f7ad38fb141dac8aa0.map