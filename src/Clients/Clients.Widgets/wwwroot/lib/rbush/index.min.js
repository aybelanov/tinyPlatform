/**
 * Minified by jsDelivr using Terser v5.17.1.
 * Original file: /npm/rbush@3.0.1/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import quickselect from"quickselect";export default class RBush{constructor(t=9){this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}all(){return this._all(this.data,[])}search(t){let e=this.data;const i=[];if(!intersects(t,e))return i;const n=this.toBBox,r=[];for(;e;){for(let h=0;h<e.children.length;h++){const a=e.children[h],s=e.leaf?n(a):a;intersects(t,s)&&(e.leaf?i.push(a):contains(t,s)?this._all(a,i):r.push(a))}e=r.pop()}return i}collides(t){let e=this.data;if(!intersects(t,e))return!1;const i=[];for(;e;){for(let n=0;n<e.children.length;n++){const r=e.children[n],h=e.leaf?this.toBBox(r):r;if(intersects(t,h)){if(e.leaf||contains(t,h))return!0;i.push(r)}}e=i.pop()}return!1}load(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(let e=0;e<t.length;e++)this.insert(t[e]);return this}let e=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===e.height)this._splitRoot(this.data,e);else{if(this.data.height<e.height){const t=this.data;this.data=e,e=t}this._insert(e,this.data.height-e.height-1,!0)}else this.data=e;return this}insert(t){return t&&this._insert(t,this.data.height-1),this}clear(){return this.data=createNode([]),this}remove(t,e){if(!t)return this;let i=this.data;const n=this.toBBox(t),r=[],h=[];let a,s,o;for(;i||r.length;){if(i||(i=r.pop(),s=r[r.length-1],a=h.pop(),o=!0),i.leaf){const n=findItem(t,i.children,e);if(-1!==n)return i.children.splice(n,1),r.push(i),this._condense(r),this}o||i.leaf||!contains(i,n)?s?(a++,i=s.children[a],o=!1):i=null:(r.push(i),h.push(a),a=0,s=i,i=i.children[0])}return this}toBBox(t){return t}compareMinX(t,e){return t.minX-e.minX}compareMinY(t,e){return t.minY-e.minY}toJSON(){return this.data}fromJSON(t){return this.data=t,this}_all(t,e){const i=[];for(;t;)t.leaf?e.push(...t.children):i.push(...t.children),t=i.pop();return e}_build(t,e,i,n){const r=i-e+1;let h,a=this._maxEntries;if(r<=a)return h=createNode(t.slice(e,i+1)),calcBBox(h,this.toBBox),h;n||(n=Math.ceil(Math.log(r)/Math.log(a)),a=Math.ceil(r/Math.pow(a,n-1))),h=createNode([]),h.leaf=!1,h.height=n;const s=Math.ceil(r/a),o=s*Math.ceil(Math.sqrt(a));multiSelect(t,e,i,o,this.compareMinX);for(let r=e;r<=i;r+=o){const e=Math.min(r+o-1,i);multiSelect(t,r,e,s,this.compareMinY);for(let i=r;i<=e;i+=s){const r=Math.min(i+s-1,e);h.children.push(this._build(t,i,r,n-1))}}return calcBBox(h,this.toBBox),h}_chooseSubtree(t,e,i,n){for(;n.push(e),!e.leaf&&n.length-1!==i;){let i,n=1/0,r=1/0;for(let h=0;h<e.children.length;h++){const a=e.children[h],s=bboxArea(a),o=enlargedArea(t,a)-s;o<r?(r=o,n=s<n?s:n,i=a):o===r&&s<n&&(n=s,i=a)}e=i||e.children[0]}return e}_insert(t,e,i){const n=i?t:this.toBBox(t),r=[],h=this._chooseSubtree(n,this.data,e,r);for(h.children.push(t),extend(h,n);e>=0&&r[e].children.length>this._maxEntries;)this._split(r,e),e--;this._adjustParentBBoxes(n,r,e)}_split(t,e){const i=t[e],n=i.children.length,r=this._minEntries;this._chooseSplitAxis(i,r,n);const h=this._chooseSplitIndex(i,r,n),a=createNode(i.children.splice(h,i.children.length-h));a.height=i.height,a.leaf=i.leaf,calcBBox(i,this.toBBox),calcBBox(a,this.toBBox),e?t[e-1].children.push(a):this._splitRoot(i,a)}_splitRoot(t,e){this.data=createNode([t,e]),this.data.height=t.height+1,this.data.leaf=!1,calcBBox(this.data,this.toBBox)}_chooseSplitIndex(t,e,i){let n,r=1/0,h=1/0;for(let a=e;a<=i-e;a++){const e=distBBox(t,0,a,this.toBBox),s=distBBox(t,a,i,this.toBBox),o=intersectionArea(e,s),l=bboxArea(e)+bboxArea(s);o<r?(r=o,n=a,h=l<h?l:h):o===r&&l<h&&(h=l,n=a)}return n||i-e}_chooseSplitAxis(t,e,i){const n=t.leaf?this.compareMinX:compareNodeMinX,r=t.leaf?this.compareMinY:compareNodeMinY;this._allDistMargin(t,e,i,n)<this._allDistMargin(t,e,i,r)&&t.children.sort(n)}_allDistMargin(t,e,i,n){t.children.sort(n);const r=this.toBBox,h=distBBox(t,0,e,r),a=distBBox(t,i-e,i,r);let s=bboxMargin(h)+bboxMargin(a);for(let n=e;n<i-e;n++){const e=t.children[n];extend(h,t.leaf?r(e):e),s+=bboxMargin(h)}for(let n=i-e-1;n>=e;n--){const e=t.children[n];extend(a,t.leaf?r(e):e),s+=bboxMargin(a)}return s}_adjustParentBBoxes(t,e,i){for(let n=i;n>=0;n--)extend(e[n],t)}_condense(t){for(let e,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(e=t[i-1].children,e.splice(e.indexOf(t[i]),1)):this.clear():calcBBox(t[i],this.toBBox)}}function findItem(t,e,i){if(!i)return e.indexOf(t);for(let n=0;n<e.length;n++)if(i(t,e[n]))return n;return-1}function calcBBox(t,e){distBBox(t,0,t.children.length,e,t)}function distBBox(t,e,i,n,r){r||(r=createNode(null)),r.minX=1/0,r.minY=1/0,r.maxX=-1/0,r.maxY=-1/0;for(let h=e;h<i;h++){const e=t.children[h];extend(r,t.leaf?n(e):e)}return r}function extend(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function compareNodeMinX(t,e){return t.minX-e.minX}function compareNodeMinY(t,e){return t.minY-e.minY}function bboxArea(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function bboxMargin(t){return t.maxX-t.minX+(t.maxY-t.minY)}function enlargedArea(t,e){return(Math.max(e.maxX,t.maxX)-Math.min(e.minX,t.minX))*(Math.max(e.maxY,t.maxY)-Math.min(e.minY,t.minY))}function intersectionArea(t,e){const i=Math.max(t.minX,e.minX),n=Math.max(t.minY,e.minY),r=Math.min(t.maxX,e.maxX),h=Math.min(t.maxY,e.maxY);return Math.max(0,r-i)*Math.max(0,h-n)}function contains(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function intersects(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function createNode(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function multiSelect(t,e,i,n,r){const h=[e,i];for(;h.length;){if((i=h.pop())-(e=h.pop())<=n)continue;const a=e+Math.ceil((i-e)/n/2)*n;quickselect(t,a,e,i,r),h.push(e,a,a,i)}}
//# sourceMappingURL=/sm/6a66a7b665f66c8e8a30b8105dd227b3dd4d3e64dbb88b41e4a485af9f98828b.map